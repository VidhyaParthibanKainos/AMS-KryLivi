<?xml version="1.0" encoding="UTF-8"?>
<beans
     xmlns="http://www.springframework.org/schema/beans"
     xmlns:beans="http://www.springframework.org/schema/beans"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:cc="http://www.capeclear.com/assembly/10"
     xmlns:cloud="urn:com.workday/esb/cloud/10.0"
     xmlns:env="http://schemas.xmlsoap.org/soap/envelope/"
     xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
     xmlns:pi="urn:com.workday/picof"
     xmlns:wd="urn:com.workday/bsvc"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 
	<cc:assembly id="SetHeaders" version="2020.36">
        <cc:local-out id="PIM_Debug_Stats_Primary_142" store-message="none" execute-when="props['sskPrimaryLogCountDebug'] > 0" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'DEBUG'"/>
            <cc:set name="is.message.summary" value="props['sskPrimaryLogCountDebug'] + ' debug message(s) added!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Info_Stats_Primary_142" store-message="none" execute-when="props['sskPrimaryLogCountInfo'] > 0" routes-response-to="PIM_Debug_Stats_Primary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="props['sskPrimaryLogCountInfo'] + ' informational message(s) added!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Warning_Stats_Primary_142" store-message="none" execute-when="props['sskPrimaryLogCountWarn'] > 0" routes-response-to="PIM_Info_Stats_Primary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'WARNING'"/>
            <cc:set name="is.message.summary" value="props['sskPrimaryLogCountWarn'] + ' warning(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Error_Stats_Primary_142" store-message="none" execute-when="props['sskPrimaryLogCountError'] > 0" routes-response-to="PIM_Warning_Stats_Primary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'ERROR'"/>
            <cc:set name="is.message.summary" value="props['sskPrimaryLogCountError'] + ' error(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Critical_Stats_Primary_142" store-message="none" execute-when="props['sskPrimaryLogCountFatal'] > 0" routes-response-to="PIM_Error_Stats_Primary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'CRITICAL'"/>
            <cc:set name="is.message.summary" value="props['sskPrimaryLogCountFatal'] + ' fatal error(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-in id="LogStatsPrimary" routes-to="PIM_Critical_Stats_Primary_142" access="private"/>
        <cc:local-out id="Call_LogStatsPrimary_142" execute-when="props['inLogFinalize']" endpoint="vm://INT006_Greenhouse_Inbound/LogStatsPrimary"/>
        <cc:async-mediation id="OutputPrimaryLog_142" routes-to="Call_LogStatsPrimary_142" execute-steps-when="com.workday.custom.int006.ssk142.GeneralCloudLogHelper.isLogReadyForOutput(context, 'primary');">
            <cc:steps>
                <cc:eval id="Setup">
                    <cc:expression>props['sskPrimaryLogFilesStored'] = props['sskPrimaryLogFilesStored'] + 1</cc:expression>
                    <cc:expression>if (props['sskPrimaryLogFileFormat'] == 'HTML') {&#xD;
	props['localPrimaryLogFileExtension'] = '.html';&#xD;
} else if (props['sskPrimaryLogFileFormat'] == 'CSV') {&#xD;
	props['localPrimaryLogFileExtension'] = '.csv';&#xD;
} else {&#xD;
	props['localPrimaryLogFileExtension'] = '.xlsx';&#xD;
}</cc:expression>
                    <cc:expression>props['localPrimaryLogFilenameForStorage'] = (props['sskPrimaryLogMaxCountPerFile'] == 0) ? props['sskPrimaryLogFilename'] # props['localPrimaryLogFileExtension'] : props['sskPrimaryLogFilename'] # &quot;_&quot; # props['sskPrimaryLogFilesStored'] # props['localPrimaryLogFileExtension']</cc:expression>
                </cc:eval>
                <cc:store id="StoreCloudLog" input="variable" input-variable="cloud-log-primary" createDocumentReference="true" expiresIn="@{props['sskPrimaryLogExpires']}" title="@{props['localPrimaryLogFilenameForStorage']}"/>
                <cc:eval id="Reset">
                    <cc:expression>vars['cloud-log-primary'] = null</cc:expression>
                    <cc:expression>props['sskPrimaryLogCountByLogFile'] = 0</cc:expression>
                    <cc:expression>foreach (propname : ['localPrimaryLogFilenameForStorage']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="StoreLogPrimary" routes-to="OutputPrimaryLog_142" access="public">
            <cc:parameter default="false" name="inLogFinalize" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_StoreLogPrimary_142" endpoint="vm://INT006_Greenhouse_Inbound/StoreLogPrimary">
            <cc:set name="inLogFinalize" value="false"/>
        </cc:local-out>
        <cc:local-in id="CreateLogEntry" routes-to="RoutePrimaryLogType_142" access="public" icon="icons/CreateLogEntry.png">
            <cc:parameter documentation="Value that will be written to the Message attribute of the Cloud Logger." name="inLogMessage" required="true" type="string"/>
            <cc:parameter documentation="Value that will be written to the Message Details attribute of the Cloud Logger." name="inLogMessageDetail" required="false" type="string"/>
            <cc:parameter documentation="Value that will be written to the Reference Id attribute of the Cloud Logger.  This is most commonly used to record the WID of the record to which this message pertains and can save the MVEL code of concatenating it into the Message Detail." name="inLogReferenceId" required="false" type="string"/>
            <cc:parameter documentation="Value that determines the Level attribute of the Cloud Logger.  Must be one of: debug, info, warn, error, fatal." name="inLogLevel" required="true" type="string" validation="['debug','info','warn','error','fatal'] contains props['inLogLevel'].trim().toLowerCase()"/>
            <cc:parameter documentation="Value written to the LocalIn Extra Column on the log.  This field is a convention of SSK and used to record the name of a Mediation related to the message, e.g. the errorComponentId causing an error to be raised." name="inExtraLocalIn" required="false"/>
            <cc:parameter documentation="Value written to the RecordNumber Extra Column on the log.  This field is a convention of SSK and used to record the position/count of a data record in a set to which this message pertains." name="inExtraRecordNumber" required="false"/>
            <cc:parameter documentation="Value written to the SupportData Extra Column on the log.  This field is a convention of SSK and used to provide open-ended advice for support.  This may constitute additional data values, or it may mean remediation advice for a particular error." name="inExtraSupportData" required="false"/><cc:parameter documentation="Value written to the ErrorCode Extra Column on the log.  This field is a convention of SSK and used to provide the value of the error code when the message is logging error information.  This code may be given by the ESB, or it may be a custom code defined by the developer.  Note that this field is a String whereas Studio/ESB codes are integers, so type conversion is required." name="inExtraErrorCode" required="false"/>
        </cc:local-in>
        <cc:local-out id="Call_StoreLogPrimary_GEH" routes-response-to="Call_StoreLogSecondary_GEH" endpoint="vm://INT006_Greenhouse_Inbound/StoreLogPrimary" propagate-abort="false">
            <cc:set name="inLogFinalize" value="true"/>
        </cc:local-out>
        <cc:local-out id="PIM_CriticalUnhandledException_GEH" store-message="none" routes-response-to="Call_StoreLogPrimary_GEH" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'CRITICAL'"/>
            <cc:set name="is.message.summary" value="'An unhandled error was encountered!'"/>
            <cc:set name="is.message.detail" value="'Error Message: ' + context.getErrorMessage()"/>
        </cc:local-out>
        <cc:send-error id="GlobalErrorHandler" routes-to="PIM_CriticalUnhandledException_GEH"/>
        <cc:local-out id="Call_StoreLogPrimary" store-message="none" routes-response-to="Call_StoreLogSecondary" endpoint="vm://INT006_Greenhouse_Inbound/StoreLogPrimary">
            <cc:set name="inLogFinalize" value="true"/>
        </cc:local-out>
        <cc:local-out id="Call_Main_109" store-message="none" endpoint="@{props['inMainEndpoint']}" propagate-abort="false"/>
        <cc:async-mediation id="Initialize_Handler_109">
            <cc:steps>
                <cc:eval id="Abort">
                    <cc:expression>context.setAbort(true);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_Error_109" store-message="none" routes-response-to="Call_StoreLogPrimary_Error_109" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'An error occurred within the integration flow and has been caught by the SSK framework.'"/>
            <cc:set name="inLogMessageDetail" value="'The exception was trapped at the top-level just before the Global Error Handler.  See the Support Detail for additional error information, and see the Local-In for the component at which the exception was raised.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            
        <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/><cc:set name="inExtraSupportDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/></cc:local-out>
        <cc:async-mediation id="TopLevelErrorTrap_109" routes-to="Call_Debug_Core_109" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_CreateLogEntry_Error_109"/>
        </cc:async-mediation>
        <cc:workday-in id="StartHere" routes-to="Foundation">
            <cc:integration-system name="INT006 Greenhouse Inbound">
        <cloud:param name="Run in Validation Mode">
          <cloud:type>
            <cloud:simple-type>boolean</cloud:simple-type>
          </cloud:type>
          <cloud:default>
            <cloud:boolean>false</cloud:boolean>
          </cloud:default>
        </cloud:param>
        <cloud:param name="Run with Debug Logging">
          <cloud:type>
            <cloud:simple-type>boolean</cloud:simple-type>
          </cloud:type>
          <cloud:default>
            <cloud:boolean>false</cloud:boolean>
          </cloud:default>
        </cloud:param>
        <cloud:param name="Source Integration Event WID (Build and Debug Only)">
          <cloud:type>
            <cloud:simple-type>text</cloud:simple-type>
          </cloud:type>
        </cloud:param>
        <cloud:attribute-map-service name="int006 Greenhouse Inbound Attribute Map Service - General">
          <cloud:attribute name="Document Retention in Days">
            <cloud:type>
              <cloud:simple-type>number</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
        </cloud:attribute-map-service>
        <cloud:attribute-map-service name="int006 Greenhouse Inbound Attribute Map Service - Primary Logging">
          <cloud:attribute name="Log File Name (Exclude File Extension)">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Log Retention in Days">
            <cloud:type>
              <cloud:simple-type>number</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Max Entries per Log File">
            <cloud:type>
              <cloud:simple-type>number</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Cloud Log Output File Type">
            <cloud:type>
              <cloud:enumeration-type name="CloudLogOutputFileType">
                <cloud:enumeration>HTML</cloud:enumeration>
                <cloud:enumeration>CSV</cloud:enumeration>
                <cloud:enumeration>XLSX</cloud:enumeration>
              </cloud:enumeration-type>
            </cloud:type>
            <cloud:display-option>required-for-launch</cloud:display-option>
          </cloud:attribute>
        </cloud:attribute-map-service>
        <cloud:attribute-map-service name="int006 Greenhouse Inbound Attribute Map Service - Secondary Logging">
          <cloud:attribute name="Log File Name (Exclude File Extension)">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Log Retention in Days">
            <cloud:type>
              <cloud:simple-type>number</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Max Entries per Log File">
            <cloud:type>
              <cloud:simple-type>number</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Cloud Log Output File Type">
            <cloud:type>
              <cloud:enumeration-type name="CloudLogOutputFileType">
                <cloud:enumeration>HTML</cloud:enumeration>
                <cloud:enumeration>CSV</cloud:enumeration>
                <cloud:enumeration>XLSX</cloud:enumeration>
              </cloud:enumeration-type>
            </cloud:type>
            <cloud:display-option>required-for-launch</cloud:display-option>
          </cloud:attribute>
        </cloud:attribute-map-service>
        <cloud:attribute-map-service name="int006 Greenhouse Inbound Attribute Map Service - Functional">
          <cloud:attribute name="Output File Name (Include File Extension)">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Delivery Document Tag(s)">
            <cloud:type>
              <cloud:class-report-field description="Document Tags" type="WID" singular="false">eef1d7fe8ea9408e85a43ce755c69ef2</cloud:class-report-field>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Retrieval Document Tag(s)">
            <cloud:type>
              <cloud:class-report-field description="Document Tag" type="WID" singular="false">5242ed284a574130affb6653f3e0d93b</cloud:class-report-field>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Retrieval Document Tag Match Strategy">
            <cloud:type>
              <cloud:enumeration-type name="DocumentTagMatchType">
                <cloud:enumeration>Any</cloud:enumeration>
                <cloud:enumeration>All</cloud:enumeration>
              </cloud:enumeration-type>
            </cloud:type>
          </cloud:attribute>
        </cloud:attribute-map-service>
        <cloud:attribute-map-service name="int006 Greenhouse Inbound Source ID Map">
          <cloud:map name="Source">
            <cloud:internal-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:internal-type>
            <cloud:external-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:external-type>
          </cloud:map>
        </cloud:attribute-map-service>
        <cloud:report-service name="int006 Greenhouse Inbound Report Service">
          <cloud:report-alias description="INT006_Reasons" name="int006_Reasons">
            <cloud:report-reference description="INT006_Reasons" type="WID">59d384871e5610141762272e904a0000</cloud:report-reference>
          </cloud:report-alias>
          <cloud:report-alias description="INT006_Country" name="int006_Country">
            <cloud:report-reference description="INT006_Country" type="WID">59d384871e561014172b66d0c09d0000</cloud:report-reference>
          </cloud:report-alias>
          <cloud:report-alias description="INT006_JobRequisitions" name="int006_JobReq">
            <cloud:report-reference description="INT006_JobRequisitions" type="WID">59d384871e561014179dd198b2ed0000</cloud:report-reference>
          </cloud:report-alias>
        </cloud:report-service>
      </cc:integration-system>
        </cc:workday-in>
        <cc:async-mediation id="InitializeAttributesAndLaunchParameters" routes-to="AsyncMediation11" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="Eval">
                    <cc:expression>props['webhookFilename']=da.getFileName(0)</cc:expression>
                    <cc:expression>da.toVar(props['webhookFilename'], 'webhookFile')</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="HandleError_CustomLogic"/>
        </cc:async-mediation>
        <cc:async-mediation id="Results_Handler_103" routes-to="Call_HandleError_Results_Error_103">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Results_Error_103" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the SOAP results from the message rootpart to variable '# props['inReturnResults'] #'.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_103'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inReturnResults'"/>
            
         <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/><cc:set name="inLogTarget" value="'primary'"/></cc:local-out>
        <cc:async-mediation id="Results_103" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars[props.inReturnResults] = parts[0];</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Results_Handler_103"/>
        </cc:async-mediation>
        <cc:async-mediation id="RouteError_Http_Handler_103" routes-to="Call_HandleError_HttpError_Error_103">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'http';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_HttpError_Error_103" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError" clone-request="false">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] #' application HTTP request error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while executing a SOAP request for the '# props['inWebServiceApplication'] #' application.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? context.errorCode : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_103'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="'SOAP-Request__' # props['inWebServiceApplication']"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/><cc:set name="inLogTarget" value="'primary'"/></cc:local-out>
        <cc:async-mediation id="CallSoap_Catch_103" routes-to="CallSoap_103" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="RouteError_103"/>
        </cc:async-mediation>
        <cc:workday-out-soap id="CallSoap_103" store-message="none" routes-response-to="Call_Debug_SoapResponse_103" application="@{props['inWebServiceApplication']}" version="@{props['inApiVersion']}"/>
        <cc:sync-mediation id="InitializeAndFinalize_103" routes-to="Call_BuildRequest_103" routes-response-to="Call_Finally_103">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['outIsSoapError'] = '';&#xD;
props['outErrorMessage'] = '';</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
        </cc:sync-mediation>
        <cc:async-mediation id="Teardown_103">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsQualifierTyped','localIsValueDefined','localIsValueTyped']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_103" routes-to="Teardown_103"/>
        <cc:local-out id="Call_Finally_103" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_103"/>
        <cc:local-in id="CallSoap" routes-to="InitializeAndFinalize_103" access="public" icon="icons/CallSoap.png">
            <cc:parameter default="props['globalApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter documentation="The WWS application where the operation may be found, e.g. &quot;Human_Resources&quot;." name="inWebServiceApplication" required="true" type="string"/>
            <cc:parameter documentation="The location that holds the data to be used in the transform provided on the inPathToXsltFile parameter.  This value is dependent on the value of inDataLocationId.  The parameter can have one of three values: message, variable, or property.  When the value is 'message', then the message part identified by inDataLocationId is interpreted as XML data to which the inPathToXsltFile xslt will be applied.  Similarly, if this parameter value is 'variable', then the variable identified by inDataLocationId is interpreted as XML data to which the inPathToXsltFile xslt will be applied.  if this parameter value is 'property', then the property identified by inDataLocationId is interpreted as a java.util.Map instance whose key/value pairs match pre-defined keys in the inPathToXsltFile xslt for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inBuildRequestDataLocation" required="props['inBuildRequestPathToXsltFile'] != empty" type="string" validation="((props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (['message','variable','property'] contains props['inBuildRequestDataLocation'].trim().toLowerCase())) ||&#xD;&#xA;&#x9;((props['inBuildRequestPathToXsltFile'] == empty) &amp;&amp; (props['inBuildRequestDataLocation'] == empty))"/>
            <cc:parameter documentation="The name that, when used with inBuildReqeustDataLocation, uniquely identifies which variable or property is to be used as the source data to which the transform provided on the inBuildReqeustPathToXsltFile parameter will be applied.  When inBuildReqeustDataLocation is 'message', then this parameter is ignored and the message root part is assumed." name="inBuildRequestDataLocationId" required="(props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'].trim().toLowerCase() != 'message')" type="string" validation="((props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'].trim().toLowerCase() != 'message') &amp;&amp; (props['inBuildRequestDataLocationId'] != empty)) ||&#xD;&#xA;&#x9;((props['inBuildRequestPathToXsltFile'] == empty) &amp;&amp; (props['inBuildRequestDataLocationId'] == empty))"/>
            <cc:parameter documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot; using the data identified by the inDataLocation and inDataLocationId input parameters.  This SSK Component also supports pre-built, on-message requests as well as facilities to construct the request dynamically.  If this parameter is omitted or set to null / an empty string, then inDataLocation and inDataLocationId can also be omitted (they are ignored), and then the dynamic request construction will be bypassed and the message root part will be used as the request." name="inBuildRequestPathToXsltFile" required="(props['inBuildRequestDataLocation'] != empty) || (props['inBuildRequestDataLocationId'] != empty)" type="string"/>
            <cc:parameter default="'message'" documentation="How the SOAP results are returned to the caller.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found.  " name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="'primary'" documentation="In the event of a SOAP error from the tenant, this parameter controls whether the message is logged to the primary or secondary logs.  Component processing, Studio validation messages, and hard HTTP errors will still go to the primary log, but data-level messages returned on the SOAP API will be directed per this configuration.  Note that the Extra Column configuration of the default secondary log is still coded and therefore assumed." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/><cc:parameter default="props['sskIsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        	
        	<cc:out-parameter documentation="A string to indicate that the request resulted in an error and identify the type.  If the error was at the API level, then outIsSoapError == 'http'.  If the error was at the tenant/application level, then outIsSoapError == 'soap'.  If there was an error unrelated to the API call, then outIsSoapError == 'logic'.  If there is no error, , then outIsSoapError == empty.  Further individual errors determined by Get_Event_Details or Get_Import_Processes are not handled here." name="outIsSoapError"/>
	        <cc:out-parameter documentation="The error message of the exception for possible higher-level logging needs." name="outErrorMessage"/>
	    </cc:local-in>
        <cc:local-out id="Call_CreateLogEntry_Error_105" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            
        <cc:set name="inLogMessage" value="'Error generated during loading of Java Map'"/><cc:set name="inLogMessageDetail" value="parts[0].xpath('/Error')"/><cc:set name="inLogLevel" value="'error'"/><cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_Error_105'"/></cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Warn_105" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry"><cc:set name="inLogMessage" value="'Warning generated during loading of Java Map'"/><cc:set name="inLogMessageDetail" value="parts[0].xpath('/Warning')"/><cc:set name="inLogLevel" value="'warn'"/><cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_Warn_105'"/>
        </cc:local-out>
        <cc:route id="RouteMessages_105">
            <cc:xpath-strategy>
                <cc:choose-route expression="exists( /Warning )" route="Warning"/>
                <cc:choose-route expression="exists( /Error )" route="Error"/>
            </cc:xpath-strategy>
            <cc:sub-route name="Warning" routes-to="Call_CreateLogEntry_Warn_105"/>
            <cc:sub-route name="Error" routes-to="Call_CreateLogEntry_Error_105"/>
        </cc:route>
        <cc:splitter id="Splitter_105" no-split-message-error="false">
            <cc:sub-route name="RouteResult" routes-to="RouteMessages_105"/>
            <cc:xml-stream-splitter xpath="/*/*"/>
        </cc:splitter>
        <cc:sync-mediation id="LoadMap_105" routes-to="Splitter_105">
            <cc:request-steps>
                <cc:xslt-plus id="LoadMap" url="mctx:vars/localXslt105"/>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_LoadMap_Error_105"/>
        </cc:sync-mediation>
        <cc:sync-mediation id="PrepareForLoadMap_105" routes-to="LoadMap_105" routes-response-to="Call_Finally_105">
            <cc:request-steps>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10500" failure-message="Property 'inMap' does not contain a Java Map">map = props['inMap'];
return (map == null ) ||
	(( map != null) &amp;&amp; (map instanceof java.util.Map));</cc:expression>
                </cc:validate-exp>
                <cc:eval id="SetValues">
                    <cc:expression>props['outMap'] = props['inMap'];</cc:expression>
                    <cc:expression>// If the map property is not current assigned then create a new HashMap in it
if (props['outMap'] == empty) {&#xD;
	props['outMap'] = new java.util.HashMap();&#xD;
}</cc:expression>
                    <cc:expression>props['localMapPropertyName'] = 'outMap'</cc:expression>
                </cc:eval>
                <cc:write id="LoadXslt" output="variable" output-variable="localXslt105">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;xsl:stylesheet version=&quot;3.0&quot; &#xD;
    xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&#xD;
    xmlns:tube=&quot;java:com.capeclear.mediation.impl.cc.MediationTube&quot;&#xD;
    xmlns:ctx=&quot;java:com.capeclear.mediation.MediationContext&quot;&#xD;
    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&#xD;
    xmlns:jmap=&quot;java:java.util.Map&quot;&#xD;
    xmlns:jt=&quot;http://saxon.sf.net/java-type&quot;&#xD;
    xmlns:this=&quot;urn:this&quot;>&#xD;
    &#xD;
    &lt;xsl:param name=&quot;inStoreDataAs&quot; as=&quot;xs:string&quot;/>&#xD;
    &lt;xsl:param name=&quot;inQueryToEntry&quot; as=&quot;xs:string&quot;/>&#xD;
    &lt;xsl:param name=&quot;inQueryToKey&quot; as=&quot;xs:string&quot;/>&#xD;
    &lt;xsl:param name=&quot;inQueryToValue&quot; as=&quot;xs:string&quot;/>&#xD;
    &lt;xsl:param name=&quot;localMapPropertyName&quot; as=&quot;xs:string&quot;/>&#xD;
    &lt;xsl:param name=&quot;inEmptyValueIsError&quot; as=&quot;xs:boolean&quot; select=&quot;true()&quot;/>&#xD;
    &#xD;
    &lt;!-- This stylesheet is designed to be streamable so that only one record is held in memory at any one time -->&#xD;
    &lt;xsl:mode streamable=&quot;yes&quot; on-no-match=&quot;shallow-skip&quot;/>&#xD;
    &lt;xsl:mode streamable=&quot;no&quot; name=&quot;in-memory&quot;/>&#xD;
    &#xD;
    &lt;!-- Obtain the current MediationContext in use in the assembly -->&#xD;
    &lt;xsl:variable name=&quot;ctx&quot; select=&quot;tube:getCurrentMediationContext()&quot;/>&#xD;
    &#xD;
    &lt;!-- Retrieve the Java Map stored in the context property named HashMap -->&#xD;
    &lt;xsl:variable name=&quot;Map&quot; select=&quot;ctx:getProperty($ctx, $localMapPropertyName)&quot; as=&quot;jt:java.util.Map&quot;/>&#xD;
    &#xD;
    &lt;!-- Based on the configuration of the StoreDataAs property determine the function which will be used to store the values in the map.  Using the function reference allows us to avoid the inefficiency of comparing the value of StoreDataAs for each entry -->&#xD;
    &lt;xsl:variable name=&quot;StoreDataInMap&quot; select=&quot;if ( $inStoreDataAs = 'SimpleString') then this:StoreDataAsSimpleString#2 else if ($inStoreDataAs = 'DOM') then this:StoreDataAsDOM#2 else this:StoreDataAsXMLString#2&quot; />&#xD;
    &#xD;
    &lt;xsl:template match=&quot;/&quot;>&#xD;
        &lt;MapHelper>&#xD;
            &lt;xsl:if test=&quot;$inStoreDataAs = 'XMLString'&quot;>&#xD;
                &lt;Warning>Map entries are configured to be stored as XMLStrings.  Using this will require that data is re-parsed every time the data is used.  This could impose a significant runtime performance overhead if each entry is, on average, accessed more than once&lt;/Warning>&#xD;
            &lt;/xsl:if>&#xD;
            &lt;xsl:if test=&quot;$inStoreDataAs = 'DOM'&quot;>&#xD;
                &lt;Warning>Map entries are configured to be stored as an XML DOM.  Using this option may require large amounts of memory.  Consider transforming the data before storage so as to only store the minimum required.  For very large documents consider moving to a custom Java solution with optimized data storage&lt;/Warning>&#xD;
            &lt;/xsl:if>&#xD;
            &#xD;
            &lt;!-- Now process the input file.  The EntryFilter variable can then be optionally used to only select those entries matching that value.  The filter can only navigate the descendant axis since only the node and and descendants returned by the QueryToEntry expression are brought into memory -->&#xD;
            &lt;xsl:apply-templates select=&quot;@{props['inQueryToEntry']}/copy-of()@if{props['inEntryFilter'] != empty}[@{props['inEntryFilter']}]@end{}&quot; mode=&quot;in-memory&quot;/>    		&#xD;
        &lt;/MapHelper>&#xD;
    &lt;/xsl:template>&#xD;
    &#xD;
    &lt;!-- Process each entry -->&#xD;
    &lt;xsl:template match=&quot;*&quot; mode=&quot;in-memory&quot;>&#xD;
        &lt;xsl:variable name=&quot;key&quot;	select=&quot;@{props['inQueryToKey']}&quot;/>&#xD;
        &lt;xsl:variable name=&quot;value&quot;	select=&quot;@{props['inQueryToValue']}&quot;/>&#xD;
        &#xD;
        &lt;xsl:choose>&#xD;
            &lt;!-- If we've no key then we have no option but to generate an error -->&#xD;
            &lt;xsl:when test=&quot;not(exists($key))&quot;>&#xD;
                &lt;Error>&#xD;
                    &lt;Message>&lt;xsl:text expand-text=&quot;yes&quot;>No key matching {$inQueryToKey} found in record&lt;/xsl:text>&lt;/Message>&#xD;
                    &lt;Record>&lt;xsl:copy-of select=&quot;.&quot;/>&lt;/Record>&#xD;
                &lt;/Error>&#xD;
            &lt;/xsl:when>&#xD;
            &#xD;
            &lt;!-- If we've no value and we're configured to treat no value as an error then output that error, otherwise we'll put the empty value into the map -->&#xD;
            &lt;xsl:when test=&quot;not(exists($value)) and $inEmptyValueIsError&quot;>&#xD;
                &lt;Error>&#xD;
                    &lt;Message>&lt;xsl:text expand-text=&quot;yes&quot;>No value matching {$inQueryToValue} found in record&lt;/xsl:text>&lt;/Message>&#xD;
                    &lt;Record>&lt;xsl:copy-of select=&quot;.&quot;/>&lt;/Record>&#xD;
                &lt;/Error>				&#xD;
            &lt;/xsl:when>&#xD;
            &#xD;
            &lt;!-- Store the value in the map -->&#xD;
            &lt;xsl:otherwise>&#xD;
                &lt;xsl:value-of select=&quot;$StoreDataInMap($key,$value)&quot;/>&#xD;
            &lt;/xsl:otherwise>&#xD;
        &lt;/xsl:choose>&#xD;
    &lt;/xsl:template>&#xD;
    &#xD;
    &lt;xsl:function name=&quot;this:StoreDataAsSimpleString&quot;>&#xD;
        &lt;xsl:param name=&quot;key&quot; as=&quot;xs:string&quot;/>&#xD;
        &lt;xsl:param name=&quot;value&quot; as=&quot;item()&quot;/>&#xD;
        &lt;xsl:value-of select=&quot;jmap:put($Map, string($key), string($value))&quot;/>&#xD;
    &lt;/xsl:function>&#xD;
    &#xD;
    &lt;xsl:function name=&quot;this:StoreDataAsXMLString&quot;>&#xD;
        &lt;xsl:param name=&quot;key&quot; as=&quot;xs:string&quot;/>&#xD;
        &lt;xsl:param name=&quot;value&quot; as=&quot;item()&quot;/>&#xD;
        &lt;xsl:value-of select=&quot;jmap:put($Map, string($key), serialize($value))&quot;/>&#xD;
    &lt;/xsl:function>&#xD;
    &#xD;
    &lt;!-- &#xD;
    	This function is provided for future expansion.  There is no native way to export DOM information through Saxon Java extension functions such that the DOM (or NodeInfo) information can be processed&#xD;
    	elsewhere in the assembly since the Saxon Processor which was used to produce this information is not available to us outside of the XsltPlus step.&#xD;
    	&#xD;
    	In future, access to parsed DOM of the data will be provided through a Java extension function and a DOM implementation optimized for Workday-like data and map configurations.&#xD;
     -->&#xD;
    &lt;xsl:function name=&quot;this:StoreDataAsDOM&quot; >&#xD;
        &lt;xsl:param name=&quot;key&quot; as=&quot;xs:string&quot;/>&#xD;
        &lt;xsl:param name=&quot;value&quot; as=&quot;item()&quot;/>&#xD;
		&lt;xsl:value-of select=&quot;jmap:put($Map, string($key), $value)&quot;/>&#xD;
		&lt;xsl:message terminate=&quot;yes&quot; select=&quot;'Storage of DOM values in the map are not yet implemented'&quot;/>&#xD;
	&lt;/xsl:function>&#xD;
&lt;/xsl:stylesheet></cc:text>
                    </cc:message>
                </cc:write>
            </cc:request-steps>
            <cc:response-steps>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-in id="PopulateJavaMap" routes-to="PrepareForLoadMap_105" access="public" icon="icons/PopulateJavaMap.png">
            <cc:parameter documentation="The Java Map which is to be populated with the current message" name="inMap" required="false"/>
            <cc:parameter default="'SimpleString'" documentation="Determines whether the map will be populated with simple string values, an in-memory DOM or an XML String" name="inStoreDataAs" required="false" validation="['SimpleString','XMLString'].contains(props['inStoreDataAs'])"/>
            <cc:parameter documentation="The XPath expression selecting the records which contain the information to be put into the Map" name="inQueryToEntry" required="true" type="string" validation="props['inQueryToEntry'].trim().length() > 0"/>
            <cc:parameter documentation="XPath expression which can optionally be executed against the elements returned by QueryToEntry in order to determine if those entries should be stored in the map" name="inEntryFilter" required="false" type="string"/>
            <cc:parameter documentation="The XPath expression to select the Map key from each record.  This expression is executed against the element returned by the QueryToEntry expression" name="inQueryToKey" required="true" type="string" validation="props['inQueryToKey'].trim().length() > 0"/>
            <cc:parameter documentation="The XPath expression which returns the value to be stored in the map when executed against the element returned by the QueryToEntry expression" name="inQueryToValue" required="true" type="string" validation="props['inQueryToValue'].trim().length() > 0"/>
            <cc:parameter default="true" documentation="Controls whether empty map values are to be treated as errors" name="inEmptyValueIsError" required="false" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:out-parameter documentation="The Java Map which will have been populated with the data in the current message" name="outMap"/>
        </cc:local-in>
        <cc:local-out id="Call_HandleError_Results_Error_102" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the RaaS results from the message rootpart to variable globalRaaSResults.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
	        <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="Results_102" routes-to="Call_Debug_Result_102" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars[props.inReturnResults] = parts[0].source;</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Results_Error_102"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_CallRaaS_Error_102" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Execution Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while executing reports-as-a-service for the '# props['inReportServiceAlias'] #' report alias.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
	        <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="CallRaaS_Catch_102" routes-to="CallRaaS_102" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CallRaaS_Error_102"/>
        </cc:async-mediation>
        <cc:workday-out-rest id="CallRaaS_102" store-message="none" extra-path="@{props['localRestUrl']}" method="GET"/>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Error_102" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Preparation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a reports-as-a-service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
	        <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_102" routes-to="ChooseProtocol_102" continue-after-error="rewind" handle-downstream-errors="true" routes-response-to="Call_Finally_102">
            <cc:request-steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>props['localIsPromptsProvided'] = props['inPropertyNameReportPromptMap'] != empty;</cc:expression>
                    <cc:expression>props['localIsPromptsMap'] = (props['localIsPromptsProvided']) ? (context.getProperty(props['inPropertyNameReportPromptMap']) instanceof java.util.Map) : false;&#xD;
props['localIsPromptsEmpty'] = (props['localIsPromptsProvided']) ? (context.getProperty(props['inPropertyNameReportPromptMap']).isEmpty()) : false;</cc:expression>
                    <cc:expression>props['localIsPromptsValid'] = (!props['localIsPromptsProvided']) || (props['localIsPromptsMap'] &amp;&amp; !props['localIsPromptsEmpty']);</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10200" failure-message="The map contained in the property @{props['inPropertyNameReportPromptMap']} as specified on the input parameter inPropertyNameReportPromptMap was either empty, or it was not a map.">props['localIsPromptsValid']</cc:expression>
                </cc:validate-exp>
                <cc:eval id="BuildURL">
                    <cc:expression>props['localRestUrl'] = intsys.reportService.getExtrapath(props['inReportServiceAlias']);</cc:expression>
                    <cc:expression>props['localQuerystring'] = '';</cc:expression>
                    <cc:expression>if (props['localIsPromptsProvided']) {&#xD;
	props['localKeyValueMap'] = context.getProperty(props['inPropertyNameReportPromptMap']);&#xD;
&#xD;
	foreach (mapKey : props['localKeyValueMap'].keySet()) {&#xD;
		if (props['localQuerystring'] != empty) {props['localQuerystring'] = props['localQuerystring'] # '&amp;';}&#xD;
&#xD;
		mapValue = props['localKeyValueMap'].get(String.valueOf(mapKey));&#xD;
		if (mapValue instanceof java.util.AbstractCollection) {&#xD;
			props['localQuerystring'] = props['localQuerystring'] # String.valueOf(mapKey) # '=' # com.workday.custom.int006.ssk102.ParameterMapHelper.transformCollectionParameterToQueryString(mapValue, props.inIsUseJavaUrlEncoder);&#xD;
		} else {&#xD;
			props['localQuerystring'] = props['localQuerystring'] # String.valueOf(mapKey) # '=' # com.workday.custom.int006.ssk102.ParameterMapHelper.urlEscapeValue(String.valueOf(mapValue), props.inIsUseJavaUrlEncoder);&#xD;
		}&#xD;
	}&#xD;
	props['localRestUrl'] = props['localRestUrl'] # '?' # props['localQuerystring'];&#xD;
}</cc:expression>
                    <cc:expression>props['localIsValidUrlLength'] = props['localRestUrl'].getBytes().length &lt;= 16000;</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Error_102"/>
        </cc:sync-mediation>
        <cc:async-mediation id="Teardown_102">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsPromptsProvided','localIsPromptsValid','localRestUrl','localQuerystring','localKeyValueMap','localIsPromptsMap','localIsPromptsEmpty','localFilename','localProgressedToAPI','localIsValidUrlLength']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_102" routes-to="Teardown_102"/>
        <cc:local-out id="Call_Finally_102" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_102"/>
        <cc:local-in id="CallRaaS" routes-to="InitializeAndFinalize_102" access="public" icon="icons/CallRaaS.png">
            <cc:parameter documentation="The Report Service configuration from which to retrieve results." name="inReportServiceAlias" required="true" type="string"/>
            <cc:parameter default="false" documentation="Controls whether or not the RaaS results are saved to a file that is then attached to the Integration Event for support purposes." name="inSaveResultsToIntegrationEvent" required="true" type="boolean"/>
            <cc:parameter documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  If the report is not parameterized, then leave this input parameter empty.  If setting this input parameter though, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap." name="inPropertyNameReportPromptMap" required="false" type="string"/><cc:parameter default="false" documentation="Parameter decides how the prompt values are URLEncoded.  True = use java.net.URLEncoder, which encodes the most characters possible.  False = use implementation in ParameterMapHelper that encodes the minimum characters necessary." name="inIsUseJavaUrlEncoder" required="true" type="boolean"/><cc:parameter default="'message'" documentation="Where the results of the response are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="'primary'" documentation="Controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-in id="LoadFile" routes-to="LoadFile_111" access="public" icon="icons/LoadFile.png">
            
            <cc:parameter documentation="The name of the file as known in the results of GetEventDocuments and written into the /Documents/Document/Filename results element.  This is used from error reporting if necessary." name="inFilename" required="false" type="string"/><cc:parameter documentation="The Cloud Collection value returned by GetEventDocuments and available through the GetDocumentList (SSK110) component.  In conjunction with the inEntryID parameter, this is essential to retrieving the document contents from the blobitory." name="inCollection" required="true" type="string"/><cc:parameter documentation="The Document Entry ID value returned by GetEventDocuments and available through the GetDocumentList (SSK110) component.  In conjunction with the inCollection parameter, this is essential to retrieving the document contents from the blobitory." name="inEntryID" required="true" type="string"/>
			<cc:parameter default="'message'" documentation="How the file contents are returned to the caller, either on the message if the value is 'message', which is the default, or if the value is 'variable', then the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="PIM_Tag_106" store-message="none" endpoint="vm://wcc/PutIntegrationMessage">
            <cc:set name="is.event.wid" value="props['inTargetEventWID']"/><cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="'Saved file '# props['inOutputFilename'] #' to the Integration Event.'"/>
            <cc:set name="is.document.variable.name" value="'localStoreResult106'"/><cc:set name="is.document.file.name" value="props['inOutputFilename']"/>
            <cc:set name="is.document.deliverable" value="props['inOutputIsDeliverable'] ? 'true' : 'false'"/>
            <cc:set name="is.document.retrieved" value="props['inOutputIsRetrieved'] ? 'true' : 'false'"/><cc:set name="is.document.labels" value="props['inOutputDocumentTags'] != empty ? util.listToCommaDelimString(props['inOutputDocumentTags']) : null"/>
            
            
        <cc:set name="is.message.storage.enabled" value="false"/><cc:set name="is.message.secured.instance.refs" value="context.containsProperty('localSecuredRefs') ? props['localSecuredRefs'] : null"/><cc:set name="is.message.secured.instance.refs.type" value="context.containsProperty('localSecuredRefs') ? props['inSecuredInstanceRefTypes'] : null"/></cc:local-out>
        <cc:local-out id="Call_HandleError_StoreVariable_Error_106" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Storage Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while storing data to the Integration Event.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:local-in id="GenerateOutput" routes-to="InitializeAndFinalize_106" access="public" icon="icons/GenerateOutput.png">
            <cc:parameter default="'message'" documentation="Where to find the data to be output.  If the value is 'variable', then the contents of globalOutputData will be written.  Otherwise, the contents of the message root part will be output." name="inDataSource" required="true" type="string"/><cc:parameter default="context.containsProperty('sskEventWID') ? props['sskEventWID'] : null" documentation="The WID of the Integration Event to which the document should be attached.  This need not be the current event, although it will default as such." name="inTargetEventWID" required="true" type="string"/>
            
            <cc:parameter default="context.containsProperty('sskOutputFilename') ? props['sskOutputFilename'] : null" documentation="The filename of the file to be produced.  This may be provided as an Integration Attribute, and is defaulted as such.  This may also be produced by a Sequence Generator and provided here.  The name should include an extension, which would also include the .pgp extension if encrypted." name="inOutputFilename" required="true" type="string"/>
            
            <cc:parameter default="context.containsProperty('sskDocumentRetentionPeriod') ? props['sskDocumentRetentionPeriod'] : 'P7D'" documentation="The duration to keep the output file.  Value is of the format &quot;P&quot; followed by a number followed by &quot;D&quot;.  This evaluates to a number of days." name="inDocumentRetentionPeriod" required="true" type="string"/>
            <cc:parameter default="context.containsProperty('sskDeliveryDocTag') ? props['sskDeliveryDocTag'] : null" documentation="An optional list of Document Tag(s) to be placed on the file to facilitate ease of identification on the Integration Event.  The parameter should be passed as a list data structure containing the Document_Tag_Name reference id of the Tag as a string.  For example, props['listOfTags'] = new java.util.ArrayList();  props['listOfTags'].add('INT_Document_TagName');" name="inOutputDocumentTags" required="false"/>
            <cc:parameter default="false" documentation="A boolean flag to specify if the file being produced should be considered deliverable.  This facilitates identification by a Document Delivery service." name="inOutputIsDeliverable" required="true" type="boolean"/>
            <cc:parameter default="false" documentation="A boolean flag to specify if the file being produced should be considered retrieved.  This facilitates identification by post-processor integration systems for further processing and is especially useful when building a pre-processor to a connector dependent on that tag." name="inOutputIsRetrieved" required="false" type="boolean"/><cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/><cc:parameter documentation="A list of Reference IDs (by default, WIDs, but other types are supported in conjunction with the inSecuredInstanceRefTypes parameter) to which file access is restricted.  The list may either be given as an ArrayList of Strings, or as a String that is a comma-separated list of the IDs." name="inSecuredInstanceRefs" required="false" validation="(props['inSecuredInstanceRefs'] == empty) || (props['inSecuredInstanceRefs'] instanceof java.lang.String) || (props['inSecuredInstanceRefs'] instanceof java.util.List)"/><cc:parameter default="'WID'" name="inSecuredInstanceRefTypes" required="props['inSecuredInstanceRefs'] != empty" type="string"/>
        </cc:local-in>
        <cc:local-out id="Call_CreateLogEntry_SingleFileProceed_Info_110" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'A Document Retrieval Service file was found and loaded.'"/>
            <cc:set name="inLogMessageDetail" value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.'"/>
            
            <cc:set name="inLogLevel" value="'info'"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(SingleFileProceed)'"/>
            <cc:set name="inExtraRecordNumber" value="String.valueOf(props['localDACount'])"/>
            
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_MultipleFilesProceed_Info_110" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Multiple retrieved files were found.'"/>
            <cc:set name="inLogMessageDetail" value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.'"/>
            <cc:set name="inLogReferenceId" value="String.valueOf(props['localDACount'])"/>
            <cc:set name="inLogLevel" value="'info'"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(MultipleFilesProceed)'"/>
            <cc:set name="inExtraRecordNumber" value="String.valueOf(props['localDACount'])"/>
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_MultipleFilesCountError_Error_110" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'The expected number of files was not found!'"/>
            <cc:set name="inLogMessageDetail" value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.  However, '# props['inExactFileCountExpected'] #' files(s) were expected.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(MultipleFilesCountError)'"/>
            <cc:set name="inExtraRecordNumber" value="String.valueOf(props['localDACount'])"/>
            
        	<cc:set name="inExtraErrorCode" value="'11002'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
	        <cc:set name="inTargetType" value="'properties'"/>
	        <cc:set name="inTargetName" value="'sskDebugPropertyList'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_MultipleFilesError_Error_110" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Too many retrieved files were found!'"/>
            <cc:set name="inLogMessageDetail" value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.  Only a single file is expected.  A multiple-data condition is an error and the output of the Document Retrieval Service should be investigated.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(MultipleFilesError)'"/>
            <cc:set name="inExtraRecordNumber" value="String.valueOf(props['localDACount'])"/>
            
        	<cc:set name="inExtraErrorCode" value="'11001'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
	        <cc:set name="inTargetType" value="'properties'"/>
	        <cc:set name="inTargetName" value="'sskDebugPropertyList'"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_NoFileProceed_Info_110" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'No retrieved file was found.'"/>
            <cc:set name="inLogMessageDetail" value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.'"/>
            
            <cc:set name="inLogLevel" value="'info'"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(NoFileProceed)'"/>
            <cc:set name="inExtraRecordNumber" value="'0'"/>
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_NoFileError_Error_110" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'No retrieved file was found!'"/>
            <cc:set name="inLogMessageDetail" value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.  Data is expected.  A no-data condition is an error and the output of the Document Retrieval Service should be investigated.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(NoFileError)'"/>
            <cc:set name="inExtraRecordNumber" value="'0'"/>
            
        	<cc:set name="inExtraErrorCode" value="'11000'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
	        <cc:set name="inTargetType" value="'properties'"/>
	        <cc:set name="inTargetName" value="'sskDebugPropertyList'"/>
	    </cc:local-out>
        <cc:route id="RouteOnCount_110">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inNoFileThrowsException'] &amp;&amp; props['localDACount'] == 0" route="NoFileError"/>
                <cc:choose-route expression="(!props['inNoFileThrowsException']) &amp;&amp; props['localDACount'] == 0" route="NoFileProceed"/>
                <cc:choose-route expression="props['inMultipleFilesThrowsException'] &amp;&amp; props['localDACount'] > 1" route="MultipleFilesError"/>
                <cc:choose-route expression="(!props['inMultipleFilesThrowsException']) &amp;&amp; props['inExactFileCountExpected'] > 0 &amp;&amp; (props['localDACount'] != props['inExactFileCountExpected'])" route="MultipleFilesCountError"/>
                <cc:choose-route expression="(!props['inMultipleFilesThrowsException']) &amp;&amp; (props['inExactFileCountExpected'] == -1 || props['localDACount'] == props['inExactFileCountExpected']) &amp;&amp; props['localDACount'] > 1" route="MultipleFilesProceed"/>
                <cc:choose-route expression="true" route="SingleFileProceed"/>
            </cc:mvel-strategy>
            <cc:sub-route name="NoFileError" routes-to="Call_HandleError_NoFileError_Error_110"/>
            <cc:sub-route name="NoFileProceed" routes-to="Call_CreateLogEntry_NoFileProceed_Info_110"/>
            <cc:sub-route name="MultipleFilesError" routes-to="Call_HandleError_MultipleFilesError_Error_110"/>
            <cc:sub-route name="MultipleFilesCountError" routes-to="Call_HandleError_MultipleFilesCountError_Error_110"/>
            <cc:sub-route name="MultipleFilesProceed" routes-to="Call_CreateLogEntry_MultipleFilesProceed_Info_110"/>
            <cc:sub-route name="SingleFileProceed" routes-to="Call_CreateLogEntry_SingleFileProceed_Info_110"/>
        </cc:route>
        <cc:async-mediation id="DocumentAccessor_110" routes-to="Call_Debug_FilteredDocuments_110" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="UpdateDebug">
                    <cc:expression>if (context.containsProperty('sskDebugPropertyList')) {&#xD;
	props['sskDebugPropertyList'].add('inNoFileThrowsException');&#xD;
	props['sskDebugPropertyList'].add('inMultipleFilesThrowsException');&#xD;
	props['sskDebugPropertyList'].add('inExactFileCountExpected');&#xD;
	props['sskDebugPropertyList'].add('localTagFilter');&#xD;
	props['sskDebugPropertyList'].add('localDACount');&#xD;
}</cc:expression>
                </cc:eval>
                <cc:eval id="InitValues">
                    <cc:expression>props['localTagFilter'] = '';</cc:expression>
                    <cc:expression>if ((props['inRetrievalDocTag'] != empty) &amp;&amp; (props['inRetrievalDocTagType'] == 'All')) {&#xD;
	props['localTagFilter'] = '';&#xD;
	foreach (tag : props['inRetrievalDocTag']) {&#xD;
		props['localTagFilter'] = props['localTagFilter'] # '[wd:Document_Tag_Reference/wd:ID[@wd:type=\'WID\'] = \'' # tag # '\']';&#xD;
	}&#xD;
}</cc:expression>
                    <cc:expression>if ((props['inRetrievalDocTag'] != empty) &amp;&amp; (props['inRetrievalDocTagType'] == 'Any')) {&#xD;
	numOfTags = props['inRetrievalDocTag'].size();&#xD;
	counter = 1;&#xD;
&#xD;
	props['localTagFilter'] = '[wd:Document_Tag_Reference/wd:ID[@wd:type=\'WID\'] = (';&#xD;
	foreach (tag : props['inRetrievalDocTag']) {&#xD;
		props['localTagFilter'] = props['localTagFilter'] # '\'' # tag # '\'' # ((counter &lt; numOfTags) ? ',' : '');&#xD;
		counter = counter + 1;&#xD;
	}&#xD;
	props['localTagFilter'] = props['localTagFilter'] # ')]';&#xD;
}</cc:expression>
                </cc:eval>
                <cc:write id="WriteXSLT" output="variable" output-variable="localXslt110">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;xsl:stylesheet &#xD;
	xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&#xD;
    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&#xD;
    xmlns:wd=&quot;urn:com.workday/bsvc&quot;&#xD;
    exclude-result-prefixes=&quot;#all&quot;&#xD;
    version=&quot;3.0&quot;>&#xD;
    &#xD;
    &lt;xsl:mode streamable=&quot;yes&quot; on-no-match=&quot;shallow-skip&quot;/>&#xD;
    &lt;xsl:mode name=&quot;in-memory&quot; streamable=&quot;no&quot;/>&#xD;
    &#xD;
    &lt;xsl:output indent=&quot;no&quot;/>&#xD;
    &#xD;
    &lt;xsl:template match=&quot;/&quot;>&#xD;
        &lt;Documents>&#xD;
            &lt;xsl:apply-templates/>&#xD;
        &lt;/Documents>&#xD;
    &lt;/xsl:template>&#xD;
&#xD;
    &lt;xsl:template match=&quot;wd:Repository_Document&quot;>&#xD;
        &lt;xsl:apply-templates select=&quot;wd:Repository_Document_Data/copy-of()@if{props['localTagFilter'] != empty}@{props['localTagFilter']}@end{}&quot; mode=&quot;in-memory&quot;/>&#xD;
    &lt;/xsl:template>&#xD;
&#xD;
    &lt;xsl:template match=&quot;wd:Repository_Document_Data&quot; mode=&quot;in-memory&quot;>&#xD;
	    &lt;Document>&#xD;
	    	&lt;Collection>&lt;xsl:value-of select=&quot;substring-before(@wd:Document_ID, '/')&quot;/>&lt;/Collection>&#xD;
	    	&lt;EntryID>&lt;xsl:value-of select=&quot;substring-after(@wd:Document_ID, '/')&quot;/>&lt;/EntryID>&#xD;
	    	&lt;Filename>&lt;xsl:value-of select=&quot;@wd:File_Name&quot;/>&lt;/Filename>&#xD;
	    	&lt;Filesize>&lt;xsl:value-of select=&quot;wd:File_Size&quot;/>&lt;/Filesize>&#xD;
	    	&lt;Mimetype>&lt;xsl:value-of select=&quot;wd:Content_Type_Reference/wd:ID[@wd:type = 'Content_Type_ID']&quot;/>&lt;/Mimetype>&#xD;
	    &lt;/Document>&#xD;
    &lt;/xsl:template>&#xD;
&lt;/xsl:stylesheet></cc:text>
                    </cc:message>
                </cc:write>
                <cc:xslt-plus id="FilterEventDocuments" url="mctx:vars/localXslt110"/>
                <cc:xslt-plus id="CountRecords" output="variable" output-mimetype="text/xml" output-variable="localRecordCount110" url="xslt/ssk110/SSK110_CountRecords.xsl"/>
                <cc:eval id="SetValues">
                    <cc:expression>props['localDACount'] = (int)vars['localRecordCount110'].xstream('/totalRecords');</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_DocumentAccessor_Error_110"/>
        </cc:async-mediation>
        <cc:local-out id="GetEventDocuments_110" store-message="none" routes-response-to="Call_Debug_GetEventDocuments_110" endpoint="vm://wcc/GetEventDocuments">
            <cc:set name="ie.event.wid" value="props['inEventWID']"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Error_110" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'GetEventDocuments Execution Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while calling Get_Event_Documents.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_110" routes-to="GetEventDocuments_110" handle-downstream-errors="true" routes-response-to="Call_Finally_110">
            <cc:request-steps/>
            <cc:response-steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>if (props.inReturnResults != 'message') {&#xD;
	vars[props.inReturnResults] = parts[0].source;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:response-steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Error_110"/>
        </cc:sync-mediation>
        <cc:async-mediation id="Teardown_110">
            <cc:steps>
                <cc:eval id="CleanUp">
						<cc:expression>foreach (propname : ['localTagFilter','localDACount']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['localXslt110','localRecordCount110']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
					</cc:eval>
                <cc:eval id="ReduceDebug">
                    <cc:expression>if (context.containsProperty('sskDebugPropertyList')) {&#xD;
	props['sskDebugPropertyList'].remove('localDACount');&#xD;
	props['sskDebugPropertyList'].remove('inNoFileThrowsException');&#xD;
	props['sskDebugPropertyList'].remove('inMultipleFilesThrowsException');&#xD;
	props['sskDebugPropertyList'].remove('inExactFileCountExpected');&#xD;
	props['sskDebugPropertyList'].remove('localTagFilter');&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_110" routes-to="Teardown_110"/>
        <cc:local-out id="Call_Finally_110" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_110">
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:local-in id="GetDocumentList" routes-to="InitializeAndFinalize_110" access="public" icon="icons/GetDocumentList.png">
            <cc:parameter default="context.containsProperty('sskDebugWID') ? props['sskDebugWID'] : props['sskEventWID']" documentation="WID of the Integration Event from which the documents will be queried.  This is typically the current event, and as such, is defaulted to the current event WID.  However, changing this WID enables retrieving documents from another related event for processing." name="inEventWID" required="true" type="string"/>
            <cc:parameter default="true" documentation="Controls whether or not an exception is thrown when there are no input files to the Integration Event.  TRUE means an exception will be thrown.  FALSE means no exception will be thrown." name="inNoFileThrowsException" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not an exception is thrown when there are multiple input files to the Integration Event.  TRUE means an exception will be thrown.  FALSE means no exception will be thrown." name="inMultipleFilesThrowsException" required="true" type="boolean"/>
            <cc:parameter default="-1" documentation="Specifies an exact number of files to be expected on the Integration Event.  If a variable number of input files is supported, then this should be passed as -1." name="inExactFileCountExpected" required="false" type="integer" validation="props['inExactFileCountExpected'] == -1 || props['inExactFileCountExpected'] > 0"/>
            <cc:parameter default="context.containsProperty('sskRetrievalDocTag') ? props['sskRetrievalDocTag'] : null" documentation="Specifies a Document Tag for filtering the input files on the Integration Event.  If not specified, parameter will try to use the value of the Retrieval Document Tag Integration Attribute." name="inRetrievalDocTag" required="false"/>
            <cc:parameter default="context.containsProperty('sskRetrievalDocTagType') ? props['sskRetrievalDocTagType'] : null" documentation="Specifies a strategy for how to use the Document Tags given in the inRetrievalDocTag parameter for filtering the input files on the Integration Event.  If &quot;Any&quot; is given, then any file file that matches at least one of the given tags will be returned.  If &quot;All&quot; is specified, then only files that match every given tag will be returned." name="inRetrievalDocTagType" required="props['inRetrievalDocTag'] != empty" type="string"/><cc:parameter default="'message'" documentation="Where the results of the response are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/><cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the GetEventDocuments results are output on debug as well as context properties in error conditions." name="inDebugMode" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-in id="Main" routes-to="GetEventDocuments"/>
        <cc:local-out id="Call_HandleError_SoapError_Error_103" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError" clone-request="true">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] #' application SOAP request error'"/>
            <cc:set name="inLogMessageDetail" value="parts[0].xstream('/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault/faultstring')"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="parts[0].xstream('/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault/faultcode')"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="org.apache.commons.lang3.StringUtils.normalizeSpace(parts[0].xstreamF('/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault/detail'))"/>
        	<cc:set name="inExtraErrorCode" value="'10307'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_103'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="'SOAP-Request__' # props['inWebServiceApplication']"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/><cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:async-mediation id="RouteError_Soap_Handler_103" routes-to="Call_HandleError_SoapError_Error_103">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'soap';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_StoreLogPrimary_Error_109" store-message="none" routes-response-to="Call_StoreLogSecondary_Error_109" endpoint="vm://INT006_Greenhouse_Inbound/StoreLogPrimary">
            <cc:set name="inLogFinalize" value="true"/>
        </cc:local-out>
        <cc:local-in id="Debug" routes-to="Debug_InitializeAndFinalize_144" access="public" icon="icons/Debug.png">
        	<cc:parameter default="'message'" documentation="The type of information to be output to the log." name="inTargetType" required="true" type="string" validation="props['sskDebugTargetTypeValidation'].contains(props['inTargetType'])"/>
        	<cc:parameter documentation="The reference name to use for single-named output types selected on inTargetType.  Required when inTargetType is one of: property, variable, list, map, or set." name="inTargetName" required="false" type="string" validation="props['sskDebugTargetNameValidation'].contains(props['inTargetType']) &amp;&amp;&#xD;&#xA;(props['inTargetName'] != empty || props['inEntityName'] != empty)"/>
        	<cc:parameter documentation="A specific filename to use when exporting the message or variable content to a file zipped in a consolidated archive.  This is optional and only used when inTargetType is &quot;message&quot; or &quot;variable&quot;." name="inEntityName" required="false" type="string"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        	<cc:out-parameter documentation="If a file has been written to the debug archive, the name of that file will be returned for further reference in logging messages." name="outEntityName"/>
        <cc:out-parameter documentation="A boolean that is set to true on exit of this SSK Component under specific input parameter conditions to signal in the completion of the event that the archive needs to finalized and attached." name="outDebugLogged144"/></cc:local-in>
        <cc:route id="RouteType_144">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inTargetType'] == 'message'" route="Message"/>
                <cc:choose-route expression="props['inTargetType'] == 'property'" route="Property"/>
                <cc:choose-route expression="props['inTargetType'] == 'properties'" route="Properties"/>
                <cc:choose-route expression="props['inTargetType'] == 'variable'" route="Variable"/>
                <cc:choose-route expression="props['inTargetType'] == 'map'" route="Map"/>
                <cc:choose-route expression="props['inTargetType'] == 'list'" route="List"/>
                <cc:choose-route expression="props['inTargetType'] == 'set'" route="Set"/>
                <cc:choose-route expression="props['inTargetType'] == 'finalize'" route="Finalize"/>
                <cc:choose-route expression="true" route="Undefined"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Message" routes-to="RouteThread_Message_144"/>
            <cc:sub-route name="Property" routes-to="MessageValues_Property_144"/>
            <cc:sub-route name="Properties" routes-to="RouteProperties_144"/>
            <cc:sub-route name="Variable" routes-to="RouteThread_Variable_144"/>
            <cc:sub-route name="Map" routes-to="GetMapKeys_144"/>
            <cc:sub-route name="List" routes-to="GetListKeys_144"/>
            <cc:sub-route name="Set" routes-to="GetSetKeys_144"/>
            <cc:sub-route name="Finalize" routes-to="Call_Aggregate_Finalize_144"/>
            <cc:sub-route name="Undefined" routes-to="Call_CreateLogEntry_Warn_Undefined_144"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntry_Warn_Undefined_144" store-message="none" execute-when="!props['inIsChildThreadContext']" routes-response-to="Call_CreateLogEntryOnThread_Warn_Undefined_144" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Undefined Debug Log'"/>
            <cc:set name="inLogMessageDetail" value="'RouteType_144 was not able to correctly process the inTargetType input parameter.'"/>
            
            <cc:set name="inLogLevel" value="'warn'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_Variable_144" store-message="none" routes-response-to="Variable_Name_144" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Variable ' # props['inTargetName']"/>
            <cc:set name="inLogMessageDetail" value="'Variable '# props['inTargetName'] #' saved to debug file with name of ' # props['outEntityName']"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_Property_144" store-message="none" execute-when="!props['inIsChildThreadContext']" routes-response-to="Call_CreateLogEntryOnThread_Debug_Property_144" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Property ' # props['inTargetName']"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_Message_144" store-message="none" routes-response-to="Message_Name_144" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Message RootPart'"/>
            <cc:set name="inLogMessageDetail" value="'Message root part saved to debug file with name of ' # props['outEntityName']"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_Map_144" store-message="none" execute-when="!props['inIsChildThreadContext']" routes-response-to="Call_CreateLogEntryOnThread_Debug_Map_144" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="props[props.inTargetName] # '/' # props['localKey144']"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_List_144" store-message="none" execute-when="!props['inIsChildThreadContext']" routes-response-to="Call_CreateLogEntryOnThread_Debug_List_144" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="props.inTargetName # ' Element ' # String.valueOf(props.localCounter144)"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_SoapRequest_103" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallSoap_Catch_103" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            
            
            
            
            
            
            
        <cc:set name="inTargetType" value="'message'"/><cc:set name="inEntityName" value="'SOAP-Request__' # props['inWebServiceApplication']"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_Debug_RaaSRequest_102" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallRaaS_Catch_102" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
        <cc:set name="inTargetName" value="'localRestUrl'"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:route id="RouteError_103">
            <cc:mvel-strategy>
                <cc:choose-route expression="parts[0].isXml() &amp;&amp; (parts[0].xstreamB('/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault'))" route="SoapError"/>
                <cc:choose-route expression="true" route="HttpError"/>
            </cc:mvel-strategy>
            <cc:sub-route name="SoapError" routes-to="RouteError_Soap_Handler_103"/>
            <cc:sub-route name="HttpError" routes-to="RouteError_Http_Handler_103"/>
        </cc:route>
        <cc:async-mediation id="HttpError_Handler_104" routes-to="Call_HandleError_HttpError_Error_104">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'http';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_HttpError_Error_104" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] #' application HTTP request error'"/>
            <cc:set name="inLogMessageDetail" value="'A transport protocol error occurred and the request was not evaluated or processed by the tenant.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
	        <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_104'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Request__' # props['inWebServiceApplication']"/>
            
	    <cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:async-mediation id="SoapError_Handler_104" routes-to="Call_HandleError_SoapError_Error_104">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'soap';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_SoapError_Error_104" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] #' application SOAP request error'"/>
            <cc:set name="inLogMessageDetail" value="'The API call resulted in the following SOAP fault: '# String.valueOf(parts[0].xpath('/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault/faultstring'))"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
	        <cc:set name="inExtraErrorCode" value="'10407'"/>
	        <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_104'"/>
	        <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
	        <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
	        <cc:set name="inTargetType" value="'property'"/>
	        <cc:set name="inTargetName" value="'message'"/>
	        <cc:set name="inEntityName" value="'SOAP-Request__' # props['inWebServiceApplication']"/>
	        
	    <cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:route id="RouteError_104">
            <cc:mvel-strategy>
                <cc:choose-route expression="parts[0].isXml() &amp;&amp; (parts[0].xpath('count(/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault)') > 0)" route="SoapError"/>
                <cc:choose-route expression="true" route="HttpError"/>
            </cc:mvel-strategy>
            <cc:sub-route name="SoapError" routes-to="SoapError_Handler_104"/>
            <cc:sub-route name="HttpError" routes-to="HttpError_Handler_104"/>
        </cc:route>
        <cc:async-mediation id="CallSoap_Catch_104" routes-to="RouteConcurrency_104" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="RouteError_104"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_SoapRequest_104" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallSoap_Catch_104" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
        <cc:set name="inEntityName" value="'SOAP-Request'"/></cc:local-out>
        <cc:local-out id="Call_Debug_SoapXslt_104" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inBuildRequestPathToXsltFile'"/>
        </cc:local-out>
        <cc:async-mediation id="Transform_Handler_104" routes-to="Call_HandleError_Transform_Error_104">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Transform_Error_104" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Transformation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a SOAP service call.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_104'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inBuildRequestPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inBuildRequestPathToXsltFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inBuildRequestPathToXsltFile'], '/') :&#xD;&#xA;&#x9;props['inBuildRequestPathToXsltFile']"/>
            
        <cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:async-mediation id="Transform_104" routes-to="Call_Debug_SoapXslt_104">
            <cc:steps>
                <cc:xslt-plus id="WriteSoap" input="message" url="@{props['inBuildRequestPathToXsltFile']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Transform_Handler_104"/>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareVariableInput_104" routes-to="Transform_104">
            <cc:steps>
                <cc:eval id="PrimeMessage">
                    <cc:expression>varname = props['inBuildRequestDataLocationId'];&#xD;
parts[0] = vars[varname].source;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PreparePropertyInput_104" routes-to="Transform_104">
            <cc:steps>
                <cc:write id="PrimeMessage">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;Root/></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Validation_Handler_104" routes-to="Call_HandleError_Validation_Error_104">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Validation_Error_104" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Validation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while validating parameters for a SOAP service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_104'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_104" routes-to="Call_BuildRequest_104" routes-response-to="Call_ParallelPostProcess_104">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['outIsSoapError'] = '';&#xD;
props['outErrorMessage'] = '';</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:async-mediation id="Teardown_104">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsQualifierTyped','localIsValueDefined','localIsValueTyped','localIsQueryCacheEffective','localIsQueryCacheEntryDate']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>if (vars.isVariable('c2pAggregatedResult104')) {&#xD;
	vars['c2pAggregatedResult104'] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_104" routes-to="Call_CreateLogEntry_FlushInfo_104"/>
        <cc:local-out id="Call_Finally_104" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_104"/>
        <cc:local-in id="CallSoapPaged" routes-to="InitializeAndFinalize_104" access="public" icon="icons/CallSoapPaged.png">
            <cc:parameter default="props['globalApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter documentation="The WWS application where the operation may be found, e.g. &quot;Human_Resources&quot;." name="inWebServiceApplication" required="true" type="string"/>
            
            <cc:parameter documentation="The location that holds the data to be used in the transform provided on the inPathToXsltFile parameter.  This value is dependent on the value of inDataLocationId.  The parameter can have one of three values: message, variable, or property.  When the value is 'message', then the message part identified by inDataLocationId is interpreted as XML data to which the inPathToXsltFile xslt will be applied.  Similarly, if this parameter value is 'variable', then the variable identified by inDataLocationId is interpreted as XML data to which the inPathToXsltFile xslt will be applied.  if this parameter value is 'property', then the property identified by inDataLocationId is interpreted as a java.util.Map instance whose key/value pairs match pre-defined keys in the inPathToXsltFile xslt for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inBuildRequestDataLocation" required="props['inBuildRequestPathToXsltFile'] != empty" type="string" validation="((props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (['message','variable','property'] contains props['inBuildRequestDataLocation'].trim().toLowerCase())) ||&#xD;&#xA;&#x9;((props['inBuildRequestPathToXsltFile'] == empty) &amp;&amp; (props['inBuildRequestDataLocation'] == empty))"/>
            <cc:parameter documentation="The name that, when used with inBuildReqeustDataLocation, uniquely identifies which variable or property is to be used as the source data to which the transform provided on the inBuildReqeustPathToXsltFile parameter will be applied.  When inBuildReqeustDataLocation is 'message', then this parameter is ignored and the message root part is assumed." name="inBuildRequestDataLocationId" required="(props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'].trim().toLowerCase() != 'message')" type="string" validation="((props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'].trim().toLowerCase() != 'message') &amp;&amp; (props['inBuildRequestDataLocationId'] != empty)) ||&#xD;&#xA;&#x9;((props['inBuildRequestPathToXsltFile'] == empty) &amp;&amp; (props['inBuildRequestDataLocationId'] == empty))"/>
            <cc:parameter documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot; using the data identified by the inDataLocation and inDataLocationId input parameters.  This SSK Component also supports pre-built, on-message requests as well as facilities to construct the request dynamically.  If this parameter is omitted or set to null / an empty string, then inDataLocation and inDataLocationId can also be omitted (they are ignored), and then the dynamic request construction will be bypassed and the message root part will be used as the request." name="inBuildRequestPathToXsltFile" required="(props['inBuildRequestDataLocation'] != empty) || (props['inBuildRequestDataLocationId'] != empty)" type="string"/>
            <cc:parameter default="'env:Envelope/env:Body/*/wd:Response_Data/*'" documentation="Xpath to the elements in the response that are to be aggregated into the final data set." name="inXpathToResultsToAggregate" required="!props['inParallelSuppressAggregation']" type="string"/>
            <cc:parameter default="'&lt;SoapResults xmlns:wd=&quot;urn:com.workday/bsvc&quot;>'" documentation="In order to aggregate multiple XML elements at the same level into a final, returned document, a new root node is required.  This parameter defines that node including the namespaces required in the results, e.g. &lt;SoapResults xmlns:wd=&quot;urn:com.workday/bsvc&quot;>" name="inAggregatedResultsHeader" required="!props['inParallelSuppressAggregation']" type="string" validation="props['inAggregatedResultsHeader'] != empty"/>
            <cc:parameter default="'&lt;/SoapResults>'" documentation="In order to aggregate multiple XML elements at the same level into a final, returned document, a new root node is required.  This parameter defines the matching, terminating element as was defined on the inAggregatedResults parameter." name="inAggregatedResultsFooter" required="!props['inParallelSuppressAggregation']" type="string" validation="props['inAggregatedResultsFooter'] != empty"/>
            <cc:parameter default="true" documentation="A boolean value that directs the SSK Component to run the PagedGet component in either serial or parallel mode.  Running in parallel mode exposes more capability of this SSK Component as you can inject custom code to be executed after a response is received on each child thread.  This is a suitable mechanism to achieve parallel processing in lieu of the wcc://ParallelSubRoutine component." name="inIsParallelPagedGet" required="true" type="boolean"/>
            <cc:parameter documentation="Only applies when inIsParallelPagedGet is set to true.  When in parallel mode, this parameter defines a dynamic endpoint to which the PagedGet responses will be routed for custom processing, e.g. follow-up RAAS reports (remember that SA-102 is not thread-safe though) or outbound vendor HTTP/API calls.  The format of this value is the same as other local-out endpoint attributes, e.g. 'vm://INT006_Greenhouse_Inbound/local-in'.  If any data from the child threads is to be returned to the main SSK Component caller, then the data to be aggregated should be left on the message root part to be picked up by the aggregator thread and ultimately returned to the main parent thread.  The aggregator will expect the data mime-type to be text/xml, and it will assume the root node is to be skipped and is not a part of the data." name="inParallelPageProcessorEndpoint" required="false" type="string"/>
            <cc:parameter default="false" documentation="Only applies when inIsParallelPagedGet is set to true.  When in parallel mode, and this parameter is true, then the results of each page retrieval and/or whatever additional processing is performed on each page response, will not be aggregated.  Effectively therefore, there will be no results returned from this SSK Component and the required attribute of the inReturnResults parameter will become false.  The results/effect of the pages retrieved will then be the actions of the custom code provided at the inParallelPageProcessorEndpoint endpoint parameter.  If that code produces results that are to be aggregated in lieu of the retrieved PagedGet responses, then this parameter should be set to false, and the data to be aggregated should be left on the message root part to be picked up by the aggregator.  The aggregator will expect the data mime-type to be text/xml, and it will assume the root node is to be skipped and is not a part of the data." name="inParallelSuppressAggregation" required="props['inIsParallelPagedGet']" type="boolean"/>
            <cc:parameter default="'message'" documentation="How the SOAP results are returned to the caller.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found.  " name="inReturnResults" required="(!props['inIsParallelPagedGet']) ||&#xD;&#xA;&#x9;(props['inIsParallelPagedGet'] &amp;&amp; (!props['inParallelSuppressAggregation']))" type="string"/>
            <cc:parameter default="props['sskIsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="'primary'" documentation="Controls whether the error message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            <cc:out-parameter documentation="A string to indicate that the request resulted in an error and identify the type.  If the error was at the API level, then outIsSoapError == 'http'.  If the error was at the tenant/application level, then outIsSoapError == 'soap'.  If there was an error unrelated to the API call, then outIsSoapError == 'logic'.  If there is no error, , then outIsSoapError == empty.  Further individual errors determined by Get_Event_Details or Get_Import_Processes are not handled here." name="outIsSoapError"/>
        <cc:out-parameter documentation="The error message of the exception for possible higher-level logging needs." name="outErrorMessage"/></cc:local-in>
        <cc:local-out id="CallSoapParallel_104" store-message="none" endpoint="vm://wcc/PagedGet">
        	<cc:set name="is.paged.get.request.current.page.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Filter/wd:Page'"/>
        	<cc:set name="is.paged.get.response.current.page.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Page'"/>
        	<cc:set name="is.paged.get.response.total.pages.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Pages'"/>
        	<cc:set name="is.paged.get.response.total.results.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Results'"/>
        	<cc:set name="is.paged.get.process.endpoint" value="'vm://INT006_Greenhouse_Inbound/ProcessPageParallel_104'"/>
        	<cc:set name="is.paged.get.application" value="props['inWebServiceApplication']"/>
        	<cc:set name="is.paged.get.version" value="props['inApiVersion']"/>
        	<cc:set name="is.paged.get.page.zero" value="false"/>
        	<cc:set name="is.paged.get.store.requests" value="true"/>
        	<cc:set name="is.paged.get.parallel" value="true"/>
        	<cc:set name="is.paged.get.parallel.aggregation.endpoint" value="'vm://INT006_Greenhouse_Inbound/AggregateParallel_104'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_LoadMap_Error_105" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">            
            <cc:set name="inLogMessage" value="'XSLT3 Map Load Error'"/>
            <cc:set name="inLogMessageDetail" value="'The XML data failed to be converted into a Java Map'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_105'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'localXslt105'"/>
            <cc:set name="inEntityName" value="'PopulateJavaMap-Transform'"/>
        </cc:local-out>
        <cc:async-mediation id="Teardown_105">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>// Remove properties that are purely internal to the subassembly
foreach (propname : ['localMapPropertyName']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>// And remove local variables that are no longer required&#xD;
foreach (varname : ['localXslt105']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_105" routes-to="Teardown_105"/>
        <cc:local-out id="Call_Finally_105" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_105"/>
        <cc:local-in id="IntegrationEventProgress" routes-to="ErrorTrap_108" access="public" icon="icons/IntegrationEventProgress0.png">
            <cc:parameter documentation="The overall completion percentage of the studio execution." name="inProgressPercentage" required="true" type="string"/>
            <cc:parameter documentation="The optional message to output on the Integration Event to indicate at what stage of the processing the Studio is." name="inProgressMessage" required="false" type="string"/>
        </cc:local-in>
        <cc:local-out id="PIM_108" store-message="none" execute-when="props['inProgressMessage'] != empty" routes-response-to="PIE_108" endpoint="vm://wcc/PutIntegrationMessage"><cc:set name="is.message.severity" value="'INFO'"/><cc:set name="is.message.summary" value="props['inProgressMessage']"/><cc:set name="is.message.storage.enabled" value="false"/></cc:local-out>
        <cc:local-out id="PIE_108" store-message="none" routes-response-to="Call_CreateLogEntry_Info_108" endpoint="vm://wcc/PutIntegrationEvent"><cc:set name="is.percent.complete" value="props['inProgressPercentage']"/></cc:local-out>
        <cc:local-out id="Call_IEP_10" store-message="none" routes-response-to="MainFlowControl_109" endpoint="vm://INT006_Greenhouse_Inbound/IntegrationEventProgress" clone-request="true" propagate-abort="false"><cc:set name="inProgressPercentage" value="'10'"/><cc:set name="inProgressMessage" value="'Initialization Complete.  Cloud Log, integration attributes, and launch parameters have been loaded.'"/></cc:local-out>
        <cc:local-out id="Call_IEP_90" store-message="none" routes-response-to="Call_StaticCodeAnalysis_109" endpoint="vm://INT006_Greenhouse_Inbound/IntegrationEventProgress" clone-request="true" propagate-abort="false">
            <cc:set name="inProgressPercentage" value="'90'"/>
            <cc:set name="inProgressMessage" value="'Integration functional behavior complete.  Finalizing logs...'"/>
        </cc:local-out>
        <cc:local-out id="Call_IEP_99" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/IntegrationEventProgress" clone-request="true" propagate-abort="false">
            <cc:set name="inProgressPercentage" value="'99'"/>
            <cc:set name="inProgressMessage" value="'Logs Finalized.  Awaiting any background process to complete Integration Event...'"/>
        </cc:local-out>
        <cc:aggregator id="AggregateToArchive_144" routes-to="StoreArchive_144" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:zip-file-collater output-mimetype="application/zip" message-entity-name="@{props['outEntityName']}"/>
        </cc:aggregator>
        <cc:local-in id="Aggregate_144" routes-to="DedupeName_144">
            <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
            <cc:parameter default="false" name="inBatch" required="true" type="boolean"/><cc:parameter default="(props['inEntityName'] != empty) ? props['inEntityName'] : props['inTargetName']" name="inEntityName" required="props['inCollate']" type="string"/>
        <cc:out-parameter name="outEntityName"/></cc:local-in>
        <cc:async-mediation id="DedupeName_144" routes-to="AggregateToArchive_144">
            <cc:steps>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="14400" failure-message="DebugFile Aggregator (Aggregator_144) parameter failure.  The inCollate and inBatch arguments cannot both be false.">(!props['inCollate'] &amp;&amp; props['inBatch']) ||&#xD;
	(props['inCollate'] &amp;&amp; !props['inBatch']) ||&#xD;
	(props['inCollate'] &amp;&amp; props['inBatch'])</cc:expression>
                </cc:validate-exp>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outEntityName'] = (props['inEntityName'] != empty) ? props['sskStringDeduplicator'].dedupeString(props['inEntityName']) : '';</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_Finalize_144" store-message="none" execute-when="!props['inIsChildThreadContext']" routes-response-to="Call_CreateLogEntryOnThread_Warn_Finalize_144" endpoint="vm://INT006_Greenhouse_Inbound/Aggregate_144"><cc:set name="inCollate" value="false"/><cc:set name="inBatch" value="true"/></cc:local-out>
        <cc:local-out id="Call_Aggregate_Message_144" store-message="none" routes-response-to="Call_CreateLogEntry_Debug_Message_144" endpoint="vm://INT006_Greenhouse_Inbound/Aggregate_144">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        <cc:set name="inEntityName" value="(props['inEntityName'] != empty) ? props['inEntityName'] : props['inTargetName']"/></cc:local-out>
        <cc:async-mediation id="Message_Name_144">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outEntityName'] = props['outEntityName'];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Variable_PrepareValue_144" routes-to="Call_Aggregate_Variable_144">
            <cc:steps>
                <cc:eval id="CopyVarToMsg">
                    <cc:expression>parts[0] = vars[props.inTargetName];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_Variable_144" store-message="none" routes-response-to="Call_CreateLogEntry_Debug_Variable_144" endpoint="vm://INT006_Greenhouse_Inbound/Aggregate_144">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
            <cc:set name="inEntityName" value="(props['inEntityName'] != empty) ? props['inEntityName'] : props['inTargetName']"/>
        </cc:local-out>
        <cc:async-mediation id="Variable_Name_144">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outEntityName'] = props['outEntityName'];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="SetHeaders_103" routes-to="Call_Debug_SoapRequest_103">
            <cc:steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers></cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_BuildRequest_103" store-message="none" execute-when="props['inBuildRequestPathToXsltFile'] != empty" routes-response-to="SetHeaders_103" endpoint="vm://INT006_Greenhouse_Inbound/BuildRequest_103" propagate-abort="true"><cc:set name="inApiVersion" value="props['inApiVersion']"/><cc:set name="inPathToXsltFile" value="props['inPathToXsltFile']"/><cc:set name="inMapPropertyName" value="props['inMapPropertyName']"/><cc:set name="inMapVariableName" value="props['inMapVariableName']"/><cc:set name="inDebugMode" value="props['inDebugMode']"/><cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/></cc:local-out>
        <cc:async-mediation id="StoreArchive_144" execute-steps-when="props['inBatch']">
            <cc:steps>
                <cc:store id="StoreArchive" output="variable" output-variable="localDebugArchive" createDocumentReference="true" expiresIn="@{props['sskPrimaryLogExpires']}" title="@{props['sskDebugArchiveFilename']}"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="BuildRequest_104" routes-to="RouteInputSource_104">
            <cc:parameter default="props['inApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter default="props['inBuildRequestPathToXsltFile']" documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;." name="inBuildRequestPathToXsltFile" required="true" type="string"/>
            <cc:parameter default="props['inBuildRequestDataLocation']" documentation="The java.util.Map instance that holds the key/value pairs of values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapVariableName.  The transform will define pre-established keys for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inBuildRequestDataLocation" required="false" type="string"/>
            <cc:parameter default="context.containsProperty('inBuildRequestDataLocationId') ? props['inBuildRequestDataLocationId'] : null" documentation="The name of the context variable that holds the data values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapPropertyName.  The XML stored in the variable must be compatible with the XSLT provided on inPathToXsltFile.  See aUnit tests for a generic example of a multi-iteration, multi-variable example." name="inBuildRequestDataLocationId" required="false" type="string"/>
            <cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/><cc:parameter default="props['inIsAbortOnError']" name="inIsAbortOnError" required="true" type="boolean"/>
        </cc:local-in>
        <cc:async-mediation id="Validation_Message_104" routes-to="Transform_104">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>props['localIsValueDefined'] = parts[0] != empty;&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (parts[0].isXml());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10400" failure-message="Message part[0] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="10401" failure-message="Message part[0] was not valid XML data.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp></cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Message_104"/>
        </cc:async-mediation>
        <cc:async-mediation id="ValidateAndSetHeaders_104" routes-to="Call_Debug_SoapRequest_104">
            <cc:steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="EvaluateQueryCache">
                    <cc:expression>okToEval = parts[0].isXml();&#xD;
props['localIsQueryCacheEffective'] = okToEval ? parts[0].xstreamB('/env:Envelope/env:Body/*/wd:Response_Filter/wd:As_Of_Effective_Date') : false;&#xD;
props['localIsQueryCacheEntryDate'] = okToEval ? parts[0].xstreamB('/env:Envelope/env:Body/*/wd:Response_Filter/wd:As_Of_Entry_DateTime') : false;</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateQueryCache">
                    <cc:expression error-number="10408" failure-message="Both the Response_Filter/As_Of_Effective_Date and the Response_Filter/As_Of_Entry_DateTime must be set to avoid the tenanted PagedGet query cache from being cleared and recalculated on each page query.  This does not affect functionality, but it does undermine performance and could affect other integrations making PagedGet calls as well.">props['localIsQueryCacheEffective']</cc:expression>
                    <cc:expression error-number="10409" failure-message="Both the Response_Filter/As_Of_Effective_Date and the Response_Filter/As_Of_Entry_DateTime must be set to avoid the tenanted PagedGet query cache from being cleared and recalculated on each page query.  This does not affect functionality, but it does undermine performance and could affect other integrations making PagedGet calls as well.">props['localIsQueryCacheEntryDate']</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_QueryCache_Error_104"/>
        </cc:async-mediation>
        <cc:local-out id="Call_BuildRequest_104" store-message="none" execute-when="props['inBuildRequestPathToXsltFile'] != empty" routes-response-to="ValidateAndSetHeaders_104" endpoint="vm://INT006_Greenhouse_Inbound/BuildRequest_104" propagate-abort="true">
            <cc:set name="inApiVersion" value="props['inApiVersion']"/>
            <cc:set name="inBuildRequestPathToXsltFile" value="props['inBuildRequestPathToXsltFile']"/>
            <cc:set name="inBuildRequestDataLocation" value="props['inBuildRequestDataLocation']"/>
            <cc:set name="inBuildRequestDataLocationId" value="context.containsProperty('inBuildRequestDataLocationId') ? props['inBuildRequestDataLocationId'] : null"/>
            <cc:set name="inDebugMode" value="props['inDebugMode']"/><cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_Finalize_109" store-message="none" execute-when="props['sskIsDebugMode'] || props['outDebugLogged144']" routes-response-to="Call_IEP_99" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'finalize'"/>
            
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_DocumentAccessor_Error_110" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'GetEventDocuments Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while parsing the Get_Event_Documents response.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Info_108" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Integration '# String.valueOf(props['inProgressPercentage']) #'% Complete'"/>
            <cc:set name="inLogMessageDetail" value="props['inProgressMessage']"/>
            
            <cc:set name="inLogLevel" value="'info'"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_Finalize_GEH" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'finalize'"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_SoapResponse_103" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Results_103" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Response__' # props['inWebServiceApplication']"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_Debug_Initialize_Finalize_Error_109" store-message="none" execute-when="props['sskIsDebugMode'] || props['outDebugLogged109']" routes-response-to="Initialize_Handler_109" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'finalize'"/>
        </cc:local-out>
        <cc:async-mediation id="Teardown_107">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsBatch', 'localSourceCounter', 'localSourcesList', 'localCacheMessage']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>// And remove local variables that are no longer required&#xD;
foreach (varname : ['localPreTransformData107', 'localMessageCache107']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_107" routes-to="Teardown_107"/>
        <cc:sync-mediation id="Validation_107" routes-to="Call_AggregateSources_107" routes-response-to="Call_Finally_107">
            <cc:request-steps>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10700" failure-message="Input parameter inDataSourceLocationList was empty.  A comma-separated string of values is expected that defines the variables and/or message root locations and sequence for aggregation to apply your xslt.">props['inDataSourceLocationList'] != empty</cc:expression>
                    <cc:expression error-number="10701" failure-message="Input parameter inDataSourceLocationList did not contain any comma separators implying there is only a single data source value provided.  SSK107 is not appropriate for use with only one data source; transform your data directly instead.">org.apache.commons.lang3.StringUtils.countMatches(props.inDataSourceLocationList, ',') > 0</cc:expression>
                    <cc:expression error-number="10702" failure-message="Input parameter inPathToXsltFile was empty.  A path relative to ws/WSAR-INF is required to apply a transformation to the aggregated inputs.">props['inPathToXsltFile'] != empty</cc:expression>
                </cc:validate-exp>
            </cc:request-steps>
            <cc:response-steps>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_107" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_107"/>
        <cc:local-in id="StreamDataMerge" routes-to="Validation_107" access="public" icon="icons/StreamDataMerge.png">
            <cc:parameter documentation="A comma separated string list of variable names and/or 'message' identifying the locations from which to pull data for aggregation and in what order." name="inDataSourceLocationList" required="true" type="string"/>
            <cc:parameter documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will transform the data from inPayloadDataLocation, enriching and decorating it with data from inEnrichmentDataLocation, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;.  Though this is intended to be a streaming implementation, the responsibility for streaming lies with the developer of the XSLT; this SSK Component is not streaming unless the XSLT correctly implements it." name="inPathToXsltFile" required="true" type="string"/>
            <cc:parameter default="'message'" documentation="Where the results of the transformation are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found.  " name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the aggregated, pre-transform data from variable localPreTransformData107 is output on debug as well as context properties in error conditions." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        	<cc:parameter default="'primary'" documentation="Controls where the xsl:message elements produced in the transformation are logged, whether to the primary or secondary logs.  Component processing and validation messages will still go to the primary log, but data-level messages from the xslt will be directed per this configuration.  Note that the Extra Column configuration of the default secondary log is still coded and therefore assumed." name="inLogTargetForXsltMessages" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTargetForXsltMessages'].trim().toLowerCase()"/>
        </cc:local-in>
        <cc:local-in id="Aggregate_107" routes-to="AggregateData_107"><cc:parameter default="true" name="inCollate" required="true" type="boolean"/><cc:parameter default="false" name="inBatch" required="true" type="boolean"/></cc:local-in>
        <cc:aggregator id="AggregateData_107" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="variable" output-mimetype="text/xml" output-variable="localPreTransformData107">
        <cc:header-text>&lt;Results></cc:header-text>
        <cc:footer-text>&lt;/Results></cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:async-mediation id="Transform_107" routes-to="Call_LogXsltMessages_107">
            <cc:steps>
                <cc:xslt-plus id="ExecuteTransform" input="variable" input-variable="localPreTransformData107" url="@{props['inPathToXsltFile']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Transform_Error_107"/>
        </cc:async-mediation>
        <cc:async-mediation id="FinalizeResults" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars[props.inReturnResults] = parts[0].source;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Transform_Error_107" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'XSLT Transform Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred executing the payload transformation using enrichment data.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_107'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:sync-mediation id="MainFlowControl_109" routes-to="Call_Main_109" routes-response-to="Call_IEP_90">
            <cc:request-steps>
                <cc:eval id="LoopDetectBugWorkaround1">
                    <cc:expression>//This Loop-Detected workaround is necessary; otherwise, any exceptions raised in the close-down process and handled by SA-109 will produce a loop detected error and obscure the actual error that occurred within Main.&#xD;
props[&quot;globalProcessFlagLoopControl&quot;] = com.workday.custom.int006.ssk109.LocalOutHelper.SnapshotLoopDetection(context);</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="ResetAbort">
                    <cc:expression>context.setAbort(false);</cc:expression>
                </cc:eval>
                <cc:eval id="LoopDetectBugWorkaround2">
                    <cc:expression>com.workday.custom.int006.ssk109.LocalOutHelper.ClearLoopDetectionFlags(context, props[&quot;globalProcessFlagLoopControl&quot;]);</cc:expression>
                </cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:sync-mediation id="Variable_InitializeAndFinalize_Parent_144" routes-to="Variable_PrepareValue_144" execute-steps-when="!message.isNullContentRootPart()">
            <cc:request-steps>
                <cc:copy id="SaveMsg" output="variable" output-variable="debugTemporaryStorage" stream-xpath="true"/></cc:request-steps>
            <cc:response-steps>
            
                <cc:eval id="CleanUp">
                    <cc:expression>vars['debugTemporaryStorage'] = null;</cc:expression>
                </cc:eval>
                <cc:copy id="RestoreMsg" output="message" input="variable" input-variable="debugTemporaryStorage" stream-xpath="true"/>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-out id="Call_HandleError_NormalizeResponse_Error_102" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'SOAP Unwrap Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while unwrapping the RaaS results from the SOAP envelope.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="'SOAP-Response__' # props['inReportServiceAlias']"/>
            
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="NormalizeResponse_102">
            <cc:steps>
                <cc:xslt-plus id="UnwrapSoap" output-mimetype="text/xml" url="xslt/ssk102/SSK102_UnwrapSoapTransform.xsl"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_NormalizeResponse_Error_102"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_HttpOut_Error_102" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Execution Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while executing reports-as-a-service for the '# props['inReportServiceAlias'] #' report alias.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="HttpOut_Catch_102" routes-to="HttpOut_102" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_HttpOut_Error_102"/>
        </cc:async-mediation>
        <cc:http-out id="HttpOut_102" store-message="none" routes-response-to="NormalizeResponse_102" endpoint="@{intsys.reportService.getEndpoint(props.inReportServiceAlias)}" http-method="POST"/>
        <cc:local-out id="Call_Debug_SoapRequest_102" store-message="none" execute-when="props['inDebugMode']" routes-response-to="HttpOut_Catch_102" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Request__' # props['inReportServiceAlias']"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_ComposeRequest_Error_102" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Preparation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a reports-as-a-service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-in id="ExecuteWithRest_102" routes-to="Call_Debug_RaaSRequest_102"><cc:parameter default="props['localRestUrl']" documentation="The full rest query including all querystring parameters" name="inRestUrl" required="true" type="string"/><cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/></cc:local-in>
        <cc:local-in id="ExecuteWithSoap_102" routes-to="Call_CreateLogEntry_ExecuteWithSoap_Info_102"><cc:parameter default="props['inReportServiceAlias']" documentation="The Report Service configuration from which to retrieve results." name="inReportServiceAlias" required="true" type="string"/><cc:parameter default="props['inPropertyNameReportPromptMap']" documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  If the report is not parameterized, then leave this input parameter empty.  If setting this input parameter though, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap." name="inPropertyNameReportPromptMap" required="true" type="string"/><cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/></cc:local-in>
        <cc:route id="ChooseProtocol_102">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['localIsValidUrlLength']" route="REST"/>
                <cc:choose-route expression="true" route="SOAP"/>
            </cc:mvel-strategy>
            <cc:sub-route name="REST" routes-to="Call_ExecuteWithRest_102"/>
            <cc:sub-route name="SOAP" routes-to="Call_ExecuteWithSoap_102"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntry_ExecuteWithSoap_Info_102" store-message="none" execute-when="!props['inIsChildThreadContext']" routes-response-to="Call_CreateThreadLogEntry_Info_102" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Executing reports-as-a-service for the '# props['inReportServiceAlias'] #' report alias using SOAP.'"/>
            <cc:set name="inLogMessageDetail" value="'The URL constructed including querystring parameters exceed the maximum URL length for RESTful RaaS calls of 16000 Bytes.  Switching to use SOAP as protocol.'"/>
            
            <cc:set name="inLogLevel" value="'info'"/>
            
            
            
            
        </cc:local-out>
        <cc:local-out id="Call_ExecuteWithRest_102" store-message="none" routes-response-to="Results_102" endpoint="vm://INT006_Greenhouse_Inbound/ExecuteWithRest_102"><cc:set name="inRestUrl" value="props['localRestUrl']"/></cc:local-out>
        <cc:local-out id="Call_ExecuteWithSoap_102" store-message="none" routes-response-to="Results_102" endpoint="vm://INT006_Greenhouse_Inbound/ExecuteWithSoap_102"><cc:set name="inPropertyNameReportPromptMap" value="props['inPropertyNameReportPromptMap']"/><cc:set name="inReportServiceAlias" value="props['inReportServiceAlias']"/><cc:set name="inDebugMode" value="props['inDebugMode']"/></cc:local-out>
        <cc:async-mediation id="ComposeRequest_102" routes-to="Call_Debug_SoapRequest_102">
            <cc:steps>
                <cc:custom id="WriteSoapRequest" ref="SSK102SoapAuthorBean"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_ComposeRequest_Error_102"/>
        </cc:async-mediation>
        <cc:local-in id="AddReportPromptFromProperty" routes-to="Call_CreateLogEntry_Warn_101" access="public" icon="icons/AddReportPromptFromProperty.png">
			<cc:parameter documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  When setting this input parameter, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap.  This data structure can be easily created through the com.workday.custom.int006.ssk102.ParameterMapHelper class and initializeParameterMap method and then subsequently managed with the SSK101 SSK Components." name="inPropertyNameReportPromptMap" required="true" type="string"/>
        	<cc:parameter documentation="The XML name of the report prompt as specified on the Prompts tab of the Custom Report." name="inReportPromptName" required="true" type="string"/>
        	<cc:parameter documentation="The Id type of the value being provided on the prompt if the value is an instance reference.  For example, if the report prompt accepted workers and you were sending employees, this value might be 'Employee_ID'.  If the report prompt is a non-instance value, this parameter may be left empty / omitted." name="inReferenceIdType" required="false" type="string"/>
        	<cc:parameter documentation="The value to be assigned to the report prompt.  This may be a numeric value, string value or instance reference id." name="inValue" required="true"/>
        </cc:local-in>
        <cc:local-in id="AddReportPromptFromXml" routes-to="InitializeAndFinalize_Xml_101" icon="icons/AddReportPromptFromXml.png">
			<cc:parameter documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  When setting this input parameter, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap.  This data structure can be easily created through the com.workday.custom.int006.ssk102.ParameterMapHelper class and initializeParameterMap method and then subsequently managed with the SSK101 SSK Components." name="inPropertyNameReportPromptMap" required="true"/>
            <cc:parameter documentation="The XML name of the report prompt as specified on the Prompts tab of the Custom Report." name="inReportPromptName" required="true" type="string"/>
            <cc:parameter documentation="The Id type of the value being provided on the prompt if the value is an instance reference.  For example, if the report prompt accepted workers and you were sending employees, this value might be 'Employee_ID'.  If the report prompt is a non-instance value, this parameter may be left empty / omitted." name="inReferenceIdType" required="false" type="string"/>
            <cc:parameter documentation="The location where the XML data containing the parameter values can be found.  This may be either on the Message root or in a variable.  In the former case, specify the value of this parameter as the literal 'message'.  Otherwise, if the value is found in a variable, please set this parameter to the name of that variable." name="inParameterDataLocation" required="true" type="string" validation="props['inParameterDataLocation'] == 'message' || vars.isVariable(props.inParameterDataLocation)"/>
            <cc:parameter documentation="The XPath query that will select the values from the XML data to be used as report parameters." name="inQueryToValue" required="true" type="string"/>
            <cc:parameter documentation="XPath expression which can optionally be executed against the elements returned by QueryToEntry in order to determine if those entries should be stored in the map" name="inEntryFilter" required="false" type="string"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the dynamic XSLT is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Xml_Error_101" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Parameter Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a reports-as-a-service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_Xml_101" routes-to="NormalizeMapValues_Xml_101" continue-after-error="rewind" handle-downstream-errors="false" routes-response-to="Call_Finally_Multiple_101">
            <cc:request-steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>props['localIsPromptsMap'] = context.getProperty(props['inPropertyNameReportPromptMap']) instanceof java.util.Map;</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10101" failure-message="The value contained in the property @{props['inPropertyNameReportPromptMap']} as specified on the input parameter inPropertyNameReportPromptMap is not a map.">props['localIsPromptsMap']</cc:expression>
                </cc:validate-exp>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Xml_Error_101"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Property_Error_101" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Parameter Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a reports-as-a-service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_Property_101" routes-to="NormalizeMapValues_Property_101" continue-after-error="rewind" handle-downstream-errors="false" routes-response-to="Call_Finally_Single_101">
            <cc:request-steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>props['localIsPromptsMap'] = context.getProperty(props['inPropertyNameReportPromptMap']) instanceof java.util.Map;</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10100" failure-message="The value contained in the property @{props['inPropertyNameReportPromptMap']} as specified on the input parameter inPropertyNameReportPromptMap is not a map.">props['localIsPromptsMap']</cc:expression>
                </cc:validate-exp>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Property_Error_101"/>
        </cc:sync-mediation>
        <cc:async-mediation id="Teardown_101">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsPromptsMap','localKey','localValue']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['localXslt101']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_101" routes-to="Teardown_101"/>
        <cc:local-out id="Call_Finally_Single_101" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_101"/>
        <cc:local-out id="Call_Finally_Multiple_101" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_101"/>
        <cc:async-mediation id="NormalizeMapValues_Property_101" routes-to="Validate_Property_101">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['localKey'] = (props['inReferenceIdType'] == empty) ? props['inReportPromptName'] : props['inReportPromptName'] # '!' # props['inReferenceIdType'];</cc:expression>
                    <cc:expression>if (props['inValue'] instanceof java.lang.Object) {&#xD;
	props['localValue'] = props['inValue'];&#xD;
} else {&#xD;
	props['localValue'] = String.valueOf(props['inValue']);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_NormalizeMapValues_Property_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_NormalizeMapValues_Property_Error_101" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Prompt Key/Value Pair Error'"/>
            <cc:set name="inLogMessageDetail" value="'A problem was encountered while composing the key and value data for map storage on the ' # props['inReportPromptName'] # ' report prompt.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:local-out id="Call_HandleError_Validate_Property_Error_101" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Duplicate Map Key'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while validating a reports-as-a-service prompt key/value pair.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:async-mediation id="Validate_Property_101" routes-to="UpdateMap_Property_101">
            <cc:steps>
                <cc:validate-exp id="ValidateKey">
                    <cc:expression error-number="10102" failure-message="The map already contains a key named @{props['localKey']}.">!(((java.util.Map)props[props.inPropertyNameReportPromptMap]).containsKey(props.localKey))</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Validate_Property_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_UpdateMap_Property_Error_101" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Map Update Error'"/>
            <cc:set name="inLogMessageDetail" value="'A problem was encountered while writing the value data under the ' # props['localKey'] # ' report prompt in the ' # props['inPropertyNameReportPromptMap'] # ' map.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:async-mediation id="UpdateMap_Property_101">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>((java.util.Map)props[props.inPropertyNameReportPromptMap]).put(props['localKey'], props['localValue']);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_UpdateMap_Property_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_UpdateMap_Xml_Error_101" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Map Update Error'"/>
            <cc:set name="inLogMessageDetail" value="'A problem was encountered while writing the value data under the ' # props['localKey'] # ' report prompt in the ' # props['inPropertyNameReportPromptMap'] # ' map.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="UpdateMap_Xml_101">
            <cc:steps>
                <cc:xslt-plus id="BuildList" url="mctx:vars/localXslt101"/>
                <cc:eval id="UpdateValues">
                    <cc:expression>((java.util.Map)props[props.inPropertyNameReportPromptMap]).put(props['localKey'], props['localValue']);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_UpdateMap_Xml_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Validate_Xml_Error_101" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Duplicate Map Key'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while validating a reports-as-a-service prompt key/value pair.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="Validate_Xml_101" routes-to="UpdateMap_Xml_101">
            <cc:steps>
                <cc:validate-exp id="Validations">
                    <cc:expression error-number="10104" failure-message="The map already contains a key named @{props['localKey']}.">!(((java.util.Map)props[props.inPropertyNameReportPromptMap]).containsKey(props.localKey))</cc:expression>
                    <cc:expression error-number="10105" failure-message="The referenced data for transformation into Report Prompt data indicated at @{props['inParameterDataLocation']} is not in XML format.">parts[0].isXml()</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Validate_Xml_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_NormalizeMapValues_Xml_Error_101" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Prompt Key/Value Pair Error'"/>
            <cc:set name="inLogMessageDetail" value="'A problem was encountered while composing the key and value data for map storage on the ' # props['inReportPromptName'] # ' report prompt.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="NormalizeMapValues_Xml_101" routes-to="Call_Debug_Xslt_101">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['localKey'] = (props['inReferenceIdType'] == empty) ? props['inReportPromptName'] : props['inReportPromptName'] # '!' # props['inReferenceIdType'];</cc:expression>
                    <cc:expression>props['localValue'] = new java.util.ArrayList();</cc:expression>
                </cc:eval>
                <cc:write id="WriteXslt" output="variable" output-variable="localXslt101">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;xsl:stylesheet version=&quot;3.0&quot; &#xD;
    xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&#xD;
    xmlns:env=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&#xD;
    xmlns:wd=&quot;urn:com.workday/bsvc&quot;&#xD;
    xmlns:tube=&quot;java:com.capeclear.mediation.impl.cc.MediationTube&quot;&#xD;
    xmlns:ctx=&quot;java:com.capeclear.mediation.MediationContext&quot;&#xD;
    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&#xD;
    xmlns:jlist=&quot;java:java.util.List&quot;&#xD;
    xmlns:jt=&quot;http://saxon.sf.net/java-type&quot;&#xD;
    xmlns:this=&quot;urn:this&quot;>&#xD;
    &#xD;
    &lt;xsl:param name=&quot;inQueryToValue&quot; as=&quot;xs:string&quot;/>&#xD;
    &#xD;
    &lt;xsl:mode streamable=&quot;yes&quot; on-no-match=&quot;shallow-skip&quot;/>&#xD;
    &lt;xsl:mode streamable=&quot;no&quot; on-no-match=&quot;shallow-skip&quot; name=&quot;in-memory&quot;/>&#xD;
    &#xD;
    &lt;!-- Obtain the current MediationContext in use in the assembly -->&#xD;
    &lt;xsl:variable name=&quot;ctx&quot; select=&quot;tube:getCurrentMediationContext()&quot;/>&#xD;
    &#xD;
    &lt;!-- Retrieve the Java List stored in the context property localValue -->&#xD;
    &lt;xsl:variable name=&quot;list&quot; select=&quot;ctx:getProperty($ctx, 'localValue')&quot; as=&quot;jt:java.util.List&quot;/>&#xD;
    &#xD;
    &lt;xsl:template match=&quot;/&quot;>&#xD;
        &lt;ListHelper>&#xD;
            &lt;!-- Now process the input file.  The EntryFilter variable can then be optionally used to only select those entries matching that value.  The filter can only navigate the descendant axis since only the node and and descendants returned by the QueryToEntry expression are brought into memory -->&#xD;
            &lt;xsl:apply-templates select=&quot;@{props['inQueryToValue']}/copy-of()@if{props['inEntryFilter'] != empty}@{props['inEntryFilter']}@end{}&quot; mode=&quot;in-memory&quot;/>    		&#xD;
        &lt;/ListHelper>&#xD;
    &lt;/xsl:template>&#xD;
    &#xD;
    &lt;!-- Process each entry -->&#xD;
    &lt;xsl:template match=&quot;*&quot; mode=&quot;in-memory&quot;>&#xD;
        &lt;xsl:variable name=&quot;value&quot;	 select=&quot;./text()&quot; as=&quot;xs:string&quot;/>&#xD;
        &lt;templateMatched/>&#xD;
		&lt;xsl:value-of select=&quot;jlist:add($list, $value)&quot;/>&#xD;
    &lt;/xsl:template>&#xD;
&lt;/xsl:stylesheet></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_NormalizeMapValues_Xml_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_PrepareInputData_Xml_Error_101" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Map Preparation Error'"/>
            <cc:set name="inLogMessageDetail" value="'A problem was encountered while moving the value data from the ' # props['inParameterDataLocation'] # ' variable to the message root for extraction.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="PrepareInputData_Xml_101" routes-to="Validate_Xml_101" execute-steps-when="props['inParameterDataLocation'] != 'message'">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>parts[0] = vars[props.inParameterDataLocation];</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_PrepareInputData_Xml_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_Xslt_101" store-message="none" execute-when="props['inDebugMode']" routes-response-to="PrepareInputData_Xml_101" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'localXslt101'"/>
            
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-in id="HandleError" routes-to="Threading_141" access="public" icon="icons/HandleError.png">
            <cc:parameter documentation="Value passed to CreateLogEntry's inLogMessage parameter." name="inLogMessage" required="true" type="string"/>
            <cc:parameter documentation="Value passed to CreateLogEntry's inLogMessageDetail parameter." name="inLogMessageDetail" required="false" type="string"/>
            <cc:parameter documentation="Value passed to CreateLogEntry's inLogReferenceId parameter." name="inLogReferenceId" required="false" type="string"/>
            <cc:parameter documentation="Value passed to CreateLogEntry's inLogLevel parameter.  Validation is performed by CreateLogEntry." name="inLogLevel" required="true" type="string"/>
            <cc:parameter default="context.errorComponentId" documentation="Value passed to CreateLogEntry's inExtraLocalIn parameter." name="inExtraLocalIn" required="false"/>
            <cc:parameter documentation="Value passed to CreateLogEntry's inExtraRecordNumber parameter." name="inExtraRecordNumber" required="false"/>
            <cc:parameter default="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')" documentation="Value passed to CreateLogEntry's inExtraSupportData parameter." name="inExtraSupportData" required="false"/><cc:parameter default="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''" documentation="Value passed to CreateLogEntry's inExtraErrorCode parameter." name="inExtraErrorCode" required="false"/><cc:parameter documentation="The SSK Component endpoint to call for clean-up of properties and/or variables." name="inFinallyEndpoint" required="false" type="string"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler.  In order for this parameter to have an effect of aborting the SSK Component from which it was called, the Propagate Abort setting on the Advanced tab of the calling Local-Out component must be set to true." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="false" documentation="When set to true, clears the residual error details by setting a null exception." name="inIsResetError" required="false" type="boolean"/><cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the dynamic XSLT is output on debug." name="inIncludeDebugOutput" required="true" type="boolean"/>
        	<cc:parameter default="'message'" documentation="The type of information to be output to the log." name="inTargetType" required="props['inIncludeDebugOutput']" type="string" validation="props['sskDebugTargetTypeValidation'].contains(props['inTargetType'])"/>
        	<cc:parameter documentation="The reference name to use for single-named output types selected on inTargetType.  Required when inTargetType is one of: property, variable, list, map, or set." name="inTargetName" required="props['inIncludeDebugOutput'] &amp;&amp; (['property','properties','variable','map','list','set'] contains props['inTargetType'].trim().toLowerCase())" type="string" validation="props['sskDebugTargetNameValidation'].contains(props['inTargetType']) &amp;&amp;&#xD;&#xA;(props['inTargetName'] != empty || props['inEntityName'] != empty)"/>
        	<cc:parameter documentation="A specific filename to use when exporting the message or variable content to a file zipped in a consolidated archive.  This is optional and only used when inTargetType is &quot;message&quot; or &quot;variable&quot;." name="inEntityName" required="props['inIncludeDebugOutput'] &amp;&amp; (['message','variable'] contains props['inTargetType'].trim().toLowerCase())" type="string"/><cc:parameter default="'primary'" documentation="Controls whether the error message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        	<cc:out-parameter documentation="If a file has been written to the debug archive, the name of that file will be returned for further reference in logging messages." name="outEntityName"/>
        </cc:local-in>
        <cc:local-out id="Call_Finally_141" store-message="none" execute-when="props['inFinallyEndpoint'] != empty" routes-response-to="Handler_141" endpoint="@{props['inFinallyEndpoint']}"/>
        <cc:async-mediation id="Handler_141" routes-to="AbortOnError_141">
            <cc:steps>
                <cc:eval id="HandleError">
                    <cc:expression>if (props.containsKey('inIsResetError') &amp;&amp; props.inIsResetError) { context.setException(null); }</cc:expression>
                    <cc:expression>context.setErrorHandled(true);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="AbortOnError_141" execute-steps-when="props['inIsAbortOnError']">
            <cc:steps>
                <cc:eval id="SetAbort">
                    <cc:expression>context.setAbort(true);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_141" store-message="none" execute-when="props['inLogTarget'] == 'primary'" routes-response-to="Call_CreateSecondaryLogEntry_141" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="props.inLogMessage"/>
            <cc:set name="inLogMessageDetail" value="if (context.containsProperty('inLogMessageDetail')) {&#xD;&#xA;&#x9;(props['inLogMessageDetail'] != empty) ? props['inLogMessageDetail'] : ''&#xD;&#xA;} else {&#xD;&#xA;&#x9;''&#xD;&#xA;}"/>
            <cc:set name="inLogReferenceId" value="if (context.containsProperty('inLogReferenceId')) {&#xD;&#xA;&#x9;(props['inLogReferenceId'] != empty) ? props['inLogReferenceId'] : ''&#xD;&#xA;} else {&#xD;&#xA;&#x9;''&#xD;&#xA;}"/>
            <cc:set name="inLogLevel" value="props.inLogLevel"/>
            <cc:set name="inExtraLocalIn" value="if (context.containsProperty('inExtraLocalIn')) {&#xD;&#xA;&#x9;props['inExtraLocalIn']&#xD;&#xA;} else {&#xD;&#xA;&#x9;''&#xD;&#xA;}"/>
            <cc:set name="inExtraRecordNumber" value="if (context.containsProperty('inExtraRecordNumber')) {&#xD;&#xA;&#x9;props['inExtraRecordNumber']&#xD;&#xA;} else {&#xD;&#xA;&#x9;''&#xD;&#xA;}"/>
            <cc:set name="inExtraSupportData" value="if (context.containsProperty('inExtraSupportData')) {&#xD;&#xA;&#x9;props['inExtraSupportData']&#xD;&#xA;} else {&#xD;&#xA;&#x9;''&#xD;&#xA;}"/>
            <cc:set name="inExtraErrorCode" value="if (context.containsProperty('inExtraErrorCode')) {&#xD;&#xA;&#x9;props['inExtraErrorCode']&#xD;&#xA;} else {&#xD;&#xA;&#x9;''&#xD;&#xA;}"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_Parent_141" store-message="none" execute-when="props['inIncludeDebugOutput'] &amp;&amp; props['inTargetType'] != empty" routes-response-to="Call_Finally_141" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="props['inTargetType']"/>
            <cc:set name="inTargetName" value="props['inTargetName']"/>
            <cc:set name="inEntityName" value="props['inEntityName']"/>
        <cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:local-out id="Call_Debug_Result_102" store-message="none" execute-when="props['inDebugMode'] || props['inSaveResultsToIntegrationEvent']" routes-response-to="ThreadedResultOutput_102" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="props['inReturnResults'] != 'message' ? 'variable' : 'message'"/>
            <cc:set name="inTargetName" value="props['inReturnResults'] == 'message' ? null : props.inReturnResults"/><cc:set name="inEntityName" value="'RAAS-Results__' # props['inReportServiceAlias']"/>
            
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-in id="InitializeFrameworkThenRunMain" routes-to="Initialize_109" access="public" icon="icons/InitializeFrameworkThenRunMain.png"><cc:parameter default="'vm://INT006_Greenhouse_Inbound/Main'" documentation="This parameter value will define the main flow and logic processing of the integration.  This is where all of the requirements-specific work will happen in between the StarterKit framework initialization and finalization." name="inMainEndpoint" required="true" type="string"/></cc:local-in>
        <cc:local-out id="Call_InitializeFrameworkThenRunMain" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/InitializeFrameworkThenRunMain" unset-properties="false"><cc:set name="inMainEndpoint" value="'vm://INT006_Greenhouse_Inbound/Main'"/></cc:local-out>
        <cc:async-mediation id="RetrieveMessage_112" routes-to="Call_WriteLog_112">
            <cc:steps>
                <cc:eval id="UpdateValues"><cc:expression>props['localLogMessage'] = props['localLogIterator'].next()</cc:expression></cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="LoopOverMessages_112">
            <cc:loop-strategy condition="props['localLogIterator'].hasNext()" repeat-limit="200000"/>
            <cc:sub-route name="Loop" routes-to="RetrieveMessage_112"/>
        </cc:route>
        <cc:sync-mediation id="InitializeAndFinalize_112" routes-to="LoopOverMessages_112" handle-downstream-errors="true">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props.localLogIterator = new com.workday.custom.int006.ssk112.ObjectIterator(props.inLogIterator)</cc:expression>
                    <cc:expression>props.localHasMessages = props.localLogIterator.hasNext()</cc:expression>
                    <cc:expression>whichLog = ((props['inIsChildThreadContext']) ? 'CreateLogEntryOnThread' : ((props['inLogTarget'] == 'secondary') ? 'WriteSecondaryLog_' : 'WritePrimaryLog_'));&#xD;
whichFormat = ((props['inLogTarget'] == 'secondary') ? props['sskSecondaryLogFileFormat'] : props['sskPrimaryLogFileFormat']);&#xD;
props.dynamicEndpoint112 = 'vm://INT006_Greenhouse_Inbound/' # whichLog # whichFormat # '_142';</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp"><cc:expression>foreach (name: {'localHasMessages', 'localLogMessage', 'localLogIterator', 'dynamicEndpoint112'}) { context.removeProperty(name) } </cc:expression></cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-in id="CloudLogMessages_112" routes-to="InitializeAndFinalize_112" access="private">
            <cc:parameter documentation="An instance of Iterator&lt;CloudLogAdapter> which will be used to iterate over all the messages to be placed in the cloud-log" name="inLogIterator" required="true"/><cc:parameter documentation="Passed-through value of which log to write to" name="inLogTarget" required="true" type="string" validation="props['inLogTarget']"/>
        </cc:local-in>
        <cc:local-in id="CloudLogETVXTTMessages" routes-to="InitializeAndFinalize_ETVXTT_112" access="public" icon="icons/CloudLogETVXTTMessages.png">
            <cc:parameter default="props['etv.messages']" documentation="An instance of ETVInfoCollection" name="inMessages" required="false" validation="props['inMessages'] instanceof com.workday.mediation.impl.mediators.etv.ETVInfoCollection"/>
            <cc:parameter default="false" documentation="Specifies whether the collection should be cleared after it is output to the log.  The default is to be cleared." name="inIsClearMessages" required="false" type="boolean"/>
            <cc:parameter default="'INFO'" documentation="Minimum severity level to be reported.  Defaults to INFO" name="inMinLogLevel" required="false" validation="['INFO','WARNING','ERROR','CRITICAL'] contains props['inMinLogLevel'].trim().toUpperCase()"/>
         	<cc:parameter default="'primary'" documentation="Controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/><cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-in id="CloudLogXSLTMessages" routes-to="InitializeAndFinalize_XSLT_112" access="public" icon="icons/CloudLogXSLTMessages.png">
            <cc:parameter default="props['xsltstep.messages']" documentation="An instance of java.util.List which contains the messages" name="inMessages" required="true" validation="props['inMessages'] instanceof java.util.List"/>
            <cc:parameter default="true" documentation="Specifies whether the inXSLTMessages list should be cleared after it is output to the log.  The default is to be cleared." name="inIsClearMessages" required="false" type="boolean"/>
            <cc:parameter default="'debug'" documentation="The minimum level for which messages will be output.  If no value is given a default of debug will be used" name="inMinLogLevel" required="false" validation="['debug','info','warn','error','fatal'] contains props['inMinLogLevel'].trim().toLowerCase()"/>
        	<cc:parameter default="'primary'" documentation="Controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/><cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_CloudLogMessages_XSLT_112" store-message="none" execute-when="props['inMessages'] != empty" endpoint="vm://INT006_Greenhouse_Inbound/CloudLogMessages_112"><cc:set name="inLogIterator" value="com.workday.custom.int006.ssk112.CloudLogXsltStepIterator.getIterator(props['inMessages'], props['inMinLogLevel'])"/><cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_XSLT_112" routes-to="Call_CloudLogMessages_XSLT_112">
            <cc:request-steps>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>if (props['inIsClearMessages']) { props['inMessages'].clear() }</cc:expression><cc:expression>foreach (name: {'inMessages', 'inIsClearMessages', 'inMinLogLevel'}) { context.removeProperty(name) } </cc:expression></cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-out id="Call_CloudLogMessages_ETVXTT_112" store-message="none" execute-when="(props['inMessages'] != null) &amp;&amp; (props['inMessages'].currentSize() > 0)" endpoint="vm://INT006_Greenhouse_Inbound/CloudLogMessages_112">
            <cc:set name="inLogIterator" value="com.workday.custom.int006.ssk112.CloudLogETVIterator.getIterator(props['inMessages'], props['inMinLogLevel'].trim().toUpperCase())"/>
        <cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_ETVXTT_112" routes-to="Call_CloudLogMessages_ETVXTT_112">
            <cc:request-steps/>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>if (props['inIsClearMessages']) { props['inMessages'].clear() }</cc:expression><cc:expression>foreach (name: {'inMessages', 'inIsClearMessages', 'inMinLogLevel'}) { context.removeProperty(name) } </cc:expression></cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:aggregator id="AggregateFile_115" routes-to="SendResultsBackToMainThread_115" collate-when="props['aggregator.destination.force.collate']" force-batch-on-last-message="false" force-batch-when="props['aggregator.destination.force.batch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="message" output-mimetype="text/xml" xpath="*/*">
        <cc:header-text>&lt;DISRoot xmlns:tdf=&quot;urn:com.workday/tdf&quot;></cc:header-text>
        <cc:footer-text>&lt;/DISRoot></cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-in id="Aggregate_115" routes-to="PrepareFile_115">
            
            
        </cc:local-in>
        <cc:async-mediation id="Teardown_115">
            <cc:steps>
                <cc:eval id="CleanUp">
						<cc:expression>foreach (propname : ['localXPathPredicateDefault', 'localXPathPredicateService', 'localLabels', 'localFileCount']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['localXslt115','c2pAggregatedResult']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
					</cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_115" routes-to="Teardown_115"/>
        <cc:local-out id="Call_Debug_Message_115" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Results_115" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'DIS_Aggregated_File'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_Results_Error_115" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the DIS results from the message rootpart to variable globalDISResults.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_115'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="'DISResults'"/>
        </cc:local-out>
        <cc:async-mediation id="Results_115" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars[props.inReturnResults] = parts[0].source;</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Results_Error_115"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Finally_115" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_115">
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:local-out id="GetEventDocuments_115" store-message="none" routes-response-to="Call_Debug_DocumentResults_115" endpoint="vm://wcc/GetEventDocuments">
            <cc:set name="ie.event.wid" value="props['inEventWID']"/>
        </cc:local-out>
        <cc:local-in id="GetDISResults" routes-to="InitializeAndFinalize_115" access="public" icon="icons/GetDISResults.png">
            <cc:parameter default="context.containsProperty('sskDebugWID') ? props['sskDebugWID'] : props['sskEventWID']" documentation="WID of the Integration Event from which the documents will be queried.  This is typically the current event, and as such, is defaulted to the current event WID.  However, changing this WID enables retrieving documents from another related event for processing." name="inEventWID" required="true" type="string"/>
            <cc:parameter default="context.containsProperty('sskRetrievalDocTag') ? props['sskRetrievalDocTag'] : null" documentation="Specifies a Document Tag for filtering the input files on the Integration Event in addition to the default &quot;Data - Partial&quot; used by DIS.  &quot;Data - Partial&quot; is assumed and should not be provided.  If no additional tag is specified, then only the &quot;Data - Partial&quot; tag will be used.  This should be a single value that matches to the DIS service name and is useful when you have multiple DIS services configured on your integration and you need to aggregate those values separately." name="inRetrievalDocTag" required="false" type="string"/>
            <cc:parameter default="'message'" documentation="Where the results of the response are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the DIS results are output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/><cc:parameter default="false" documentation="When this parameter is set to true, the component will use a single-threaded, serialized approach to aggregate the partial data files in ascending order to preserve sorting done in the DIS itself." name="inIsUseOrderedAggregation" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_ParallelSubroutine_115" store-message="none" routes-response-to="CopyResultFromThreads_115" endpoint="vm://wcc/ParallelSubroutine"><cc:set name="parallel.processing.aggregation.endpoint" value="'vm://INT006_Greenhouse_Inbound/Aggregate_115'"/><cc:set name="parallel.processing.worker.endpoint" value="'vm://INT006_Greenhouse_Inbound/ProcessFile_115'"/><cc:set name="parallel.processing.worker.count" value="4"/><cc:set name="parallel.processing.worker.timeout" value="60"/><cc:set name="parallel.processing.timeout" value="1200"/><cc:set name="parallel.processing.splitter" value="spring.getBean('SSK115FileSplitter')"/></cc:local-out>
        <cc:local-in id="ProcessFile_115" routes-to="ReadFile_115"/>
        <cc:async-mediation id="ReadFile_115">
            <cc:steps>
                <cc:retrieve id="Retrieve" output="variable" output-mimetype="text/xml" output-variable="c2pDocument" collection="@{parts[0].xstream('/Documents/Document/Collection')}" entry="@{parts[0].xstream('/Documents/Document/EntryID')}"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareFile_115" routes-to="AggregateFile_115" execute-steps-when="props['aggregator.destination.force.collate']">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" input="variable" input-variable="c2pDocument"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="SendResultsBackToMainThread_115">
            <cc:steps>
                <cc:copy id="CopyMsgToVar" output="variable" output-mimetype="text/xml" output-variable="c2pAggregatedResult"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteFileCount_Parallel_115">
            <cc:mvel-strategy>
                <cc:choose-route expression="!parts[0].xstreamB('/*/*')" route="NoFiles"/>
                <cc:choose-route expression="true" route="Files"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Files" routes-to="Call_ParallelSubroutine_115"/>
            <cc:sub-route name="NoFiles" routes-to="Call_CreateLogEntry_NoFiles_Info_115"/>
        </cc:route>
        <cc:async-mediation id="PrepareFileResults_Parallel_115" routes-to="RouteFileCount_Parallel_115">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localXPathPredicateDefault'] = 'wd:Document_Tag_Reference/wd:ID[@wd:type=\'Workday_Document_Tag_Name\'] = \'Data - Partial\'';&#xD;
props['localXPathPredicateService'] = (props['inRetrievalDocTag'] == empty ? '' : 'wd:Document_Tag_Reference/wd:ID[@wd:type=\'Integration_Service_Name\'] = \''# props['inRetrievalDocTag'] #'\'');</cc:expression>
                </cc:eval>
                <cc:write id="LoadXslt" output="variable" output-variable="localXslt115">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;xsl:stylesheet &#xD;
	xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&#xD;
    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&#xD;
    xmlns:wd=&quot;urn:com.workday/bsvc&quot;&#xD;
    exclude-result-prefixes=&quot;#all&quot;&#xD;
    version=&quot;3.0&quot;>&#xD;
    &#xD;
    &lt;xsl:mode streamable=&quot;yes&quot; on-no-match=&quot;shallow-skip&quot;/>&#xD;
    &lt;xsl:mode name=&quot;in-memory&quot; streamable=&quot;no&quot;/>&#xD;
    &#xD;
    &lt;xsl:output indent=&quot;no&quot;/>&#xD;
    &#xD;
    &lt;xsl:template match=&quot;/&quot;>&#xD;
        &lt;Documents>&#xD;
            &lt;xsl:apply-templates/>&#xD;
        &lt;/Documents>&#xD;
    &lt;/xsl:template>&#xD;
&#xD;
    &lt;xsl:template match=&quot;wd:Repository_Document&quot;>&#xD;
        &lt;xsl:apply-templates select=&quot;wd:Repository_Document_Data/copy-of()[@{props['localXPathPredicateDefault']}@if{props['localXPathPredicateService'] != empty} and @{props['localXPathPredicateService']}@end{}]&quot; mode=&quot;in-memory&quot;/>&#xD;
    &lt;/xsl:template>&#xD;
&#xD;
    &lt;xsl:template match=&quot;wd:Repository_Document_Data&quot; mode=&quot;in-memory&quot;>&#xD;
	    &lt;Document>&#xD;
	    	&lt;Collection>&lt;xsl:value-of select=&quot;substring-before(@wd:Document_ID, '/')&quot;/>&lt;/Collection>&#xD;
	    	&lt;EntryID>&lt;xsl:value-of select=&quot;substring-after(@wd:Document_ID, '/')&quot;/>&lt;/EntryID>&#xD;
	    &lt;/Document>&#xD;
    &lt;/xsl:template>&#xD;
&lt;/xsl:stylesheet></cc:text>
                    </cc:message>
                </cc:write>
                <cc:xslt-plus id="GetDISFileList" url="mctx:vars/localXslt115"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_PrepareFileResults_Error_115"/>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_NoFiles_Info_115" store-message="none" routes-response-to="Call_Finally_NoFiles_115" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry"><cc:set name="inLogMessage" value="'No Files Found!'"/><cc:set name="inLogMessageDetail" value="'No files were found produced by the Data Initialization Service using Document Tag' #&#xD;&#xA;(props['inRetrievalDocTag'] == empty ? ' \'Data - Partial\'.' : 's \'Data - Partial\' and \'' # props['inRetrievalDocTag'] # '\'.')"/><cc:set name="inLogLevel" value="'info'"/></cc:local-out>
        <cc:local-out id="Call_Finally_NoFiles_115" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_115">
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:route id="RouteSource_106">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inDataSource'] != 'message'" route="Variable"/>
                <cc:choose-route expression="true" route="Message"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Message" routes-to="StoreMessage_106"/>
            <cc:sub-route name="Variable" routes-to="StoreVariable_106"/>
        </cc:route>
        <cc:local-out id="Call_HandleError_StoreMessage_Error_106" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Storage Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while storing data to the Integration Event.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_106" routes-to="RouteSource_106">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>if (props['inSecuredInstanceRefs'] != empty) {&#xD;
	if (props['inSecuredInstanceRefs'] instanceof java.lang.String) {&#xD;
		props['localSecuredRefs'] = props['inSecuredInstanceRefs'];&#xD;
	} else {&#xD;
		props['localSecuredRefs'] = util.listToCommaDelimString(props['inSecuredInstanceRefs']);&#xD;
	}&#xD;
}</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localSecuredRefs']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['localStoreResult106']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:async-mediation id="StoreMessage_106" routes-to="PIM_Tag_106">
            <cc:steps>
                <cc:store id="StoreContent" output="variable" output-mimetype="text/xml" output-variable="localStoreResult106" input="message" createDocumentReference="false" expiresIn="@{props['inDocumentRetentionPeriod']}" title="@{props['inOutputFilename']}"/></cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_StoreMessage_Error_106"/>
        </cc:async-mediation>
        <cc:async-mediation id="StoreVariable_106" routes-to="StoreMessage_106">
            <cc:steps>
                <cc:eval id="MoveVarToMsg">
                    <cc:expression>parts[0] = vars[props.inDataSource].source;</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_StoreVariable_Error_106"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_SoapResponse_Message_104" store-message="none" execute-when="props['inDebugMode']" routes-response-to="MoveResultsToVariable_104" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Response__' # props['inWebServiceApplication']"/>
        </cc:local-out>
        <cc:aggregator id="AggregateMessage_104" routes-to="Call_Debug_SoapResponse_Message_104" force-batch-on-last-message="false" force-batch-when="props['is.paged.get.last.page']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="message" output-mimetype="text/xml" xpath="@{props['inXpathToResultsToAggregate']}">
        <cc:header-text>@{props['inAggregatedResultsHeader']}</cc:header-text>
        <cc:footer-text>@{props['inAggregatedResultsFooter']}</cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-out id="Call_HandleError_ProcessResult_Warn_104" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'SOAP Page Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while extracing the results from the SOAP response using xpath['# props['inXpathToResultsToAggregate'] #'].  Processing of the remaining results will continue...'"/>
            <cc:set name="inLogLevel" value="'warn'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        <cc:set name="inLogTarget" value="props.inLogTarget"/></cc:local-out>
        <cc:async-mediation id="ProcessResult_Handler_104" routes-to="Call_HandleError_ProcessResult_Warn_104">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="ProcessResult_104" routes-to="AggregateMessage_104" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="ProcessResult_Handler_104"/>
        </cc:async-mediation>
        <cc:local-in id="ProcessPage_104" routes-to="ProcessResult_104">
            <cc:parameter default="props['inWebServiceApplication']" documentation="The WWS application where the operation may be found, e.g. &quot;Human_Resources&quot;." name="inWebServiceApplication" required="true" type="string"/><cc:parameter default="props['inAggregatedResultsHeader']" name="inAggregatedResultsHeader" required="true" type="string" validation="props['inAggregatedResultsHeader'] != empty"/>
            <cc:parameter default="props['inAggregatedResultsFooter']" name="inAggregatedResultsFooter" required="true" type="string" validation="props['inAggregatedResultsFooter'] != empty"/>
            <cc:parameter default="props['inXpathToResultsToAggregate']" documentation="Xpath to the elements in the response that are to be aggregated into the globalSoapResults variable." name="inXpathToResultsToAggregate" required="true" type="string"/>
            <cc:parameter default="props['inReturnResults']" documentation="How the SOAP results are returned to the caller, either on the message if the value is 'message', or in the 'globalSoapResults' variable if the value is 'variable', which is the default." name="inReturnResults" required="true" type="string"/>
            
            <cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
        </cc:local-in>
        <cc:async-mediation id="Foundation" routes-to="Call_InitializeFrameworkThenRunMain" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="SetConstantValues">
                    <cc:expression>props['globalApiVersion'] = 'v36.0';</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_StaticCodeAnalysis_109" store-message="none" execute-when="props['sskIsDebugMode']" routes-response-to="Call_StoreLogPrimary" endpoint="vm://INT006_Greenhouse_Inbound/StaticCodeAnalysis" clone-request="true" propagate-abort="false">
            <cc:set name="inStaticCodeAnalysisExemptionList" value="props['sskStaticCodeAnalysisExemptionList']"/>
            <cc:set name="inDebugMode" value="props['sskIsDebugMode']"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        </cc:local-out>
        <cc:async-mediation id="SetupThreadedLogging_143">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localParallelLog143'] = new java.util.concurrent.ConcurrentLinkedQueue();</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_StartThreadLog_Info_143" store-message="none" routes-response-to="SetupThreadedLogging_143" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Initialized Logging for Parallel Execution'"/>
            <cc:set name="inLogMessageDetail" value="'A data structure capable of capturing messages for cloud logging is being setup to support logging while executing parallel threads.  This is typically used when running parallel processing endpoints with either PagedGet where the is.paged.get.parallel parameter is true, or with use of the ParallelSubroutine component.'"/>
            <cc:set name="inLogLevel" value="'info'"/>
        </cc:local-out>
        <cc:local-in id="StartThreadLog" routes-to="Call_CreateLogEntry_StartThreadLog_Info_143" access="public" icon="icons/StartThreadLog.png"/>
        <cc:async-mediation id="LogMessage_143">
            <cc:steps>
                <cc:eval id="CreateMessage">
                    <cc:expression>m = new com.workday.custom.int006.ssk142.CloudLogMessage();</cc:expression>
                    <cc:expression>if (context.containsProperty('inLogMessage')) {m.setSummary(props.inLogMessage)};&#xD;
if (context.containsProperty('inLogMessageDetail')) {m.setDetail(props.inLogMessageDetail)};&#xD;
if (context.containsProperty('inLogReferenceId')) {m.setReferenceId(props.inLogReferenceId)};&#xD;
if (context.containsProperty('inLogLevel')) {m.setLevel(props.inLogLevel)};&#xD;
if (context.containsProperty('inExtraLocalIn')) {m.setLocalIn(props.inExtraLocalIn)};&#xD;
if (context.containsProperty('inExtraRecordNumber')) {m.setRecordNumber(props.inExtraRecordNumber)};&#xD;
if (context.containsProperty('inExtraSupportData')) {m.setSupportData(props.inExtraSupportData)};&#xD;
if (context.containsProperty('inExtraErrorCode')) {m.setErrorCode(props.inExtraErrorCode)};</cc:expression>
                    <cc:expression>props['localParallelLog143'].add(m);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="CreateLogEntryOnThread" routes-to="LogMessage_143" access="public" icon="icons/CreateLogEntryOnThread.png">
            <cc:parameter documentation="Value that will be written to the Message attribute of the Cloud Logger." name="inLogMessage" required="true" type="string"/>
            <cc:parameter documentation="Value that will be written to the Message Details attribute of the Cloud Logger." name="inLogMessageDetail" required="false" type="string"/>
            <cc:parameter documentation="Value that will be written to the Reference Id attribute of the Cloud Logger.  This is most commonly used to record the WID of the record to which this message pertains and can save the MVEL code of concatenating it into the Message Detail." name="inLogReferenceId" required="false" type="string"/>
            <cc:parameter documentation="Value that determines the Level attribute of the Cloud Logger.  Must be one of: debug, info, warn, error, fatal." name="inLogLevel" required="true" type="string" validation="['debug','info','warn','error','fatal'] contains props['inLogLevel'].trim().toLowerCase()"/>
            <cc:parameter documentation="Value written to the LocalIn Extra Column on the log.  This field is a convention of SSK and used to record the name of a Mediation related to the message, e.g. the errorComponentId causing an error to be raised." name="inExtraLocalIn" required="false"/>
            <cc:parameter documentation="Value written to the RecordNumber Extra Column on the log.  This field is a convention of SSK and used to record the position/count of a data record in a set to which this message pertains." name="inExtraRecordNumber" required="false"/>
            <cc:parameter documentation="Value written to the SupportData Extra Column on the log.  This field is a convention of SSK and used to provide open-ended advice for support.  This may constitute additional data values, or it may mean remediation advice for a particular error." name="inExtraSupportData" required="false"/>
            <cc:parameter documentation="Value written to the ErrorCode Extra Column on the log.  This field is a convention of SSK and used to provide the value of the error code when the message is logging error information.  This code may be given by the ESB, or it may be a custom code defined by the developer.  Note that this field is a String whereas Studio/ESB codes are integers, so type conversion is required." name="inExtraErrorCode" required="false"/>
        </cc:local-in>
        <cc:local-out id="Call_CreateLogEntry_LogThreadMessages_143" store-message="none" execute-when="props['inLogTarget'] == 'primary'" routes-response-to="Call_CreateSecondaryLogEntry_LogThreadMessages_143" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="props['localParallelLogMessage143'].getSummary()"/>
            <cc:set name="inLogMessageDetail" value="props['localParallelLogMessage143'].getDetail()"/>
            <cc:set name="inLogReferenceId" value="props['localParallelLogMessage143'].getReferenceId()"/>
            <cc:set name="inLogLevel" value="props['localParallelLogMessage143'].getLevel()"/>
            <cc:set name="inExtraLocalIn" value="props['localParallelLogMessage143'].getLocalIn()"/>
            <cc:set name="inExtraRecordNumber" value="props['localParallelLogMessage143'].getRecordNumber()"/>
            <cc:set name="inExtraSupportData" value="props['localParallelLogMessage143'].getSupportData()"/>
            <cc:set name="inExtraErrorCode" value="props['localParallelLogMessage143'].getErrorCode()"/>
        </cc:local-out>
        <cc:async-mediation id="RetrieveNextMessage_143" routes-to="Call_CreateLogEntry_LogThreadMessages_143">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['localParallelLogMessage143'] = props['localParallelLogIterator143'].next();</cc:expression>
                    <cc:expression>props['outIsErrorsOnThreads'] = props['outIsErrorsOnThreads'] || (['error','fatal'] contains props['localParallelLogMessage143'].getLevel().trim().toLowerCase());</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteEachMessage_143">
            <cc:loop-strategy condition="props['localParallelLogIterator143'].hasNext()" repeat-limit="200000"/>
            <cc:sub-route name="ProcessMessage" routes-to="RetrieveNextMessage_143"/>
        </cc:route>
        <cc:sync-mediation id="InitializeAndFinalize_143" routes-to="RouteEachMessage_143">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props.localParallelLogIterator143 = new com.workday.custom.int006.ssk142.ObjectIterator(props.localParallelLog143);</cc:expression>
                    <cc:expression>props['outIsErrorsOnThreads'] = false;</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localParallelLogIterator143','localParallelLogMessage143']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>props['localParallelLog143'].clear();</cc:expression>
                </cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-in id="WriteThreadLogsToCloudLog" routes-to="InitializeAndFinalize_143" access="public" icon="icons/WriteThreadLogsToCloudLog.png">
	        <cc:parameter default="'primary'" documentation="Controls whether the error message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            <cc:out-parameter documentation="A boolean value that indicates whether or not an error or fatal severity was encountered on one or more of the parallel threads.  This allows the employer of these logging SSK Components to be aware of an error/fatal entry, but not abort immediately upon first encounter and lose the rest of the logging information." name="outIsErrorsOnThreads"/>
        </cc:local-in>
        <cc:async-mediation id="Teardown_121">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localAssemblyXml','localSubAssemblyDetailMap','localSubAssemblyList','localCoreList','localExemptionList']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
                <cc:eval id="ReduceDebug">
                    <cc:expression>if (context.containsProperty('sskDebugPropertyList')) {&#xD;
	props['sskDebugPropertyList'].remove('localAssemblyXml');&#xD;
	props['sskDebugPropertyList'].remove('localSubAssemblyList');&#xD;
	props['sskDebugPropertyList'].remove('localExemptionList');&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_121" routes-to="Teardown_121"/>
        <cc:aggregator id="AggregateData_121" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="message" output-mimetype="text/xml">
        <cc:header-text>&lt;Root></cc:header-text>
        <cc:footer-text>&lt;/Root></cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-in id="Aggregate_121" routes-to="AggregateData_121">
            <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
            <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_CreateLogEntry_MissingCode_Warn_121" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'SSK Core Component Missing'"/>
            <cc:set name="inLogMessageDetail" value="'Static code analysis was unable to locate the SSK Core Component ' # &#xD;&#xA;(parts[0].xpath('.')) # '.  This may have been deleted from the integration.  See Support Data for more details.'"/>
            <cc:set name="inLogLevel" value="'warn'"/>
            <cc:set name="inExtraSupportData" value="'SSK Core Components should not be removed, even if identified as potential dead code in static analysis.  All other SSK components assume the Core Components as dependencies, and you may inadvertently break another SSK component in-use by removing a Core Component.  ' #&#xD;&#xA;'If a Core Component is being flagged in static analysis, then add the local-in id to the sskStaticCodeAnalysisExemptionList property in StaticAnalysisExemptions@Initialize_109, which can be found in the InitializeFrameworkThenRunMain SSK Component.  ' #&#xD;&#xA;'Otherwise, restore the deleted code for ' # (parts[0].xpath('.')) # ' in the ' # (props['localSubAssemblyDetailMap'].get(parts[0].xpath('.'))) # ' swimlane from a clean copy of SSK.'"/>
            <cc:set name="inExtraErrorCode" value="'12101'"/>
        </cc:local-out>
        <cc:splitter id="Splitter_MissingCode_121" no-split-message-error="false">
            <cc:sub-route name="ReportMissingCode" routes-to="Call_CreateLogEntry_MissingCode_Warn_121"/>
            <cc:xml-stream-splitter xpath="/*/*"/>
        </cc:splitter>
        <cc:local-out id="Call_Debug_Message_MissingCode_121" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Splitter_MissingCode_121" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'StaticAnalysis_MissingCode'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_MissingCode_Error_121" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Missing Code Analysis Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while performing the missing code portion of the static analysis.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_121'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['sskIsDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'StaticAnalysis_Assembly'"/>
        </cc:local-out>
        <cc:async-mediation id="MissingCode_121" routes-to="Call_Debug_Message_MissingCode_121">
            <cc:steps>
                <cc:xslt-plus id="FindDeletedCommonComponents" output-mimetype="text/xml" url="xslt/ssk121/SSK121_MissingCodeDetection.xsl"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_MissingCode_Error_121"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_Metadata_121" store-message="none" routes-response-to="MissingCode_121" endpoint="vm://INT006_Greenhouse_Inbound/Aggregate_121">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="true"/>
        </cc:local-out>
        <cc:async-mediation id="PrepareMissingCode_Metadata_121" routes-to="Call_Aggregate_Metadata_121">
            <cc:steps>
                <cc:write id="WriteMessage" output-mimetype="text/xml">
                    <cc:message>
                        <cc:text>&lt;SubAssemblies>&#xD;
	@foreach{props.localCoreList}&#xD;
	&lt;SubAssembly>@{item}&lt;/SubAssembly>&#xD;
	@end{}&#xD;
&lt;/SubAssemblies></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_Assembly_121" store-message="none" routes-response-to="PrepareMissingCode_Metadata_121" endpoint="vm://INT006_Greenhouse_Inbound/Aggregate_121">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="PrepareMissingCode_Assembly_121" routes-to="Call_Aggregate_Assembly_121">
            <cc:steps>
                <cc:write id="WriteAssemblyToMsg" output-mimetype="text/xml">
                    <cc:message>
                        <cc:static-file input-file="@{props['localAssemblyXml']}"/>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_DeadCode_Warn_121" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Potential Dead Code Detected'"/>
            <cc:set name="inLogMessageDetail" value="'Static code analysis suggests that the SSK Component defined by local-in with id=' # &#xD;&#xA;(parts[0].xstream('/*')) # ' may not be used in the integration.  See Support Data for more details.'"/>
            <cc:set name="inLogLevel" value="'warn'"/>
            <cc:set name="inExtraSupportData" value="'Static code analysis does not read dynamic endpoints, so if you have referenced this SSK Component dynamically, this may be a false-positive and you should make no code changes.  ' #&#xD;&#xA;'In this case, add your local-in id to the sskStaticCodeAnalysisExemptionList property in StaticAnalysisExemptions@Initialize_109, which can be found in the InitializeFrameworkThenRunMain SSK Component.  ' #&#xD;&#xA;'Otherwise, consider removing the SSK Component by deleting the ' # (props['localSubAssemblyDetailMap'].get(parts[0].xpath('.'))) # ' swimlane, or removing the entire parent swimlane if no other SSK Components in that group are being used.'"/>
            <cc:set name="inExtraErrorCode" value="'12100'"/>
        </cc:local-out>
        <cc:splitter id="Splitter_DeadCode_121" no-split-message-error="false">
            <cc:sub-route name="ReportDeadCode" routes-to="Call_CreateLogEntry_DeadCode_Warn_121"/>
            <cc:xml-stream-splitter xpath="/*/*"/>
        </cc:splitter>
        <cc:local-out id="Call_Debug_Message_DeadCode_121" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Splitter_DeadCode_121" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'StaticAnalysis_DeadCode'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_DeadCode_Error_121" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Dead Code Analysis Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while performing the dead code portion of the static analysis.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_121'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['sskIsDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'StaticAnalysis_Assembly'"/>
        </cc:local-out>
        <cc:async-mediation id="DeadCode_121" routes-to="Call_Debug_Message_DeadCode_121">
            <cc:steps>
                <cc:write id="WriteAssemblyToMsg" output-mimetype="text/xml">
                    <cc:message>
                        <cc:static-file input-file="@{props['localAssemblyXml']}"/>
                    </cc:message>
                </cc:write>
                <cc:xslt-plus id="FindUnusedLocalIns" output-mimetype="text/xml" url="xslt/ssk121/SSK121_DeadCodeDetection.xsl"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_DeadCode_Error_121"/>
        </cc:async-mediation>
        <cc:route id="Route_121">
            <cc:all-strategy/>
            <cc:sub-route name="DeadCode" routes-to="DeadCode_121"/>
            <cc:sub-route name="MissingCode" routes-to="PrepareMissingCode_Assembly_121"/>
            <cc:sub-route name="MissingVersion" routes-to="Call_CreateLogEntry_MissingVersion_Warn_121"/>
        </cc:route>
        <cc:local-out id="Call_Debug_PropertyList_121" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Route_121" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'properties'"/>
            <cc:set name="inTargetName" value="'sskDebugPropertyList'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Error_121" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Static Code Analysis Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing the control values to perform static analysis.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_121'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['sskIsDebugMode']"/>
            <cc:set name="inTargetType" value="'properties'"/>
            <cc:set name="inTargetName" value="'sskDebugPropertyList'"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_121" routes-to="Call_Debug_PropertyList_121" handle-downstream-errors="true" routes-response-to="Call_Finally_121">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localAssemblyXml'] = 'assembly.xml';</cc:expression>
                    <cc:expression>props['localSubAssemblyDetailMap'] = new java.util.HashMap();</cc:expression>
                    <cc:expression>props['localSubAssemblyDetailMap'].put('Main','int006 Greenhouse Inbound > Integration Code > Begin Integration Work');&#xD;
props['localSubAssemblyDetailMap'].put('InitializeFrameworkThenRunMain','Studio StarterKit Library > CORE COMPONENTS > 109 - Initialization');&#xD;
props['localSubAssemblyDetailMap'].put('HandleError','Studio StarterKit Library > CORE COMPONENTS > 141 - Error Handling');&#xD;
props['localSubAssemblyDetailMap'].put('CreateLogEntry','Studio StarterKit Library > CORE COMPONENTS > 142 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('CreateSecondaryLogEntry','Studio StarterKit Library > CORE COMPONENTS > 142 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('StoreLogPrimary','Studio StarterKit Library > CORE COMPONENTS > 142 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('StoreLogSecondary','Studio StarterKit Library > CORE COMPONENTS > 142 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('LogStatsPrimary','Studio StarterKit Library > CORE COMPONENTS > 142 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('LogStatsSecondary','Studio StarterKit Library > CORE COMPONENTS > 142 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('StartThreadLog','Studio StarterKit Library > CORE COMPONENTS > 143 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('CreateLogEntryOnThread','Studio StarterKit Library > CORE COMPONENTS > 143 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('WriteThreadLogsToCloudLog','Studio StarterKit Library > CORE COMPONENTS > 143 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('Debug','Studio StarterKit Library > CORE COMPONENTS > 144 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('CloudLogXSLTMessages','Studio StarterKit Library > CORE COMPONENTS > 112 - XSLT / ETV / XTT Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('CloudLogETVXTTMessages','Studio StarterKit Library > CORE COMPONENTS > 112 - XSLT / ETV / XTT Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('IntegrationEventProgress','Studio StarterKit Library > CORE COMPONENTS > 108 - Integration Event Progress Update');&#xD;
props['localSubAssemblyDetailMap'].put('StaticCodeAnalysis','Studio StarterKit Library > CORE COMPONENTS > 121 - Static Code Analysis');&#xD;
props['localSubAssemblyDetailMap'].put('AddReportPromptFromProperty','Studio StarterKit Library > REPORTS AS A SERVICE > 101 - Build Reports-as-a-Service Report Prompts');&#xD;
props['localSubAssemblyDetailMap'].put('AddReportPromptFromXml','Studio StarterKit Library > REPORTS AS A SERVICE > 101 - Build Reports-as-a-Service Report Prompts');&#xD;
props['localSubAssemblyDetailMap'].put('CallRaaS','Studio StarterKit Library > REPORTS AS A SERVICE > 102 - Reports-as-a-Service Execution');&#xD;
props['localSubAssemblyDetailMap'].put('CallSoap','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 103 - Workday Web Service (SOAP) Execution');&#xD;
props['localSubAssemblyDetailMap'].put('CallSoapPaged','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 104 - Workday Web Service (SOAP) Paged Execution');&#xD;
props['localSubAssemblyDetailMap'].put('CallSoapImport','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 113 - Workday Web Service (SOAP) Import APIs (Process)');&#xD;
props['localSubAssemblyDetailMap'].put('FinalizeCallSoapImport','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 113 - Workday Web Service (SOAP) Import APIs (Process)');&#xD;
props['localSubAssemblyDetailMap'].put('ReportResultsOfCallSoapImport','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 118 - Workday Web Service (SOAP) Import APIs (Post-Process)');&#xD;
props['localSubAssemblyDetailMap'].put('CreateQueue','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 122 - Workday Message Queue - Create Queue');&#xD;
props['localSubAssemblyDetailMap'].put('GetQueues','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 123 - Workday Message Queue - Get Queues');&#xD;
props['localSubAssemblyDetailMap'].put('PollQueue','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 124 - Workday Message Queue - Poll Queue');&#xD;
props['localSubAssemblyDetailMap'].put('ReadMessageFromQueue','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 125 - Workday Message Queue - Read Message');&#xD;
props['localSubAssemblyDetailMap'].put('AddMessageToQueue','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 126 - Workday Message Queue - Write Message');&#xD;
props['localSubAssemblyDetailMap'].put('DeleteMessageFromQueue','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 127 - Workday Message Queue - Delete Message');&#xD;
props['localSubAssemblyDetailMap'].put('PurgeQueue','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 128 - Workday Message Queue - Purge Queue');&#xD;
props['localSubAssemblyDetailMap'].put('GenerateOutput','Studio StarterKit Library > FILE UTILITIES > 106 - Output Generation');&#xD;
props['localSubAssemblyDetailMap'].put('GetDocumentList','Studio StarterKit Library > FILE UTILITIES > 110 - Get Document List');&#xD;
props['localSubAssemblyDetailMap'].put('LoadFile','Studio StarterKit Library > FILE UTILITIES > 111 - Load File');&#xD;
props['localSubAssemblyDetailMap'].put('GetDISResults','Studio StarterKit Library > FILE UTILITIES > 115 - Data Initialization Service');&#xD;
props['localSubAssemblyDetailMap'].put('PopulateJavaMap','Studio StarterKit Library > XSLT 3.0 > 105 - Populate Java Map');&#xD;
props['localSubAssemblyDetailMap'].put('StreamDataMerge','Studio StarterKit Library > XSLT 3.0 > 107 - Streaming Data Merge');&#xD;
props['localSubAssemblyDetailMap'].put('BlockSplitter','Studio StarterKit Library > XSLT 3.0 > 116 - XML Block Splitting');&#xD;
props['localSubAssemblyDetailMap'].put('XsltPlus','Studio StarterKit Library > XSLT 3.0 > 129 - XSLT Transform');</cc:expression>
                    <cc:expression>props['localSubAssemblyList'] = new java.util.ArrayList();&#xD;
props['localCoreList'] = new java.util.ArrayList();</cc:expression>
                    <cc:expression>foreach (key : props['localSubAssemblyDetailMap'].keySet()) {&#xD;
	if (org.apache.commons.lang3.StringUtils.contains(props['localSubAssemblyDetailMap'].get(key), 'CORE COMPONENTS')) {&#xD;
		props['localCoreList'].add(key);&#xD;
	}&#xD;
	props['localSubAssemblyList'].add(key);&#xD;
}&#xD;
props['localSubAssemblyList'] = util.listToCommaDelimString(props['localSubAssemblyList']);</cc:expression>
                    <cc:expression>if (props['inStaticCodeAnalysisExemptionList'] == empty) {&#xD;
	props['inStaticCodeAnalysisExemptionList'] = new java.util.ArrayList();&#xD;
}</cc:expression>
                    <cc:expression>if (props['inStaticCodeAnalysisExemptionList'] == empty) {&#xD;
	props['localExemptionList'] = '';&#xD;
} else {&#xD;
	props['localExemptionList'] = util.listToCommaDelimString(props['inStaticCodeAnalysisExemptionList']);&#xD;
}</cc:expression>
                </cc:eval>
                <cc:eval id="UpdateDebug">
                    <cc:expression>if (context.containsProperty('sskDebugPropertyList')) {&#xD;
	props['sskDebugPropertyList'].add('localAssemblyXml');&#xD;
	props['sskDebugPropertyList'].add('localSubAssemblyList');&#xD;
	props['sskDebugPropertyList'].add('localExemptionList');&#xD;
}</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Error_121"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_121" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_121"/>
        <cc:local-in id="StaticCodeAnalysis" routes-to="InitializeAndFinalize_121" icon="icons/DeadCodeDetection.png">
            <cc:parameter default="props['sskStaticCodeAnalysisExemptionList']" documentation="A list of SSK Components to exclude from warning generation in the static code analysis because of use by dynamic endpoints not read by the validation code." name="inStaticCodeAnalysisExemptionList" required="false"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="false" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
        </cc:local-in>
        <cc:async-mediation id="Teardown_118">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsImportRequests','localIsDoNotMatch','localProcessWID','localNodeName','localIsC2PData','localEffectiveAsOf','localEntryAsOf']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['c2pAggregatedResult118','localOriginalRequests118','localPreTransformData118','localXslt118']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
                <cc:eval id="ReduceDebug">
                    <cc:expression>if (context.containsProperty('sskDebugPropertyList')) {&#xD;
	props['sskDebugPropertyList'].remove('localIsImportRequests');&#xD;
	props['sskDebugPropertyList'].remove('localIsDoNotMatch');&#xD;
	props['sskDebugPropertyList'].remove('localProcessWID');&#xD;
	props['sskDebugPropertyList'].remove('localNodeName');&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_118" routes-to="Teardown_118"/>
        <cc:aggregator id="AggregateData_118" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="variable" output-mimetype="text/xml" output-variable="localPreTransformData118">
        <cc:header-text>&lt;Results></cc:header-text>
        <cc:footer-text>&lt;/Results></cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-in id="Aggregate_118" routes-to="AggregateData_118">
            <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
            <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_Debug_Variable_MergedData_118" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'localPreTransformData118'"/>
        </cc:local-out>
        <cc:local-out id="Call_Aggregate_PayloadData_118" store-message="none" routes-response-to="Call_Debug_Variable_MergedData_118" endpoint="vm://INT006_Greenhouse_Inbound/Aggregate_118">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="true"/>
        </cc:local-out>
        <cc:async-mediation id="PrepareImportRequests_118" routes-to="Call_Aggregate_PayloadData_118">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="localOriginalRequests118"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_EnrichmentData_118" store-message="none" routes-response-to="PrepareImportRequests_118" endpoint="vm://INT006_Greenhouse_Inbound/Aggregate_118">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="PrepareImportProcessMessages_118" routes-to="Call_Aggregate_EnrichmentData_118">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="c2pAggregatedResult118"/>
                <cc:eval id="ReleaseResource">
                    <cc:expression>vars['c2pAggregatedResult118'] = null;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="MergeRequestsWithResponses_118" routes-to="PrepareImportProcessMessages_118">
            
            
        </cc:local-in>
        <cc:local-out id="Call_HandleError_AbortOnChildThreadError_118" store-message="none" execute-when="props['outIsErrorsOnThreads']" routes-response-to="MakeVariableNullSafe_118" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Errors Encountered During Parallel Processing'"/>
            <cc:set name="inLogMessageDetail" value="'Errors were encountered on child threads.  Therefore, a complete data set cannot be guaranteed and continued processing cannot be trusted to be accurate.  The integration will be terminated due to issues encountered processing and aggregating the PagedGet results.'"/>
            <cc:set name="inLogReferenceId" value="''"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="'Call_HandleError_AbortOnChildThreadError_118'"/>
            <cc:set name="inExtraRecordNumber" value="''"/>
            <cc:set name="inExtraSupportData" value="''"/>
            <cc:set name="inExtraErrorCode" value="'11808'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_WriteThreadLogsToCloudLog_118" store-message="none" routes-response-to="Call_HandleError_AbortOnChildThreadError_118" endpoint="vm://INT006_Greenhouse_Inbound/WriteThreadLogsToCloudLog"/>
        <cc:local-in id="FinalizeReturnFromThread_118" routes-to="Call_WriteThreadLogsToCloudLog_118"/>
        <cc:aggregator id="AggregateParallelData_118" collate-when="props['aggregator.destination.force.collate'] &amp;&amp; props['localIsC2PData']" force-batch-on-last-message="false" force-batch-when="props['aggregator.destination.force.batch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="variable" output-mimetype="text/xml" output-variable="c2pAggregatedResult118" xpath="/SoapResults/*">
        <cc:header-text>&lt;wd:Import_Process_Messages xmlns:wd=&quot;urn:com.workday/bsvc&quot;></cc:header-text>
        <cc:footer-text>&lt;/wd:Import_Process_Messages></cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-out id="Call_CreateLogEntryOnThread_CrossThreadTransfer_118" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'SOAP Page Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while extracing the results from the SOAP response using xpath[/env:Envelope/env:Body/wd:Get_Import_Process_Messages_Response/wd:Response_Data/wd:Import_Process_Message].  Processing of the remaining results will continue...'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="''"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
        </cc:local-out>
        <cc:async-mediation id="CrossThreadChildToChild_118" routes-to="AggregateParallelData_118" continue-after-error="rewind" execute-steps-when="props['aggregator.destination.force.collate'] &amp;&amp; props['localIsC2PData']" handle-downstream-errors="true">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="c2pPageToAggregate118"/>
                <cc:eval id="ReleaseResource">
                    <cc:expression>vars['c2pPageToAggregate118'] = null /* Remove the variable now that we've finished with it */</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_CreateLogEntryOnThread_CrossThreadTransfer_118"/>
        </cc:async-mediation>
        <cc:async-mediation id="ValidateChildReturnData_118" routes-to="CrossThreadChildToChild_118">
            <cc:steps>
                <cc:eval id="TestForData">
                    <cc:expression>props['localIsC2PData'] = ((vars['c2pPageToAggregate118'] != null) &amp;&amp; (vars['c2pPageToAggregate118'].xstreamB('/SoapResults/*')));</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="AggregateParallel_118" routes-to="ValidateChildReturnData_118">
            
            
            
            
        </cc:local-in>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_118" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'SOAP Page Processed'"/>
            <cc:set name="inLogMessageDetail" value="'A page of SOAP results was processed'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraLocalIn" value="''"/>
            <cc:set name="inExtraRecordNumber" value="parts[0].xstream('/env:Envelope/env:Body/*/wd:Response_Results/wd:Page')"/>
            <cc:set name="inExtraSupportData" value="util.cleanString(com.workday.custom.int006.ssk144.DebugBean.getDataFragmentOfDefaultSize(context, 'c2pPageToAggregate118'));"/>
            <cc:set name="inExtraErrorCode" value="''"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntryOnThread_Warn_118" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'SOAP Page Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while extracing the results from the SOAP response using xpath[/env:Envelope/env:Body/wd:Get_Import_Process_Messages_Response/wd:Response_Data/wd:Import_Process_Message].  Processing of the remaining results will continue...'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="''"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
        </cc:local-out>
        <cc:async-mediation id="CrossThreadParentToChild_118" routes-to="Call_CreateLogEntryOnThread_Debug_118" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
                <cc:xslt-plus id="XsltPlus" output="variable" output-mimetype="text/xml" output-variable="c2pPageToAggregate118" url="xslt/ssk118/Get_Import_Process_Messages_Response.xsl"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_CreateLogEntryOnThread_Warn_118"/>
        </cc:async-mediation>
        <cc:local-in id="ProcessPageParallel_118" routes-to="CrossThreadParentToChild_118">
            
        </cc:local-in>
        <cc:local-out id="CallSoapPagedGet_118" store-message="none" endpoint="vm://wcc/PagedGet">
            <cc:set name="is.paged.get.request.current.page.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Filter/wd:Page'"/>
            <cc:set name="is.paged.get.response.current.page.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Page'"/>
            <cc:set name="is.paged.get.response.total.pages.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Pages'"/>
            <cc:set name="is.paged.get.response.total.results.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Results'"/>
            <cc:set name="is.paged.get.process.endpoint" value="'vm://INT006_Greenhouse_Inbound/ProcessPageParallel_118'"/>
            <cc:set name="is.paged.get.application" value="'Integrations'"/>
            <cc:set name="is.paged.get.version" value="props['inApiVersion']"/>
            <cc:set name="is.paged.get.page.zero" value="false"/>
            <cc:set name="is.paged.get.store.requests" value="true"/>
            <cc:set name="is.paged.get.parallel" value="true"/>
            <cc:set name="is.paged.get.parallel.aggregation.endpoint" value="'vm://INT006_Greenhouse_Inbound/AggregateParallel_118'"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_GetImportProcessMessagesRequest_118" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallSoapPagedGet_118" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Request__Get_Import_Process_Messages'"/>
        </cc:local-out>
        <cc:local-out id="Call_InitializeThreadedLogging_118" store-message="none" routes-response-to="Call_Debug_GetImportProcessMessagesRequest_118" endpoint="vm://INT006_Greenhouse_Inbound/StartThreadLog"/>
        <cc:local-out id="Call_HandleError_SoapPagedGet_Error_118" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'SOAP Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error was encountered initiating the PagedGet call for Import Process Messages.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="true"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP_Request__Get_Import_Process_Messages'"/>
        </cc:local-out>
        <cc:sync-mediation id="GetImportProcessMessages_InitializeAndFinalize_118" routes-to="Call_InitializeThreadedLogging_118" routes-response-to="Call_FinalizeReturnFromThread_118">
            <cc:request-steps>
                <cc:eval id="PagedGetWebQueryCacheParams">
                    <cc:expression>currentTimestamp = com.workday.custom.int006.DateUtils.now();&#xD;
&#xD;
props['localEffectiveAsOf'] = com.workday.custom.int006.DateUtils.convertDateToXmlString(currentTimestamp);&#xD;
props['localEntryAsOf'] = com.workday.custom.int006.DateUtils.convertDateTimeToXmlString(currentTimestamp);</cc:expression>
                </cc:eval>
                <cc:write id="WriteSoapRequest">
                    <cc:message>
                        <cc:text>&lt;soapenv:Envelope xmlns:wd=&quot;urn:com.workday/bsvc&quot; xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;>&#xD;
    &lt;soapenv:Header>&#xD;
        &lt;wd:Workday_Common_Header>&lt;wd:Include_Reference_Descriptors_In_Response>true&lt;/wd:Include_Reference_Descriptors_In_Response>&lt;/wd:Workday_Common_Header>&#xD;
    &lt;/soapenv:Header>&#xD;
    &lt;soapenv:Body>&#xD;
        &lt;wd:Get_Import_Process_Messages_Request wd:version=&quot;@{props['inApiVersion']}&quot;>&#xD;
            &lt;wd:Request_Criteria>&#xD;
                &lt;wd:Import_Process_Reference>&#xD;
                    &lt;wd:ID wd:type=&quot;WID&quot;>@{props['inProcessWID']}&lt;/wd:ID>&#xD;
                &lt;/wd:Import_Process_Reference>&#xD;
            &lt;/wd:Request_Criteria>&#xD;
            &lt;wd:Response_Filter>&#xD;
            	&lt;wd:As_Of_Effective_Date>@{props['localEffectiveAsOf']}&lt;/wd:As_Of_Effective_Date>&#xD;
            	&lt;wd:As_Of_Entry_DateTime>@{props['localEntryAsOf']}&lt;/wd:As_Of_Entry_DateTime>&#xD;
                &lt;wd:Page>1&lt;/wd:Page>&#xD;
                &lt;wd:Count>999&lt;/wd:Count>&#xD;
            &lt;/wd:Response_Filter>&#xD;
        &lt;/wd:Get_Import_Process_Messages_Request>&#xD;
    &lt;/soapenv:Body>&#xD;
&lt;/soapenv:Envelope></cc:text>
                    </cc:message>
                </cc:write>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_SoapPagedGet_Error_118"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_FinalizeReturnFromThread_118" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/FinalizeReturnFromThread_118"/>
        <cc:local-in id="GetImportProcessMessages_118" routes-to="GetImportProcessMessages_InitializeAndFinalize_118">
            <cc:parameter default="props['inApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter default="props['inProcessWID']" documentation="The WID of the background process for which messages are being requested." name="inProcessWID" required="true" type="string"/>
        </cc:local-in>
        <cc:local-out id="Call_CreateLogEntry_ResponseMessage_Dynamic_118" store-message="none" endpoint="@{(props.inLogTarget == 'secondary') ? 'vm://INT006_Greenhouse_Inbound/CreateSecondaryLogEntry' : 'vm://INT006_Greenhouse_Inbound/CreateLogEntry'}">
            <cc:set name="inLogMessage" value="'Issue with Import WWS Data'"/>
            <cc:set name="inLogMessageDetail" value="parts[0].xstream('/*/*/wd:Message_Summary')"/>
            <cc:set name="inLogReferenceId" value="props['inProcessWID']"/>
            <cc:set name="inLogLevel" value="parts[0].xstream('/*/*/wd:Severity')"/>
            <cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_ResponseMessage_Dynamic_118'"/>
            <cc:set name="inExtraRecordNumber" value="parts[0].xstream('/*/*/wd:Line_Number')"/>
            <cc:set name="inExtraSupportData" value="'The Reference Id contains the WID of the background process executing the import.  The timestamp of the error reported by the tenant is ' # (parts[0].xstream('/*/*/wd:Timestamp')) # '.'"/>
            <cc:set name="inExtraErrorCode" value="'11803'"/>
        </cc:local-out>
        <cc:splitter id="ResponseMessageSplitter_118" no-split-message-error="false">
            <cc:sub-route name="ProcessMessage" routes-to="Call_CreateLogEntry_ResponseMessage_Dynamic_118"/>
            <cc:xml-stream-splitter xpath="/*/*"/>
        </cc:splitter>
        <cc:local-out id="Call_HandleError_SimpleTransform_Error_118" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'XSLT Transform Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred executing the transformation of message data.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="PrepareResponseMessages_118" routes-to="ResponseMessageSplitter_118" handle-downstream-errors="true">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="c2pAggregatedResult118"/>
                <cc:eval id="ReleaseResource">
                    <cc:expression>vars['c2pAggregatedResult118'] = null;</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_SimpleTransform_Error_118"/>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_DetailedMessage_Dynamic_118" store-message="none" endpoint="@{(props.inLogTarget == 'secondary') ? 'vm://INT006_Greenhouse_Inbound/CreateSecondaryLogEntry' : 'vm://INT006_Greenhouse_Inbound/CreateLogEntry'}">
            <cc:set name="inLogMessage" value="'Issue with Import WWS Data'"/>
            <cc:set name="inLogMessageDetail" value="parts[0].xstream('/*/wd:Message_Summary')"/>
            <cc:set name="inLogReferenceId" value="props['inProcessWID']"/>
            <cc:set name="inLogLevel" value="parts[0].xstream('/*/wd:Severity')"/>
            <cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_DetailedMessage_Dynamic_118'"/>
            <cc:set name="inExtraRecordNumber" value="parts[0].xstream('/*/wd:Line_Number')"/>
            <cc:set name="inExtraSupportData" value="'The Reference Id contains the WID of the background process executing the import.  The timestamp of the error reported by the tenant is ' # (parts[0].xstream('/*/wd:Timestamp')) # '.  The original import request data was: ' # (org.apache.commons.lang3.StringUtils.normalizeSpace(parts[0].xstreamF('/*/wd:Request_Data')))"/>
            <cc:set name="inExtraErrorCode" value="'11802'"/>
        </cc:local-out>
        <cc:splitter id="DetailedMessageSplitter_118" no-split-message-error="false">
            <cc:sub-route name="ProcessMessage" routes-to="Call_CreateLogEntry_DetailedMessage_Dynamic_118"/>
            <cc:xml-stream-splitter xpath="/*/*"/>
        </cc:splitter>
        <cc:local-out id="Call_HandleError_DetailedTransform_Error_118" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'XSLT Transform Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred executing the payload transformation using enrichment data.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="PrepareDetailedMessages_118" routes-to="DetailedMessageSplitter_118" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localHref'] = context.baseURL # 'xslt/ssk118/' # props.localNodeName # '.xsl';</cc:expression>
                </cc:eval>
                <cc:write id="LoadXslt" output="variable" output-variable="localXslt118">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;xsl:stylesheet &#xD;
    xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&#xD;
    xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&#xD;
    xmlns:wd=&quot;urn:com.workday/bsvc&quot;&#xD;
    exclude-result-prefixes=&quot;xsd&quot;&#xD;
    version=&quot;3.0&quot;>&#xD;
    &#xD;
    &lt;xsl:mode streamable=&quot;yes&quot; on-no-match=&quot;shallow-skip&quot;/>&#xD;
    &lt;xsl:mode name=&quot;in-memory&quot; streamable=&quot;no&quot; on-no-match=&quot;shallow-skip&quot;/> &#xD;
    &lt;xsl:output method=&quot;xml&quot; indent=&quot;no&quot; encoding=&quot;UTF-8&quot;/>&#xD;
    &#xD;
    &lt;xsl:key name=&quot;lookupKey&quot; match=&quot;wd:Import_Process_Messages/wd:Import_Process_Message&quot; use=&quot;wd:Import_Process_Message_Data/wd:Line_Number&quot;/>&#xD;
&#xD;
    &lt;xsl:template match=&quot;Results&quot;>&#xD;
        &lt;xsl:iterate select=&quot;*&quot;>&#xD;
            &lt;xsl:param name=&quot;lookup&quot; as=&quot;item()?&quot;/>&#xD;
            &#xD;
            &lt;xsl:choose>&#xD;
                &lt;xsl:when test=&quot;exists($lookup)&quot;>&#xD;
                    &lt;xsl:apply-templates select=&quot;.&quot;>&#xD;
                        &lt;xsl:with-param name=&quot;lookup&quot; select=&quot;$lookup&quot;/>&#xD;
                    &lt;/xsl:apply-templates>&#xD;
                    &#xD;
                    &lt;xsl:next-iteration>&#xD;
                        &lt;xsl:with-param name=&quot;lookup&quot; select=&quot;$lookup&quot;/>&#xD;
                    &lt;/xsl:next-iteration>&#xD;
                &lt;/xsl:when>&#xD;
                &lt;xsl:otherwise>&#xD;
                    &lt;xsl:next-iteration>&#xD;
                        &lt;xsl:with-param name=&quot;lookup&quot; select=&quot;snapshot()&quot;/>&#xD;
                    &lt;/xsl:next-iteration>&#xD;
                &lt;/xsl:otherwise>&#xD;
            &lt;/xsl:choose>&#xD;
        &lt;/xsl:iterate>        &#xD;
    &lt;/xsl:template>&#xD;
    &#xD;
    &lt;xsl:include href=&quot;@{props.localHref}&quot;/>    &#xD;
    &#xD;
&lt;/xsl:stylesheet>&#xD;
</cc:text>
                    </cc:message>
                </cc:write>
                <cc:xslt-plus id="TranformToMessages" output-mimetype="text/xml" input="variable" input-variable="localPreTransformData118" url="mctx:vars/localXslt118"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_DetailedTransform_Error_118"/>
        </cc:async-mediation>
        <cc:local-out id="Call_MergeRequestsWithResponses_118" store-message="none" routes-response-to="PrepareDetailedMessages_118" endpoint="vm://INT006_Greenhouse_Inbound/MergeRequestsWithResponses_118">
            
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_PrepareDynamicXPath_Error_118" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'XSLT Transform Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred executing the payload transformation using enrichment data.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="PrepareDynamicXPath_118" routes-to="Call_MergeRequestsWithResponses_118" handle-downstream-errors="true">
            <cc:steps>
                <cc:xslt-plus id="GetRootElement" output-mimetype="text/plain" input="variable" input-variable="localOriginalRequests118" url="xslt/ssk118/Get_Root_Element_Name.xsl"/>
                <cc:eval id="InitValues">
                    <cc:expression>props['localNodeName'] = parts[0].text;&#xD;
&#xD;
//Note: The use of message.rootPartAsText is generally and categorically discouraged if not forbidden in production-grade code and use in MVEL.  &#xD;
//The reasoning supporting such restriction is that the message or variable content cannot be absolutely assured to be of manageable size, and when circumstances result in a larger-than-expected payload, the getText() methods result in excessively large strings resulting in very poor memory utilization and garbage collection performance with very adverse effects on the integration performance.&#xD;
&#xD;
//In this use case scenario, rootPartAsText may be used with complete confidence as we know definitively that the message will only contain a single string of nominal length based on the operation performed in the preceding step.&#xD;
//It is only with this absolute clarity and guarantee that we are using rootPartAsText.  Use of message.rootPartAsText, parts[0].text, or vars['variableName'].text is still STRONGLY discouraged in production code.&#xD;
</cc:expression>
                </cc:eval>
                <cc:eval id="UpdateDebug">
                    <cc:expression>if (context.containsProperty('sskDebugPropertyList')) {&#xD;
	props['sskDebugPropertyList'].add('localNodeName');&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_PrepareDynamicXPath_Error_118"/>
        </cc:async-mediation>
        <cc:route id="RouteLogChoice_118">
            <cc:mvel-strategy>
                <cc:choose-route expression="!props['inIsDoNotMatch']" route="LinkToRequest"/>
                <cc:choose-route expression="true" route="MessageOnly"/>
            </cc:mvel-strategy>
            <cc:sub-route name="LinkToRequest" routes-to="PrepareDynamicXPath_118"/>
            <cc:sub-route name="MessageOnly" routes-to="PrepareResponseMessages_118"/>
        </cc:route>
        <cc:local-out id="Call_GetImportProcessMessages_118" store-message="none" routes-response-to="RouteLogChoice_118" endpoint="vm://INT006_Greenhouse_Inbound/GetImportProcessMessages_118">
            <cc:set name="inApiVersion" value="props['inApiVersion']"/>
            <cc:set name="inProcessWID" value="props['inProcessWID']"/>
        </cc:local-out>
        <cc:local-in id="ProcessRequest_118" routes-to="Call_GetImportProcessMessages_118">
            <cc:parameter default="props['inApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter default="props['localProcessWID']" documentation="The WID of the background process for which messages are being requested." name="inProcessWID" required="true" type="string"/>
            <cc:parameter default="props['localIsDoNotMatch']" documentation="Indicates if the request file from the Studio pre-processor expresses suppression of data/message matching for logging." name="inIsDoNotMatch" type="boolean"/>
            <cc:parameter default="props['sskIsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_ProcessRequest_118" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/ProcessRequest_118" propagate-abort="false">
            <cc:set name="inApiVersion" value="props['inApiVersion']"/>
            <cc:set name="inProcessWID" value="props['localProcessWID']"/>
            <cc:set name="inIsDoNotMatch" value="props['localIsDoNotMatch']"/>
            <cc:set name="inDebugMode" value="props['inDebugMode']"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_Properties_118" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_ProcessRequest_118" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'properties'"/>
            <cc:set name="inTargetName" value="'sskDebugPropertyList'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_LoggingDetail_Error_118" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Error Parsing Archive File'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while parsing the file from the archive to determine how to log Import Process Messages.'"/>
            <cc:set name="inLogReferenceId" value="props['inImportIntegrationEventWID']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="LoggingDetail_118" routes-to="Call_Debug_Properties_118" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localIsDoNotMatch'] = Boolean.valueOf(parts[0].xstreamB('/DoNotMessageMatch'));</cc:expression>
                    <cc:expression>props['localProcessWID'] = org.apache.commons.lang3.StringUtils.removeEnd(util.currentFilename, '.xml');</cc:expression>
                </cc:eval>
                <cc:eval id="UpdateDebug">
                    <cc:expression>if (context.containsProperty('sskDebugPropertyList')) {&#xD;
	props['sskDebugPropertyList'].add('localIsDoNotMatch');&#xD;
	props['sskDebugPropertyList'].add('localProcessWID');&#xD;
}</cc:expression>
                </cc:eval>
                <cc:validate-exp id="Validate">
                    <cc:expression error-number="11804" failure-message="The background process WID could not determined from the filename within the ImportRequests.zip archive.  The value is empty, and therefore, retrieving process messages is not possible.">props['localProcessWID'] != empty</cc:expression>
                </cc:validate-exp>
                <cc:copy id="CopyMsgToVar" output="variable" output-mimetype="text/xml" output-variable="localOriginalRequests118"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_LoggingDetail_Error_118"/>
        </cc:async-mediation>
        <cc:splitter id="ImportRequestsSplitter_118">
            <cc:sub-route name="ProcessRequest" routes-to="LoggingDetail_118"/>
            <cc:unzip-splitter format="zip"/>
        </cc:splitter>
        <cc:local-out id="Call_CreateLogEntry_EmptyFile_Warn_118" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'No Import Processes Found Within File'"/>
            <cc:set name="inLogMessageDetail" value="'The ImportRequests.zip file was found; however, it did not contain any files identifying the background process WIDs.'"/>
            <cc:set name="inLogReferenceId" value="props['inImportIntegrationEventWID']"/>
            <cc:set name="inLogLevel" value="'warn'"/>
            <cc:set name="inExtraLocalIn" value="'ImportRequestsSplitter_118'"/>
            <cc:set name="inExtraSupportData" value="'ImportRequests.zip was found on the Integration Event, but was empty.  See the Reference Id for the WID of that event.'"/>
            <cc:set name="inExtraErrorCode" value="'11801'"/>
        </cc:local-out>
        <cc:async-mediation id="ImportRequestsSplitter_Catch_118" routes-to="ImportRequestsSplitter_118" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="Call_CreateLogEntry_EmptyFile_Warn_118"/>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_NoImports_Warn_118" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'No Import Process File Found'"/>
            <cc:set name="inLogMessageDetail" value="'The ImportRequests.zip file was not found; therefore, the background process WIDs are unknown and status cannot be queried.'"/>
            <cc:set name="inLogReferenceId" value="props['inImportIntegrationEventWID']"/>
            <cc:set name="inLogLevel" value="props['inLogLevelForNoImportProcessesFound']"/>
            <cc:set name="inExtraLocalIn" value="'DocumentAccessor_118'"/>
            <cc:set name="inExtraSupportData" value="'ImportRequests.zip was not found on Integration Event.  See the Reference Id for the WID of that event.'"/>
            <cc:set name="inExtraErrorCode" value="'11800'"/>
        </cc:local-out>
        <cc:route id="RouteResults_118">
            <cc:mvel-strategy>
                <cc:choose-route expression="!props['localIsImportRequests']" route="NoImports"/>
                <cc:choose-route expression="true" route="HasImports"/>
            </cc:mvel-strategy>
            <cc:sub-route name="NoImports" routes-to="Call_CreateLogEntry_NoImports_Warn_118"/>
            <cc:sub-route name="HasImports" routes-to="ImportRequestsSplitter_Catch_118"/>
        </cc:route>
        <cc:local-out id="Call_HandleError_DocumentAccessor_Error_118" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'GetEventDocuments Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while parsing the Get_Event_Documents response.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="DocumentAccessor_118" routes-to="RouteResults_118" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['localIsImportRequests'] = da.hasFile(props.inRequestFilename)</cc:expression>
                    <cc:expression>if (props['localIsImportRequests']) {&#xD;
	parts[0] = da.getData(props.inRequestFilename);&#xD;
}</cc:expression>
                </cc:eval>
                <cc:eval id="UpdateDebug">
                    <cc:expression>if (context.containsProperty('sskDebugPropertyList')) {&#xD;
	props['sskDebugPropertyList'].add('localIsImportRequests');&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_DocumentAccessor_Error_118"/>
        </cc:async-mediation>
        <cc:local-out id="GetEventDocuments_118" store-message="none" routes-response-to="DocumentAccessor_118" endpoint="vm://wcc/GetEventDocuments">
            <cc:set name="ie.event.wid" value="props['inImportIntegrationEventWID']"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_GetEventDocs_Error_118" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'GetEventDocuments Execution Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while calling Get_Event_Documents.'"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_118" routes-to="GetEventDocuments_118" handle-downstream-errors="true" routes-response-to="Call_Finally_Report_118">
            <cc:request-steps/>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_GetEventDocs_Error_118"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_Report_118" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_118"/>
        <cc:local-in id="ReportResultsOfCallSoapImport" routes-to="InitializeAndFinalize_118" access="public" icon="icons/ReportResultsOfCallSoapImport.png">
            <cc:parameter default="props['globalApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter default="props['sskIsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="context.containsProperty('sskDebugWID') ? props['sskDebugWID'] : props['sskEventWID']" documentation="The WID of the Integration Event that initiated the Import WWS call and from which we need to retrieve information to know what background processes to query for status.  If not provided, the post processor is assumed to be linked to the Import WWS initiating system by way of the Integration BP and the current WID is defaulted." name="inImportIntegrationEventWID" required="true" type="string"/>
            <cc:parameter default="'ImportRequests.zip'" documentation="The filename of the zip archive produced by the pre-processor that initiated the requests.  Presumably, if initiated with SSK and SA-113, then this should be ImportRequests.zip, which is the default." name="inRequestFilename" required="true" type="string"/>
        	<cc:parameter default="'primary'" documentation="Controls whether the message is logged to the primary or secondary logs.  Sub-assembly processing and validation messages will still go to the primary log, but data-level messages will be directed per this configuration.  Note that the Extra Column configuration of the default secondary log is still coded and therefore assumed." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
        	<cc:parameter default="'warn'" documentation="The Cloud Log entry level for the message that indicates there were no import requests identified by the previous integration event for this component to follow-up on.  Depending on customer requirements, this may be expected and OK, or may be considered an error condition.  Set the log level appropriately to influence the integration event status." name="inLogLevelForNoImportProcessesFound" required="true" type="string" validation="['info', 'warn', 'error'] contains props['inLogLevelForNoImportProcessesFound'].trim().toLowerCase()"/>
        </cc:local-in>
        <cc:async-mediation id="Teardown_113">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsValuedProperty','localIsDefinedProperty','localIsCorrectTypeProperty','localIsNonEmptyMapProperty','localIsValuedVariable','localIsDefinedVariable','localIsCorrectTypeVariable','localIsNonEmptyMapVariable']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['localRequestCache113','localImportRequestArchive113']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_113" routes-to="Teardown_113"/>
        <cc:async-mediation id="StoreArchive_113" execute-steps-when="props['inBatch']">
            <cc:steps>
                <cc:store id="StoreArchive" output="variable" output-variable="localImportRequestArchive113" createDocumentReference="true" expiresIn="@{props['sskDocumentRetentionPeriod']}" title="ImportRequests.zip"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:aggregator id="AggregateToArchive_113" routes-to="StoreArchive_113" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:zip-file-collater output-mimetype="application/zip" message-entity-name="@{props['inEntityName']}"/>
        </cc:aggregator>
        <cc:async-mediation id="NonRequest_113" routes-to="AggregateToArchive_113" execute-steps-when="props['inCollate'] &amp;&amp; !props['inSupportDetailedResultReporting']">
            <cc:steps>
                <cc:write id="WriteMessage">
                    <cc:message>
                        <cc:text>&lt;DoNotMessageMatch/></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="RestoreRequest_113" routes-to="NonRequest_113" execute-steps-when="props['inCollate'] &amp;&amp; props['inSupportDetailedResultReporting']">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output="message" output-mimetype="text/xml" input="variable" input-variable="localRequestCache113"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="ValidateArchive_113" routes-to="RestoreRequest_113">
            <cc:steps>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="11300" failure-message="WWS Import Request Aggregator (Aggregate_113) parameter failure.  The inCollate and inBatch arguments cannot both be false.">(!props['inCollate'] &amp;&amp; props['inBatch']) ||&#xD;
	(props['inCollate'] &amp;&amp; !props['inBatch']) ||&#xD;
	(props['inCollate'] &amp;&amp; props['inBatch'])</cc:expression>
                </cc:validate-exp>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Aggregate_113" routes-to="ValidateArchive_113">
            <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
            <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
            <cc:parameter documentation="When collating to the aggregator, this will be the name of the file for the content within the zip archive." name="inEntityName" required="props['inCollate']" type="string"/>
            <cc:parameter documentation="This boolean flag will cause the SSK Component to output the request message to an archive of a fixed-name that will be accessed by the post-processor and determine if detailed data block to message level result reporting will be given." name="inSupportDetailedResultReporting" required="props['inCollate']" type="boolean"/>
            <cc:out-parameter name="outEntityName"/>
        </cc:local-in>
        <cc:local-out id="Call_Finally_Finalized_113" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_113"/>
        <cc:local-out id="Call_Aggregate_Finalize_113" store-message="none" routes-response-to="Call_Finally_Finalized_113" endpoint="vm://INT006_Greenhouse_Inbound/Aggregate_113">
            <cc:set name="inCollate" value="false"/>
            <cc:set name="inBatch" value="true"/>
        </cc:local-out>
        <cc:local-in id="FinalizeCallSoapImport" routes-to="Call_Aggregate_Finalize_113" access="public" icon="icons/FinalizeCallSoapImport.png"/>
        <cc:local-out id="Call_HandleError_Results_Error_113" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the SOAP results from the message rootpart to variable globalSoapResults.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_113'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xD;&#xA;&#x9;props['inPathToXsltFile']"/>
        </cc:local-out>
        <cc:async-mediation id="Results_Handler_113" routes-to="Call_HandleError_Results_Error_113">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Results_113" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars[props.inReturnResults] = parts[0].source;</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Results_Handler_113"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_113" store-message="none" routes-response-to="Results_113" endpoint="vm://INT006_Greenhouse_Inbound/Aggregate_113" clone-request="true">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="props['inIsFinalImportCall']"/>
            <cc:set name="inEntityName" value="props['outImportProcessReference'] # '.xml'"/>
        <cc:set name="inSupportDetailedResultReporting" value="props['inSupportDetailedResultReporting']"/></cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Response_Info_113" routes-response-to="Call_Aggregate_113" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Import Web Service Started'"/>
            <cc:set name="inLogMessageDetail" value="'Launched an import process on the ' # props['inWebServiceApplication'] # ' application.  See the Reference ID for the associated WID of the Import Process Reference.'"/>
            <cc:set name="inLogReferenceId" value="props['outImportProcessReference']"/>
            <cc:set name="inLogLevel" value="'info'"/>
        </cc:local-out>
        <cc:async-mediation id="RetrieveProcessReference_113" routes-to="Call_CreateLogEntry_Response_Info_113">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['outImportProcessReference'] = parts[0].xpath('/env:Envelope/env:Body/wd:Put_Import_Process_Response/wd:Import_Process_Reference/wd:ID[@wd:type=&quot;WID&quot;]');</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_SoapResponse_113" store-message="none" execute-when="props['inDebugMode']" routes-response-to="RetrieveProcessReference_113" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Response__' # props['inWebServiceApplication']"/>
        </cc:local-out>
        <cc:workday-out-soap id="CallSoap_113" store-message="none" routes-response-to="Call_Debug_SoapResponse_113" application="@{props['inWebServiceApplication']}" version="@{props['inApiVersion']}"/>
        <cc:local-out id="Call_HandleError_HttpError_Error_113" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] #' application HTTP request error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while executing a SOAP request for the '# props['inWebServiceApplication'] #' application.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_113'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xD;&#xA;&#x9;props['inPathToXsltFile']"/>
        </cc:local-out>
        <cc:async-mediation id="RouteError_Http_Handler_113" routes-to="Call_HandleError_HttpError_Error_113">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'http';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_SoapError_Error_113" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] #' application SOAP request error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while executing a soap request for the '# props['inWebServiceApplication'] #' application.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="'11301'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_113'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xD;&#xA;&#x9;props['inPathToXsltFile']"/>
        </cc:local-out>
        <cc:async-mediation id="RouteError_Soap_Handler_113" routes-to="Call_HandleError_SoapError_Error_113">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'soap';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteError_113">
            <cc:mvel-strategy>
                <cc:choose-route expression="parts[0].isXml() &amp;&amp; (Integer.valueOf(parts[0].xpath('count(/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault)')) > 0)" route="SoapError"/>
                <cc:choose-route expression="true" route="HttpError"/>
            </cc:mvel-strategy>
            <cc:sub-route name="SoapError" routes-to="RouteError_Soap_Handler_113"/>
            <cc:sub-route name="HttpError" routes-to="RouteError_Http_Handler_113"/>
        </cc:route>
        <cc:async-mediation id="CallSoap_Catch_113" routes-to="CallSoap_113" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="RouteError_113"/>
        </cc:async-mediation>
        <cc:async-mediation id="CacheRequest_113" routes-to="CallSoap_Catch_113" execute-steps-when="props['inSupportDetailedResultReporting']">
            <cc:steps>
                <cc:copy id="CopyMsgToVar" output="variable" output-mimetype="text/xml" output-variable="localRequestCache113" input-xpath="/env:Envelope/env:Body/*" stream-xpath="true"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_SoapRequest_113" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CacheRequest_113" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Request__' # props['inWebServiceApplication']"/>
        </cc:local-out>
        <cc:async-mediation id="SetHeaders_113" routes-to="Call_Debug_SoapRequest_113">
            <cc:steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:wrap-soap id="WrapSoap"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_BuildRequest_113" store-message="none" execute-when="props['inBuildRequestPathToXsltFile'] != empty" routes-response-to="SetHeaders_113" endpoint="vm://INT006_Greenhouse_Inbound/BuildRequest_113" propagate-abort="true">
            <cc:set name="inApiVersion" value="props['inApiVersion']"/>
            <cc:set name="inPathToXsltFile" value="props['inPathToXsltFile']"/>
            <cc:set name="inDebugMode" value="props['inDebugMode']"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_113" routes-to="Call_BuildRequest_113" routes-response-to="Call_Finally_Initiate_113">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['outIsSoapError'] = '';</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_Initiate_113" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_113"/>
        <cc:local-in id="CallSoapImport" routes-to="InitializeAndFinalize_113" access="public" icon="icons/CallSoapImport.png">
            <cc:parameter default="props['globalApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter documentation="The WWS application where the operation may be found, e.g. &quot;Human_Resources&quot;." name="inWebServiceApplication" required="true" type="string"/>
            <cc:parameter documentation="The location that holds the data to be used in the transform provided on the inPathToXsltFile parameter.  This value is dependent on the value of inDataLocationId.  The parameter can have one of three values: message, variable, or property.  When the value is 'message', then the message part identified by inDataLocationId is interpreted as XML data to which the inPathToXsltFile xslt will be applied.  Similarly, if this parameter value is 'variable', then the variable identified by inDataLocationId is interpreted as XML data to which the inPathToXsltFile xslt will be applied.  if this parameter value is 'property', then the property identified by inDataLocationId is interpreted as a java.util.Map instance whose key/value pairs match pre-defined keys in the inPathToXsltFile xslt for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inBuildRequestDataLocation" required="props['inBuildRequestPathToXsltFile'] != empty" type="string" validation="((props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (['message','variable','property'] contains props['inBuildRequestDataLocation'].trim().toLowerCase())) ||&#xD;&#xA;&#x9;((props['inBuildRequestPathToXsltFile'] == empty) &amp;&amp; (props['inBuildRequestDataLocation'] == empty))"/>
            <cc:parameter documentation="The name that, when used with inBuildReqeustDataLocation, uniquely identifies which variable or property is to be used as the source data to which the transform provided on the inBuildReqeustPathToXsltFile parameter will be applied.  When inBuildReqeustDataLocation is 'message', then this parameter is ignored and the message root part is assumed." name="inBuildRequestDataLocationId" required="(props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'].trim().toLowerCase() != 'message')" type="string" validation="((props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'].trim().toLowerCase() != 'message') &amp;&amp; (props['inBuildRequestDataLocationId'] != empty)) ||&#xD;&#xA;&#x9;((props['inBuildRequestPathToXsltFile'] == empty) &amp;&amp; (props['inBuildRequestDataLocationId'] == empty))"/>
            <cc:parameter documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot; using the data identified by the inDataLocation and inDataLocationId input parameters.  This SSK Component also supports pre-built, on-message requests as well as facilities to construct the request dynamically.  If this parameter is omitted or set to null / an empty string, then inDataLocation and inDataLocationId can also be omitted (they are ignored), and then the dynamic request construction will be bypassed and the message root part will be used as the request." name="inBuildRequestPathToXsltFile" required="(props['inBuildRequestDataLocation'] != empty) || (props['inBuildRequestDataLocationId'] != empty)" type="string"/>
            <cc:parameter default="true" documentation="This boolean flag will cause the SSK Component to output the request message to an archive of a fixed-name that will be accessed by the post-processor and determine if detailed data block to message level result reporting will be given." name="inSupportDetailedResultReporting" required="true" type="boolean"/>
            <cc:parameter default="'message'" documentation="Where the results of the response are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="props['sskIsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="true" documentation="If this is the last Import WWS call that will be made by the integration, then set this parameter to true.  Otherwise, if additional Import WWS calls will be made, set this to false until the final call.  When this value is true, the ImportRequests.zip archive is produced for use in logging import results in the post-processor." name="inIsFinalImportCall" required="true" type="boolean"/>
            <cc:out-parameter documentation="A string to indicate that the request resulted in an error and identify the type.  If the error was at the API level, then outIsSoapError == 'http'.  If the error was at the tenant/application level, then outIsSoapError == 'soap'.  If there was an error unrelated to the API call, then outIsSoapError == 'logic'.  If there is no error, , then outIsSoapError == empty.  Further individual errors determined by Get_Event_Details or Get_Import_Processes are not handled here." name="outIsSoapError"/>
            <cc:out-parameter documentation="The error message of the exception for possible higher-level logging needs." name="outErrorMessage"/><cc:out-parameter documentation="The WID of the Import Process returned on the SOAP response from invoking the import web service.  This WID is later used to retrieve the outcome of the import process as well as any individual data failures." name="outImportProcessReference"/>
        </cc:local-in>
        <cc:local-out id="Call_Debug_GetEventDocuments_110" store-message="none" execute-when="props['inDebugMode']" routes-response-to="DocumentAccessor_110" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'Get_Event_Documents_Response'"/>
        </cc:local-out>
        <cc:async-mediation id="LoadFile_Variable_111" execute-steps-when="props['inReturnResults'].toString().toLowerCase() != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars[props.inReturnResults] = parts[0].source</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_LoadFile_Error_111" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'File Read Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while reading file ' # ((props['inFilename'] != empty) ? (props['inFilename'] # ' ') : '') # 'into the message root with Collection = ' # props['inCollection'] # ' and Entry = ' # props['inEntryID']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="LoadFile_111" routes-to="LoadFile_Variable_111" handle-downstream-errors="true">
            <cc:steps>
                <cc:retrieve id="Retrieve" collection="@{props['inCollection']}" entry="@{props['inEntryID']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_LoadFile_Error_111"/>
        </cc:async-mediation>
        <cc:local-out id="ProcessSplitMessage_116" store-message="none" endpoint="@{props['inProcessEndpoint']}"/>
        <cc:splitter id="Split_116" no-split-message-error="false">
            <cc:sub-route name="SubRoute" routes-to="ProcessSplitMessage_116"/>
            <cc:xml-stream-splitter xpath="/*/*"/>
        </cc:splitter>
        <cc:async-mediation id="StoreOutput_116" routes-to="Call_ProcessEndpoint_116" execute-steps-when="props['inProcessEndpoint'] == empty &amp;&amp; props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars[props.inReturnResults] = parts[0].source;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_BuildBlockMessage_Error_116" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'XSLT3 Block Splitter Error'"/>
            <cc:set name="inLogMessageDetail" value="'The XML data was unable to be split using the XSLT Block Splitter'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'XsltBlockSplitter-SplitXml'"/>
        <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_116'"/></cc:local-out>
        <cc:async-mediation id="BuildBlockMessage_116" routes-to="Call_Debug_BlockSplitResults_116" handle-downstream-errors="true">
            <cc:steps>
                <cc:xslt-plus id="SplitXML" url="xslt/ssk116/SSK116_XsltBlockSplit.xsl"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_BuildBlockMessage_Error_116"/>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareData_116" routes-to="BuildBlockMessage_116" execute-steps-when="props['inDataLocation'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveVarToMsg">
                    <cc:expression>parts[0] = vars[props.inDataLocation].source;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="BlockSplitter" routes-to="SyncMediation" access="public" icon="icons/XsltBlockSplitter.png">
            <cc:parameter default="'message'" documentation="Where the XML data being split can be found.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inDataLocation" required="true" type="string"/>
            <cc:parameter documentation="The numer of records that should be included in each output message.  Value must be a positive non-zero integer.  If inIsUseParallel is true, then this parameter will determine how many records are processed on each worker thread.  If additional splitting would be required on the worker thread to process the block, then this value should be set to 1." name="inBlockSize" required="true" type="integer" validation="props['inBlockSize'] > 0"/>
            <cc:parameter default="'/*/*'" documentation="XPath expression selecting the element(s) which will be included in each block of records.  This must be a streamable query" name="inItemXPath" required="false" type="string"/>
            <cc:parameter default="false" documentation="Boolean flag indicates that an error should be raised if there are no results from the attempt to block-split." name="inIsNoBlockSplitAnError" required="true" type="boolean"/><cc:parameter default="false" documentation="Determines if this component will route the result of the XSLT block split to a wcc/ParallelSubroutine to be processed.  If this value is true, then the inProcessEndpoint, inAggregationEndpoint, inParallelThreadCount, inParallelThreadTimeout, inParallelSplitterTimeout must also be provided.  If this value is false, then inProcessEndpoint is optional and the others should be omitted." name="inIsUseParallel" required="true" type="boolean"/><cc:parameter documentation="Specifies the endpoint (i.e., vm://INT006_Greenhouse_Inbound/&lt;Sample_Local-In>) that should be invoked to process each block of output message.  If not specified, the blocked-and-unsplit output will be returned to the caller (i.e., the original data surrounded by &lt;Blocks> and &lt;Block> tags).  If inUseParallel is true, then this must point to a thread-safe sub-assembly." name="inProcessEndpoint" required="props['inIsUseParallel']" type="string"/>
            <cc:parameter documentation="Specifies the endpoint (i.e., vm://INT006_Greenhouse_Inbound/&lt;Sample_Local-In>) that should be invoked to serve aggregation from each worker thread when inIsUseParallel is true.  This must point to a thread-safe sub-assembly." name="inAggregationEndpoint" required="props['inIsUseParallel']" type="string"/><cc:parameter default="4" documentation="This parameter sets the number of child threads that will be run.  Workday parallelism is not unbounded, and the target system must be considered as well for the amount of concurrency that can be supported.  The value must be at least 2 threads and not more than 7." name="inParallelThreadCount" required="props['inIsUseParallel']" type="integer" validation="props['inParallelThreadCount'] > 1 &amp;&amp; props['inParallelThreadCount'] &lt; 8"/><cc:parameter default="60" documentation="This parameter specifies the number of seconds in which the child thread is to complete before being interrupted and terminated." name="inParallelThreadTimeout" required="props['inIsUseParallel']" type="integer" validation="props['inParallelThreadTimeout'] > 0 &amp;&amp; props['inParallelThreadTimeout'] &lt; 7200"/><cc:parameter default="3600" documentation="This parameter specifies the number of seconds in which the ParallelSubroutine is to complete before being interrupted and terminated." name="inParallelSplitterTimeout" required="props['inIsUseParallel']" type="integer" validation="props['inParallelThreadTimeout'] > 0 &amp;&amp; props['inParallelThreadTimeout'] &lt; 7200"/><cc:parameter default="'message'" documentation="If supplied, then this is where the results of the XSLT Block Split are returned.  The result return also depends on the inProcessEndpoint value.  If the inReturnResults value is &quot;message&quot; and inProcessEndpoint is not specified, then the message root will contain all blocks when the SSK Component ends.  If the inReturnResults value is a variable name and inProcessEndpoint is not specified, then the named variable will contain all blocks when the SSK Component ends.  If inProcessEndpoint is defined, then the inReturnResults value is ignored, and it is up to the behavior of the dynamic endpoint as to what the final data state is.  The dynamic endpoint can expect to receive the block-split data on the message root part.  If inIsUseParallel is true, then inReturnResults is also ignored." name="inReturnResults" required="(!props['inIsUseParallel']) || (props['inProcessEndpoint'] == empty)" type="string"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not in-progress snapshots of data are output." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            
        </cc:local-in>
        <cc:sync-mediation id="Debug_InitializeAndFinalize_144" routes-to="RouteType_144">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['outEntityName'] = '';</cc:expression>
                </cc:eval></cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['sskFileBackedManagedDataDebugFragment','localCounter144','localKeys144','localValue144','localCollection144']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['debugTemporaryStorage','','','']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
                <cc:eval id="SetValues">
                    <cc:expression>if (['message','variable'] contains props['inTargetType'].trim().toLowerCase()) {&#xD;
	props.outDebugLogged144 = true;&#xD;
} else if (!context.containsProperty('outDebugLogged144')) {&#xD;
	props.outDebugLogged144 = false;&#xD;
} else {&#xD;
	props.outDebugLogged144 = props.outDebugLogged144 || false;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-in id="ProcessEndpoint_116" routes-to="Split_116"/>
        <cc:local-out id="Call_ProcessEndpoint_116" store-message="none" execute-when="props['inProcessEndpoint'] != empty" endpoint="vm://INT006_Greenhouse_Inbound/ProcessEndpoint_116"/>
        <cc:async-mediation id="ValidateBlockSplitResults_116" routes-to="RouteSplit_116">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['localIsBlocks'] = parts[0].xstreamB('/Blocks/Block')</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateExp">
                    <cc:expression error-number="11602" failure-message="The source data failed to be block split.  No blocks were produced.">!props['inIsNoBlockSplitAnError'] || &#xD;
	(props['inIsNoBlockSplitAnError'] &amp;&amp; props['localIsBlocks'])</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="Call_HandleError_ValidateBlockSplitResults_Error_116"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_ValidateBlockSplitResults_Error_116" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'XSLT3 Block Splitter Results Error'"/>
            <cc:set name="inLogMessageDetail" value="'The XSLT Block Splitter produced no results based on XPath to splitter of ['# props.inItemXPath #']'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="'11602'"/>
            
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'XsltBlockSplitter-ResultXml'"/>
        <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_116'"/></cc:local-out>
        <cc:async-mediation id="Teardown_116">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsBlocks']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_116" routes-to="Teardown_116"/>
        <cc:local-out id="Call_Finally_116" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_116"/>
        <cc:sync-mediation id="SyncMediation" routes-to="PrepareData_116" routes-response-to="Call_Finally_116">
            <cc:request-steps>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="11600" failure-message="Input parameter inDataLocation was not &quot;message&quot; and was not located as a variable.  The value must either be &quot;message&quot; or refer to a valid, bound variable.">props['inDataLocation'] == 'message' || context.variables.isVariable(props.inDataLocation)</cc:expression>
                    <cc:expression error-number="11601" failure-message="Input parameter inReturnResults was not &quot;message&quot; or a value for use as a variable name.  The value must either be &quot;message&quot; or a valid variable name.">props['inIsUseParallel'] || props['inReturnResults'] != empty</cc:expression>
                </cc:validate-exp></cc:request-steps>
            <cc:response-steps/>
        </cc:sync-mediation>
        <cc:sync-mediation id="InitializeAndFinalize_115" routes-to="GetEventDocuments_115" routes-response-to="Call_Finally_115">
            <cc:request-steps>
            </cc:request-steps>
            <cc:response-steps/>
        </cc:sync-mediation>
        <cc:async-mediation id="CopyResultFromThreads_115" routes-to="Call_Debug_Message_115">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" input="variable" input-variable="c2pAggregatedResult"/></cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_PrepareFileResults_Error_115" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the DIS results from the message rootpart to variable globalDISResults.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_115'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'localXslt115'"/><cc:set name="inEntityName" value="'localXslt115'"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_DocumentResults_115" store-message="none" execute-when="props['inDebugMode']" routes-response-to="RouteParallelism_115" endpoint="vm://INT006_Greenhouse_Inbound/Debug" clone-request="true"><cc:set name="inTargetType" value="'message'"/><cc:set name="inEntityName" value="'Get_Event_Documents_Response'"/></cc:local-out>
        <cc:local-out id="PIM_Debug_Stats_Secondary_142" store-message="none" execute-when="props['sskSecondaryLogCountDebug'] > 0" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'DEBUG'"/>
            <cc:set name="is.message.summary" value="props['sskSecondaryLogCountDebug'] + ' debug message(s) added!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Info_Stats_Secondary_142" store-message="none" execute-when="props['sskSecondaryLogCountInfo'] > 0" routes-response-to="PIM_Debug_Stats_Secondary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="props['sskSecondaryLogCountInfo'] + ' informational message(s) added!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Warning_Stats_Secondary_142" store-message="none" execute-when="props['sskSecondaryLogCountWarn'] > 0" routes-response-to="PIM_Info_Stats_Secondary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'WARNING'"/>
            <cc:set name="is.message.summary" value="props['sskSecondaryLogCountWarn'] + ' warning(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Error_Stats_Secondary_142" store-message="none" execute-when="props['sskSecondaryLogCountError'] > 0" routes-response-to="PIM_Warning_Stats_Secondary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'ERROR'"/>
            <cc:set name="is.message.summary" value="props['sskSecondaryLogCountError'] + ' error(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Critical_Stats_Secondary_142" store-message="none" execute-when="props['sskSecondaryLogCountFatal'] > 0" routes-response-to="PIM_Error_Stats_Secondary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'CRITICAL'"/>
            <cc:set name="is.message.summary" value="props['sskSecondaryLogCountFatal'] + ' fatal error(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-in id="LogStatsSecondary" routes-to="PIM_Critical_Stats_Secondary_142" access="private"/>
        <cc:local-out id="Call_LogStatsSecondary_142" execute-when="props['inLogFinalize']" endpoint="vm://INT006_Greenhouse_Inbound/LogStatsSecondary"/>
        <cc:async-mediation id="OutputSecondaryLog_142" routes-to="Call_LogStatsSecondary_142" execute-steps-when="com.workday.custom.int006.ssk142.GeneralCloudLogHelper.isLogReadyForOutput(context, 'secondary');">
            <cc:steps>
                <cc:eval id="Setup">
                    <cc:expression>props['sskSecondaryLogFilesStored'] = props['sskSecondaryLogFilesStored'] + 1</cc:expression>
                    <cc:expression>if (props['sskSecondaryLogFileFormat'] == 'HTML') {&#xD;
	props['localSecondaryLogFileExtension'] = '.html';&#xD;
} else if (props['sskSecondaryLogFileFormat'] == 'CSV') {&#xD;
	props['localSecondaryLogFileExtension'] = '.csv';&#xD;
} else {&#xD;
	props['localSecondaryLogFileExtension'] = '.xlsx';&#xD;
}</cc:expression>
                    <cc:expression>props['localSecondaryLogFilenameForStorage'] = (props['sskSecondaryLogMaxCountPerFile'] == 0) ? props['sskSecondaryLogFilename'] # props['localSecondaryLogFileExtension'] : props['sskSecondaryLogFilename'] # &quot;_&quot; # props['sskSecondaryLogFilesStored'] # props['localSecondaryLogFileExtension']</cc:expression>
                </cc:eval>
                <cc:store id="StoreCloudLog" input="variable" input-variable="cloud-log-secondary" createDocumentReference="true" expiresIn="@{props['sskSecondaryLogExpires']}" title="@{props['localSecondaryLogFilenameForStorage']}"/>
                <cc:eval id="Reset">
                    <cc:expression>vars['cloud-log-secondary'] = null</cc:expression>
                    <cc:expression>props['sskSecondaryLogCountByLogFile'] = 0</cc:expression>
                    <cc:expression>foreach (propname : ['localSecondaryLogFilenameForStorage']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="StoreLogSecondary" routes-to="OutputSecondaryLog_142" access="public">
            <cc:parameter default="false" name="inLogFinalize" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_StoreLogSecondary" store-message="none" execute-when="props['sskIsSecondaryLogEnabled']" routes-response-to="Call_Debug_Finalize_109" endpoint="vm://INT006_Greenhouse_Inbound/StoreLogSecondary">
            <cc:set name="inLogFinalize" value="true"/>
        </cc:local-out>
        <cc:local-out id="Call_StoreLogSecondary_Error_109" store-message="none" execute-when="props['sskIsSecondaryLogEnabled']" routes-response-to="Call_Debug_Initialize_Finalize_Error_109" endpoint="vm://INT006_Greenhouse_Inbound/StoreLogSecondary">
            <cc:set name="inLogFinalize" value="true"/>
        </cc:local-out>
        <cc:local-out id="Call_StoreLogSecondary_GEH" store-message="none" execute-when="props['sskIsSecondaryLogEnabled']" routes-response-to="Call_Debug_Finalize_GEH" endpoint="vm://INT006_Greenhouse_Inbound/StoreLogSecondary">
            <cc:set name="inLogFinalize" value="true"/>
        </cc:local-out>
        <cc:local-out id="Call_StoreLogSecondary_142" endpoint="vm://INT006_Greenhouse_Inbound/StoreLogSecondary">
            <cc:set name="inLogFinalize" value="false"/>
        </cc:local-out>
        <cc:local-in id="CreateSecondaryLogEntry" routes-to="RouteSecondaryLogType_142" access="public" icon="icons/CreateSecondaryLogEntry.png">
            <cc:parameter documentation="Value that will be written to the Message attribute of the Cloud Logger." name="inLogMessage" required="true" type="string"/>
            <cc:parameter documentation="Value that will be written to the Message Details attribute of the Cloud Logger." name="inLogMessageDetail" required="false" type="string"/>
            <cc:parameter documentation="Value that will be written to the Reference Id attribute of the Cloud Logger.  This is most commonly used to record the WID of the record to which this message pertains and can save the MVEL code of concatenating it into the Message Detail." name="inLogReferenceId" required="false" type="string"/>
            <cc:parameter documentation="Value that determines the Level attribute of the Cloud Logger.  Must be one of: debug, info, warn, error, fatal." name="inLogLevel" required="true" type="string" validation="['debug','info','warn','error','fatal'] contains props['inLogLevel'].trim().toLowerCase()"/>
            <cc:parameter documentation="Value written to the LocalIn Extra Column on the log.  This field is a convention of SSK and used to record the name of a Mediation related to the message, e.g. the errorComponentId causing an error to be raised." name="inExtraLocalIn" required="false"/>
            <cc:parameter documentation="Value written to the RecordNumber Extra Column on the log.  This field is a convention of SSK and used to record the position/count of a data record in a set to which this message pertains." name="inExtraRecordNumber" required="false"/>
            <cc:parameter documentation="Value written to the SupportData Extra Column on the log.  This field is a convention of SSK and used to provide open-ended advice for support.  This may constitute additional data values, or it may mean remediation advice for a particular error." name="inExtraSupportData" required="false"/>
            <cc:parameter documentation="Value written to the ErrorCode Extra Column on the log.  This field is a convention of SSK and used to provide the value of the error code when the message is logging error information.  This code may be given by the ESB, or it may be a custom code defined by the developer.  Note that this field is a String whereas Studio/ESB codes are integers, so type conversion is required." name="inExtraErrorCode" required="false"/>
        </cc:local-in>
        <cc:local-out id="Call_CreateSecondaryLogEntry_141" store-message="none" execute-when="props['inLogTarget'] == 'secondary'" routes-response-to="Call_Debug_Parent_141" endpoint="vm://INT006_Greenhouse_Inbound/CreateSecondaryLogEntry">
            <cc:set name="inLogMessage" value="props.inLogMessage"/>
            <cc:set name="inLogMessageDetail" value="if (context.containsProperty('inLogMessageDetail')) {&#xD;&#xA;&#x9;(props['inLogMessageDetail'] != empty) ? props['inLogMessageDetail'] : ''&#xD;&#xA;} else {&#xD;&#xA;&#x9;''&#xD;&#xA;}"/>
            <cc:set name="inLogReferenceId" value="if (context.containsProperty('inLogReferenceId')) {&#xD;&#xA;&#x9;(props['inLogReferenceId'] != empty) ? props['inLogReferenceId'] : ''&#xD;&#xA;} else {&#xD;&#xA;&#x9;''&#xD;&#xA;}"/>
            <cc:set name="inLogLevel" value="props.inLogLevel"/>
            <cc:set name="inExtraLocalIn" value="if (context.containsProperty('inExtraLocalIn')) {&#xD;&#xA;&#x9;props['inExtraLocalIn']&#xD;&#xA;} else {&#xD;&#xA;&#x9;''&#xD;&#xA;}"/>
            <cc:set name="inExtraRecordNumber" value="if (context.containsProperty('inExtraRecordNumber')) {&#xD;&#xA;&#x9;props['inExtraRecordNumber']&#xD;&#xA;} else {&#xD;&#xA;&#x9;''&#xD;&#xA;}"/>
            <cc:set name="inExtraSupportData" value="if (context.containsProperty('inExtraSupportData')) {&#xD;&#xA;&#x9;props['inExtraSupportData']&#xD;&#xA;} else {&#xD;&#xA;&#x9;''&#xD;&#xA;}"/>
            <cc:set name="inExtraErrorCode" value="if (context.containsProperty('inExtraErrorCode')) {&#xD;&#xA;&#x9;props['inExtraErrorCode']&#xD;&#xA;} else {&#xD;&#xA;&#x9;''&#xD;&#xA;}"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateSecondaryLogEntry_LogThreadMessages_143" store-message="none" execute-when="props['inLogTarget'] == 'secondary'" endpoint="vm://INT006_Greenhouse_Inbound/CreateSecondaryLogEntry">
            <cc:set name="inLogMessage" value="props['localParallelLogMessage143'].getSummary()"/>
            <cc:set name="inLogMessageDetail" value="props['localParallelLogMessage143'].getDetail()"/>
            <cc:set name="inLogReferenceId" value="props['localParallelLogMessage143'].getReferenceId()"/>
            <cc:set name="inLogLevel" value="props['localParallelLogMessage143'].getLevel()"/>
            <cc:set name="inExtraLocalIn" value="props['localParallelLogMessage143'].getLocalIn()"/>
            <cc:set name="inExtraRecordNumber" value="props['localParallelLogMessage143'].getRecordNumber()"/>
            <cc:set name="inExtraSupportData" value="props['localParallelLogMessage143'].getSupportData()"/>
            <cc:set name="inExtraErrorCode" value="props['localParallelLogMessage143'].getErrorCode()"/>
        </cc:local-out>
        <cc:local-in id="AggregateSources_107" routes-to="PrepareDataSources_107"/>
        <cc:async-mediation id="CacheMessage_107" routes-to="ForEachDataSource_107" execute-steps-when="props['localCacheMessage']">
            <cc:steps>
                <cc:copy id="CopyMsgToVar" output="variable" output-mimetype="text/xml" output-variable="localMessageCache107"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="ForEachDataSource_107">
            <cc:loop-strategy condition="props['localSourceCounter'] &lt; props['localSourcesList'].length" increment="props['localSourceCounter'] = props['localSourceCounter'] + 1" init="props['localSourceCounter'] = 0"/>
            <cc:sub-route name="ForEach" routes-to="PrepareDataSource_107"/>
        </cc:route>
        <cc:async-mediation id="PrepareDataSource_107" routes-to="Call_Aggregate_SourceData_107">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>sourceName = props.localSourcesList[props.localSourceCounter];&#xD;
if (sourceName.toLowerCase() == 'message' &amp;&amp; props.localCacheMessage) {&#xD;
	parts[0] = vars['localMessageCache107'].source;&#xD;
} else if (sourceName.toLowerCase() != 'message') {&#xD;
	parts[0] = vars[sourceName].source;&#xD;
} else {&#xD;
	//no-op - sourceName == message and cache wasn't required, which means the content is already on-message&#xD;
}</cc:expression>
                    <cc:expression>props['localIsBatch'] = (props['localSourceCounter'] == (props['localSourcesList'].length - 1));</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_SourceData_107" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Aggregate_107">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="props['localIsBatch']"/>
        </cc:local-out>
        <cc:local-out id="Call_AggregateSources_107" store-message="none" routes-response-to="Call_Debug_AggregatedData_107" endpoint="vm://INT006_Greenhouse_Inbound/AggregateSources_107"/>
        <cc:async-mediation id="PrepareDataSources_107" routes-to="CacheMessage_107">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>testString = org.apache.commons.lang3.StringUtils.replace(props.inDataSourceLocationList, ' ', '');&#xD;
props['localSourcesList'] = org.apache.commons.lang3.StringUtils.split(testString, ',');&#xD;
localMatches = 0;&#xD;
foreach (dataLoc : props['localSourcesList']) {&#xD;
	if (dataLoc.toLowerCase() == 'message') {&#xD;
		localMatches = localMatches + 1;&#xD;
	}&#xD;
}&#xD;
props['localCacheMessage'] = ((localMatches > 0) &amp;&amp; (!org.apache.commons.lang3.StringUtils.startsWith(testString.toLowerCase(), org.apache.commons.lang3.StringUtils.repeat('message', ',', Math.max(1, localMatches)))));&#xD;
</cc:expression>
                </cc:eval></cc:steps>
        </cc:async-mediation>
        <cc:route id="RoutePrimaryLogType_142">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['sskPrimaryLogFileFormat'] == 'HTML'" route="HTML"/>
                <cc:choose-route expression="props['sskPrimaryLogFileFormat'] == 'CSV'" route="CSV"/>
                <cc:choose-route expression="true" route="XLSX"/>
            </cc:mvel-strategy>
            <cc:sub-route name="HTML" routes-to="Call_WritePrimaryLog_HTML_142"/>
            <cc:sub-route name="CSV" routes-to="Call_WritePrimaryLog_CSV_142"/>
            <cc:sub-route name="XLSX" routes-to="Call_WritePrimaryLog_XLSX_142"/>
        </cc:route>
        <cc:local-in id="WritePrimaryLog_HTML_142" routes-to="PrimaryLog_HTML_142"/>
        <cc:local-in id="WritePrimaryLog_CSV_142" routes-to="PrimaryLog_CSV_142"/>
        <cc:local-in id="WritePrimaryLog_XLSX_142" routes-to="PrimaryLog_XLSX_142"/>
        <cc:async-mediation id="PrimaryLog_HTML_142" routes-to="UpdatePrimaryLogTracking_142">
            <cc:steps>
                <cc:cloud-log id="LogMessageHTML" level="props['inLogLevel'].trim().toLowerCase()" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="HTML" reference-id="props['inLogReferenceId']" variable-name="cloud-log-primary">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrimaryLog_CSV_142" routes-to="UpdatePrimaryLogTracking_142">
            <cc:steps>
                <cc:cloud-log id="LogMessageCSV" level="props['inLogLevel'].trim().toLowerCase()" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="CSV" reference-id="props['inLogReferenceId']" variable-name="cloud-log-primary">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrimaryLog_XLSX_142" routes-to="UpdatePrimaryLogTracking_142">
            <cc:steps>
                <cc:cloud-log id="LogMessageXLSX" level="props['inLogLevel'].trim().toLowerCase()" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="XLSX" reference-id="props['inLogReferenceId']" variable-name="cloud-log-primary">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_WritePrimaryLog_HTML_142" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/WritePrimaryLog_HTML_142"/>
        <cc:local-out id="Call_WritePrimaryLog_CSV_142" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/WritePrimaryLog_CSV_142"/>
        <cc:local-out id="Call_WritePrimaryLog_XLSX_142" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/WritePrimaryLog_XLSX_142"/>
        <cc:async-mediation id="SecondaryLog_XLSX_142" routes-to="UpdateSecondaryLogTracking_142">
            <cc:steps>
                <cc:cloud-log id="LogMessageXLSX" level="props['inLogLevel'].trim().toLowerCase()" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="XLSX" reference-id="props['inLogReferenceId']" variable-name="cloud-log-secondary">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="WriteSecondaryLog_XLSX_142" routes-to="SecondaryLog_XLSX_142"/>
        <cc:async-mediation id="SecondaryLog_CSV_142" routes-to="UpdateSecondaryLogTracking_142">
            <cc:steps>
                <cc:cloud-log id="LogMessageCSV" level="props['inLogLevel'].trim().toLowerCase()" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="CSV" reference-id="props['inLogReferenceId']" variable-name="cloud-log-secondary">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="WriteSecondaryLog_CSV_142" routes-to="SecondaryLog_CSV_142"/>
        <cc:async-mediation id="SecondaryLog_HTML_142" routes-to="UpdateSecondaryLogTracking_142">
            <cc:steps>
                <cc:cloud-log id="LogMessageHTML" level="props['inLogLevel'].trim().toLowerCase()" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="HTML" reference-id="props['inLogReferenceId']" variable-name="cloud-log-secondary">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="WriteSecondaryLog_HTML_142" routes-to="SecondaryLog_HTML_142"/>
        <cc:route id="RouteSecondaryLogType_142">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['sskSecondaryLogFileFormat'] == 'HTML'" route="HTML"/>
                <cc:choose-route expression="props['sskSecondaryLogFileFormat'] == 'CSV'" route="CSV"/>
                <cc:choose-route expression="true" route="XLSX"/>
            </cc:mvel-strategy>
            <cc:sub-route name="HTML" routes-to="Call_WriteSecondaryLog_HTML_142"/>
            <cc:sub-route name="CSV" routes-to="Call_WriteSecondaryLog_CSV_142"/>
            <cc:sub-route name="XLSX" routes-to="Call_WriteSecondaryLog_XLSX_142"/>
        </cc:route>
        <cc:local-out id="Call_WriteSecondaryLog_XLSX_142" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/WriteSecondaryLog_XLSX_142"/>
        <cc:local-out id="Call_WriteSecondaryLog_CSV_142" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/WriteSecondaryLog_CSV_142"/>
        <cc:local-out id="Call_WriteSecondaryLog_HTML_142" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/WriteSecondaryLog_HTML_142"/>
        <cc:local-out id="Call_WriteLog_112" store-message="none" endpoint="@{props.dynamicEndpoint112}">
        	<cc:set name="inLogMessage" value="props['localLogMessage'].message"/>
        	<cc:set name="inLogMessageDetail" value="props['localLogMessage'].details"/>
        	<cc:set name="inLogReferenceId" value="props['localLogMessage'].referenceId"/>
        	<cc:set name="inLogLevel" value="String.valueOf(props['localLogMessage'].level)"/>
        </cc:local-out>
        <cc:local-in id="XsltPlus" routes-to="ApplyTransform_129" access="public" icon="icons/XsltPlus.png">
        	<cc:parameter default="'message'" documentation="Where the XML data being transformed can be found.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inDataLocation" required="true" type="string"/>
        	<cc:parameter documentation="The path relative to ws/WSAR-INF where the transformation stylesheet to be applied is found" name="inPathToXsltFile" required="true" type="string"/>
        	<cc:parameter default="'message'" documentation="How the results are returned to the caller, either on the message if the value is 'message', which is the default, or in a variable of the name given as the value." name="inReturnResults" required="true" type="string"/>
        	<cc:parameter default="props['sskIsDebugMode'] ? 'debug' : 'info'" documentation="The minimum log level of message produced by the XSLT that will be recorded to the Cloud Log" name="inMinLogLevel" required="false" type="string" validation="['debug','info','warn','error','fatal'] contains props['inMinLogLevel'].trim().toLowerCase()"/>
        	<cc:parameter default="'primary'" documentation="Controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
        	<cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        </cc:local-in>
        <cc:async-mediation id="ApplyTransform_129" routes-to="Call_CloudLogXSLTMessages_129">
            <cc:steps>
                <cc:eval id="MoveVarToMsg">
                    <cc:expression>if (props['inDataLocation'] != 'message') {&#xD;
	parts[0] = vars[props.inDataLocation].source;&#xD;
}</cc:expression>
                </cc:eval>
                <cc:xslt-plus id="XsltPlus" messages-property="localMessages129" url="@{props['inPathToXsltFile']}"/>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>if (props['inReturnResults'] != 'message') {&#xD;
	vars[props.inReturnResults] = parts[0].source;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_ApplyTransform_Error_129"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_ApplyTransform_Error_129" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError"><cc:set name="inLogMessage" value="'XsltPlus Error'"/><cc:set name="inLogMessageDetail" value="'An error was encountered applying the ' # props['inPathToXsltFile'] # ' stylesheet to the data on ' # props['inDataLocation'] # '.'"/><cc:set name="inLogLevel" value="'error'"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/><cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/><cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/><cc:set name="inIsResetError" value="false"/><cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inLogTarget" value="props['inLogTarget']"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_CloudLogXSLTMessages_129" store-message="none" execute-when="props['localMessages129'] != empty" endpoint="vm://INT006_Greenhouse_Inbound/CloudLogXSLTMessages"><cc:set name="inMessages" value="props['localMessages129']"/><cc:set name="inIsClearMessages" value="true"/><cc:set name="inMinLogLevel" value="props['inMinLogLevel']"/><cc:set name="inLogTarget" value="props['inLogTarget']"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_QueryCache_Error_104" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            
            
        <cc:set name="inLogMessage" value="'WWS Query Cache will be voided'"/><cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/><cc:set name="inLogLevel" value="'error'"/><cc:set name="inExtraLocalIn" value="'ValidateQueryCache@ValidatedAndSetHeaders_104'"/><cc:set name="inExtraSupportData" value="'props.localIsQueryCacheEffective = ' # props.localIsQueryCacheEffective # '\nprops.localIsQueryCacheEntryDate = ' # props.localIsQueryCacheEntryDate"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/><cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_104'"/><cc:set name="inIsAbortOnError" value="true"/><cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/><cc:set name="inTargetType" value="'message'"/><cc:set name="inEntityName" value="'SOAP-Request__' # props['inWebServiceApplication']"/><cc:set name="inLogTarget" value="props['inLogTarget']"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:local-out id="CallSoapSerial_104" store-message="none" endpoint="vm://wcc/PagedGet">
            <cc:set name="is.paged.get.request.current.page.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Filter/wd:Page'"/>
            <cc:set name="is.paged.get.response.current.page.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Page'"/>
            <cc:set name="is.paged.get.response.total.pages.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Pages'"/>
            <cc:set name="is.paged.get.response.total.results.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Results'"/>
            <cc:set name="is.paged.get.process.endpoint" value="'vm://INT006_Greenhouse_Inbound/ProcessPage_104'"/>
            <cc:set name="is.paged.get.application" value="props['inWebServiceApplication']"/>
            <cc:set name="is.paged.get.version" value="props['inApiVersion']"/>
            <cc:set name="is.paged.get.page.zero" value="false"/>
            <cc:set name="is.paged.get.store.requests" value="true"/>
            
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_AbortOnChildThreadError_104" store-message="none" execute-when="props['outIsErrorsOnThreads'] &amp;&amp; props['inIsAbortOnError']" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Errors Encountered During Parallel Processing'"/>
            <cc:set name="inLogMessageDetail" value="'Errors were encountered on child threads.  Therefore, a complete data set cannot be guaranteed and continued processing cannot be trusted to be accurate.  The integration will be terminated due to issues encountered processing and aggregating the PagedGet results.'"/>
            <cc:set name="inLogReferenceId" value="''"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="'Call_HandleError_AbortOnChildThreadError_104'"/>
            <cc:set name="inExtraRecordNumber" value="''"/>
            <cc:set name="inExtraSupportData" value="''"/>
            <cc:set name="inExtraErrorCode" value="'10406'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_104'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        <cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:local-out id="Call_WriteThreadLogsToCloudLog_104" store-message="none" routes-response-to="Call_HandleError_AbortOnChildThreadError_104" endpoint="vm://INT006_Greenhouse_Inbound/WriteThreadLogsToCloudLog"><cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:local-in id="FinalizeReturnFromThread_104" routes-to="Call_WriteThreadLogsToCloudLog_104"/>
        <cc:aggregator id="AggregateParallelData_104" collate-when="props['aggregator.destination.force.collate'] &amp;&amp; props['localIsC2PData']" force-batch-on-last-message="false" force-batch-when="props['aggregator.destination.force.batch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="variable" output-mimetype="text/xml" output-variable="c2pAggregatedResult104" xpath="/*/*">
        <cc:header-text>@{props['inAggregatedResultsHeader']}</cc:header-text>
        <cc:footer-text>@{props['inAggregatedResultsFooter']}</cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-out id="Call_CreateLogEntryOnThread_CrossThreadTransfer_104" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'SOAP Page Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while transferring the results from the SOAP response to be aggregated.  Processing of the remaining results will continue but this page will be excluded...'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="''"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
        </cc:local-out>
        <cc:async-mediation id="CrossThreadChildToChild_104" routes-to="AggregateParallelData_104" continue-after-error="rewind" execute-steps-when="props['aggregator.destination.force.collate'] &amp;&amp; props['localIsC2PData']" handle-downstream-errors="true">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="c2pPageToAggregate104"/>
                <cc:eval id="ReleaseResource">
                    <cc:expression>vars['c2pPageToAggregate104'] = null /* Remove the variable now that we've finished with it */</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_CreateLogEntryOnThread_CrossThreadTransfer_104"/>
        </cc:async-mediation>
        <cc:async-mediation id="ValidateChildReturnData_104" routes-to="CrossThreadChildToChild_104">
            <cc:steps>
                <cc:eval id="TestForData">
                    <cc:expression>props['localIsC2PData'] = ((vars['c2pPageToAggregate104'] != null) &amp;&amp; (vars['c2pPageToAggregate104'].xstreamB('/*/*')));</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="AggregateParallel_104" routes-to="RouteAggregation_104">
            
            
            
            
        </cc:local-in>
        <cc:local-out id="Call_CreateLogEntryOnThread_Default_Debug_104" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'SOAP Page Processed'"/>
            <cc:set name="inLogMessageDetail" value="'A page of SOAP results was processed'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraLocalIn" value="''"/>
            <cc:set name="inExtraRecordNumber" value="parts[0].xstream('/env:Envelope/env:Body/*/wd:Response_Results/wd:Page')"/>
            <cc:set name="inExtraSupportData" value="'Sorry.  The Debug SSK Component is not thread-safe and therefore the data page cannot be archived for debug.'"/>
            <cc:set name="inExtraErrorCode" value="''"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntryOnThread_Default_Error_104" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'SOAP Page Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while extracing the results from the SOAP response using xpath[/env:Envelope/env:Body/*/wd:Response_Data].  Processing of the remaining results will continue...'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="''"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
        </cc:local-out>
        <cc:async-mediation id="CrossThread_Default_104" routes-to="Call_CreateLogEntryOnThread_Default_Debug_104" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
                <cc:xslt-plus id="XsltPlus" output="variable" output-mimetype="text/xml" output-variable="c2pPageToAggregate104" url="mctx:vars/localAggregationXslt104"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_CreateLogEntryOnThread_Default_Error_104"/>
        </cc:async-mediation>
        <cc:local-in id="ProcessPageParallel_104" routes-to="RouteThreadProcessing_104">
            
        </cc:local-in>
        <cc:local-out id="Call_InitializeThreadedLogging_104" store-message="none" routes-response-to="PrepareThreadXsltForAggregation_104" endpoint="vm://INT006_Greenhouse_Inbound/StartThreadLog"/>
        <cc:route id="RouteThreadProcessing_104">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inParallelPageProcessorEndpoint'] != empty" route="Custom"/>
                <cc:choose-route expression="true" route="Default"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Custom" routes-to="CustomThreadProcessCatch_104"/>
            <cc:sub-route name="Default" routes-to="CrossThread_Default_104"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntryOnThread_Custom_Error_104" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'SOAP Page Processing Error on Custom Endpoint'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while processing the results from the SOAP response using dynamic endpoint ['# props['inParallelPageProcessorEndpoint'] #'].  The exception was either not handled or was rethrown from that code.  Processing of the remaining results on other threads will continue...'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="''"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
        </cc:local-out>
        <cc:async-mediation id="CustomThreadProcessCatch_104" routes-to="Call_CreateLogEntryOnThread_Custom_Debug_104" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_CreateLogEntryOnThread_Custom_Error_104"/>
        </cc:async-mediation>
        <cc:local-out id="Call_CustomDynamicEndpoint_104" store-message="none" routes-response-to="CrossThread_Custom_104" endpoint="@{props['inParallelPageProcessorEndpoint']}"/>
        <cc:async-mediation id="CrossThread_Custom_104" execute-steps-when="!props['inParallelSuppressAggregation']">
            <cc:steps>
                <cc:copy id="CopyMsgToVar" output="variable" output-mimetype="text/xml" output-variable="c2pPageToAggregate104"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntryOnThread_Custom_Debug_104" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_CustomDynamicEndpoint_104" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'Invoking Dynamic Endpoint on Thread'"/>
            <cc:set name="inLogMessageDetail" value="'A page of SOAP results is routing to '# props['inParallelPageProcessorEndpoint'] #' to be processed'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraLocalIn" value="''"/>
            <cc:set name="inExtraRecordNumber" value="parts[0].xstream('/env:Envelope/env:Body/*/wd:Response_Results/wd:Page')"/>
            <cc:set name="inExtraSupportData" value="'Sorry.  The Debug SSK Component is not thread-safe and therefore the data page cannot be archived for debug.'"/>
            <cc:set name="inExtraErrorCode" value="''"/>
        </cc:local-out>
        <cc:route id="RouteAggregation_104">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inParallelSuppressAggregation']" route="Suppress"/>
                <cc:choose-route expression="true" route="Aggregate"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Suppress" routes-to="Call_CreateLogEntryOnThread_AggregationSuppressed_Info_104"/>
            <cc:sub-route name="Aggregate" routes-to="ValidateChildReturnData_104"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntryOnThread_AggregationSuppressed_Info_104" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'PagedGet Aggregation Suppressed'"/>
            <cc:set name="inLogMessageDetail" value="'The results of the paginated response will not be aggregated per configuration'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'info'"/>
            
            
            
            
        </cc:local-out>
        <cc:local-out id="Call_ParallelPostProcess_104" store-message="none" execute-when="props.inIsParallelPagedGet" routes-response-to="Call_Finally_104" endpoint="vm://INT006_Greenhouse_Inbound/ParallelPostProcess_104"/>
        <cc:local-in id="ParallelPostProcess_104" routes-to="Call_FinalizeReturnFromThread_104"/>
        <cc:local-out id="Call_FinalizeReturnFromThread_104" store-message="none" routes-response-to="SetReturnResults_Message_104" endpoint="vm://INT006_Greenhouse_Inbound/FinalizeReturnFromThread_104"/>
        <cc:async-mediation id="SetReturnResults_Message_104" routes-to="SetReturnResults_Variable_104" execute-steps-when="!props['inParallelSuppressAggregation'] &amp;&amp; props['inReturnResults'] == 'message'">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" input="variable" input-variable="c2pAggregatedResult104"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="SetReturnResults_Variable_104" execute-steps-when="!props['inParallelSuppressAggregation'] &amp;&amp; props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveVarToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, (vars.getVariable('c2pAggregatedResult104')), vars.getMimeType('c2pAggregatedResult104'));</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteInputSource_104">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inBuildRequestDataLocation'].trim().toLowerCase() == 'message'" route="Message"/>
                <cc:choose-route expression="props['inBuildRequestDataLocation'].trim().toLowerCase() == 'variable'" route="Variable"/>
                <cc:choose-route expression="true" route="Property"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Message" routes-to="Validation_Message_104"/>
            <cc:sub-route name="Variable" routes-to="Validation_Variable_104"/>
            <cc:sub-route name="Property" routes-to="Validation_Property_104"/>
        </cc:route>
        <cc:async-mediation id="Validation_Property_104" routes-to="PreparePropertyInput_104">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>propname = props['inBuildRequestDataLocationId'];&#xD;
props['localIsValueDefined'] = context.containsProperty(propname);&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (context.getProperty(propname) instanceof java.util.Map) &amp;&amp; !(((java.util.Map)(context.getProperty(propname))).isEmpty());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10404" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, a context property named [@{props.inBuildRequestDataLocationId}] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="10405" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, the referenced context property named [@{props.inBuildRequestDataLocationId}] was not an instance of a java.util.Map, or that Map was empty.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Property_104"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Variable_104" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleBuildRequestValidationError_104">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Variable_104" routes-to="PrepareVariableInput_104">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>varname = props['inBuildRequestDataLocationId'];&#xD;
props['localIsValueDefined'] = (vars.isVariable(varname)) &amp;&amp; (vars[varname] != null);&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (vars[varname].isXml());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10402" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, a message variable named [@{props.inBuildRequestDataLocationId}] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="10403" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, the referenced message variable named [@{props.inBuildRequestDataLocationId}] was not valid XML data.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Variable_104"/>
        </cc:async-mediation>
        <cc:local-in id="HandleBuildRequestValidationError_104" routes-to="Validation_Handler_104"/>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Message_104" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleBuildRequestValidationError_104">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Property_104" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleBuildRequestValidationError_104">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="MoveResultsToVariable_104" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars[props.inReturnResults] = parts[0];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteConcurrency_104">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inIsParallelPagedGet']" route="Parallel"/>
                <cc:choose-route expression="true" route="Serial"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Parallel" routes-to="Call_InitializeThreadedLogging_104"/>
            <cc:sub-route name="Serial" routes-to="CallSoapSerial_104"/>
        </cc:route>
        <cc:async-mediation id="PrepareThreadXsltForAggregation_104" routes-to="CallSoapParallel_104" execute-steps-when="!props['inParallelSuppressAggregation']">
            <cc:steps>
                <cc:write id="WriteXslt" output="variable" output-variable="localAggregationXslt104">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;xsl:stylesheet version=&quot;3.0&quot; &#xD;
    xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&#xD;
    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&#xD;
    xmlns:wd=&quot;urn:com.workday/bsvc&quot;&#xD;
    xmlns:env=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&#xD;
    exclude-result-prefixes=&quot;#all&quot;>&#xD;
    &#xD;
    &lt;xsl:mode streamable=&quot;yes&quot; on-no-match=&quot;shallow-skip&quot;/>&#xD;
    &lt;xsl:mode streamable=&quot;yes&quot; on-no-match=&quot;deep-copy&quot; name=&quot;replicate&quot;/>&#xD;
    &#xD;
    &lt;xsl:template match=&quot;/&quot;>&#xD;
        &lt;SoapResults xmlns:wd=&quot;urn:com.workday/bsvc&quot;>&#xD;
        	&lt;xsl:apply-templates select=&quot;@{props['inXpathToResultsToAggregate']}&quot; mode=&quot;replicate&quot;/>&#xD;
        &lt;/SoapResults>&#xD;
    &lt;/xsl:template>&#xD;
&lt;/xsl:stylesheet></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_WriteThreadLogsToCloudLog_Flush_104" store-message="none" execute-when="props['inIsParallelPagedGet'] &amp;&amp; props['localParallelLog143'] != empty" routes-response-to="Teardown_104" endpoint="vm://INT006_Greenhouse_Inbound/WriteThreadLogsToCloudLog">
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_FlushInfo_104" store-message="none" execute-when="props['inIsParallelPagedGet'] &amp;&amp; props['localParallelLog143'] != empty" routes-response-to="Call_WriteThreadLogsToCloudLog_Flush_104" endpoint="@{props['inLogTarget'] == 'secondary' ? 'vm://INT006_Greenhouse_Inbound/CreateSecondaryLogEntry' : 'vm://INT006_Greenhouse_Inbound/CreateLogEntry'}">
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
        <cc:set name="inLogMessage" value="'Unlogged thread messages found'"/><cc:set name="inLogMessageDetail" value="'All messages from child threads in parallel PagedGet were not logged.  Messages will be flushed to the log.  This may result in out-of-order message sequences.'"/><cc:set name="inLogLevel" value="'info'"/><cc:set name="inExtraRecordNumber" value="props['localParallelLog143'].size()"/></cc:local-out>
        <cc:async-mediation id="MakeVariableNullSafe_118" execute-steps-when="vars['c2pAggregatedResult118'] == null">
            <cc:steps>
                <cc:write id="Write" output="variable" output-mimetype="text/xml" output-variable="c2pAggregatedResult118">
                    <cc:message>
                        <cc:text>&lt;?xml version='1.0' encoding='UTF-8'?>&#xD;
&lt;wd:Import_Process_Messages xmlns:wd=&quot;urn:com.workday/bsvc&quot;/></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_AggregatedData_107" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Transform_107" endpoint="vm://INT006_Greenhouse_Inbound/Debug"><cc:set name="inTargetType" value="'variable'"/><cc:set name="inTargetName" value="'localPreTransformData107'"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_Debug_Core_109" store-message="none" routes-response-to="Call_IEP_10" endpoint="vm://INT006_Greenhouse_Inbound/Debug"><cc:set name="inTargetType" value="'properties'"/><cc:set name="inTargetName" value="'sskDebugPropertyList'"/></cc:local-out>
        <cc:local-out id="Call_Debug_SoapXslt_103" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inBuildRequestPathToXsltFile'"/>
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_Transform_Error_103" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Transformation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a SOAP service call.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_103'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inBuildRequestPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inBuildRequestPathToXsltFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inBuildRequestPathToXsltFile'], '/') :&#xD;&#xA;&#x9;props['inBuildRequestPathToXsltFile']"/>
            <cc:set name="inLogTarget" value="'primary'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="Transform_Handler_103" routes-to="Call_HandleError_Transform_Error_103">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Transform_103" routes-to="Call_Debug_SoapXslt_103">
            <cc:steps>
                <cc:xslt-plus id="WriteSoap" input="message" url="@{props['inBuildRequestPathToXsltFile']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Transform_Handler_103"/>
        </cc:async-mediation>
        <cc:async-mediation id="PreparePropertyInput_103" routes-to="Transform_103">
            <cc:steps>
                <cc:write id="PrimeMessage">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;Root/></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Property_103" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleBuildRequestValidationError_103">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Property_103" routes-to="PreparePropertyInput_103">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>propname = props['inBuildRequestDataLocationId'];&#xD;
props['localIsValueDefined'] = context.containsProperty(propname);&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (context.getProperty(propname) instanceof java.util.Map) &amp;&amp; !(((java.util.Map)(context.getProperty(propname))).isEmpty());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10304" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, a context property named [@{props.inBuildRequestDataLocationId}] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="10305" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, the referenced context property named [@{props.inBuildRequestDataLocationId}] was not an instance of a java.util.Map, or that Map was empty.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Property_103"/>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareVariableInput_103" routes-to="Transform_103">
            <cc:steps>
                <cc:eval id="PrimeMessage">
                    <cc:expression>varname = props['inBuildRequestDataLocationId'];&#xD;
parts[0] = vars[varname].source;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Variable_103" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleBuildRequestValidationError_103">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Variable_103" routes-to="PrepareVariableInput_103">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>varname = props['inBuildRequestDataLocationId'];&#xD;
props['localIsValueDefined'] = (vars.isVariable(varname)) &amp;&amp; (vars[varname] != null);&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (vars[varname].isXml());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10302" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, a message variable named [@{props.inBuildRequestDataLocationId}] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="10303" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, the referenced message variable named [@{props.inBuildRequestDataLocationId}] was not valid XML data.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Variable_103"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Message_103" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleBuildRequestValidationError_103">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Message_103" routes-to="Transform_103">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>props['localIsValueDefined'] = parts[0] != empty;&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (parts[0].isXml());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10300" failure-message="Message part[0] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="10301" failure-message="Message part[0] was not valid XML data.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Message_103"/>
        </cc:async-mediation>
        <cc:route id="RouteInputSource_103">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inBuildRequestDataLocation'].trim().toLowerCase() == 'message'" route="Message"/>
                <cc:choose-route expression="props['inBuildRequestDataLocation'].trim().toLowerCase() == 'variable'" route="Variable"/>
                <cc:choose-route expression="true" route="Property"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Message" routes-to="Validation_Message_103"/>
            <cc:sub-route name="Variable" routes-to="Validation_Variable_103"/>
            <cc:sub-route name="Property" routes-to="Validation_Property_103"/>
        </cc:route>
        <cc:local-in id="BuildRequest_103" routes-to="RouteInputSource_103">
            <cc:parameter default="props['inApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter default="props['inBuildRequestPathToXsltFile']" documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;." name="inBuildRequestPathToXsltFile" required="true" type="string"/>
            <cc:parameter default="props['inBuildRequestDataLocation']" documentation="The java.util.Map instance that holds the key/value pairs of values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapVariableName.  The transform will define pre-established keys for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inBuildRequestDataLocation" required="false" type="string"/>
            <cc:parameter default="context.containsProperty('inBuildRequestDataLocationId') ? props['inBuildRequestDataLocationId'] : null" documentation="The name of the context variable that holds the data values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapPropertyName.  The XML stored in the variable must be compatible with the XSLT provided on inPathToXsltFile.  See aUnit tests for a generic example of a multi-iteration, multi-variable example." name="inBuildRequestDataLocationId" required="false" type="string"/>
            <cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="props['inIsAbortOnError']" name="inIsAbortOnError" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_HandleError_Validation_Error_103" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Validation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while validating parameters for a SOAP service call.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_103'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/><cc:set name="inLogTarget" value="'primary'"/></cc:local-out>
        <cc:async-mediation id="Validation_Handler_103" routes-to="Call_HandleError_Validation_Error_103">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="HandleBuildRequestValidationError_103" routes-to="Validation_Handler_103"/>
        <cc:local-out id="Call_CreateLogEntry_MissingVersion_Warn_121" store-message="none" execute-when="props['sskVersion'] == empty" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry"><cc:set name="inLogMessage" value="'Missing SSK Version Number'"/><cc:set name="inLogMessageDetail" value="'The SSK version number is held in the &quot;sskStudioStarterKitVersion&quot; property and read from the WSAR-INF/ws-application.xml file.  This value provides important insights to Workday in managing the Integration Cloud and should be left in Studio CLAR file at all times.'"/><cc:set name="inLogLevel" value="'warn'"/><cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_MissingVersion_Warn_121'"/><cc:set name="inExtraSupportData" value="'Either the WSAR-INF/ws-application.xml file has been removed/modified, or MVEL code in SetConstantValues@Initialize has been removed/modified.  Please restore this code to enable version identification.'"/></cc:local-out>
        <cc:async-mediation id="Initialize_109" routes-to="TopLevelErrorTrap_109" continue-after-error="rewind" handle-downstream-errors="false">
            <cc:steps>
                <cc:custom id="InitializeCoreSSK" ref="SSK109InitializeCore"/>
                <cc:eval id="StaticAnalysisExemptions">
                    <cc:expression>// Add other local-in names to the list that you may be using as dynamic endpoints.  For example, if you have a SSK Component that you're using on the inParallelPageProcessorEndpoint parameter of SSK-104.&#xD;
props['sskStaticCodeAnalysisExemptionList'].add('Main');</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="PIM_InitializationFailed_109"/>
        </cc:async-mediation>
        <cc:local-out id="PIM_InitializationFailed_109" store-message="none" endpoint="vm://wcc/PutIntegrationMessage"><cc:set name="is.message.severity" value="'FATAL'"/><cc:set name="is.message.summary" value="context.exception == empty ? 'Failed to initialize SSK Framework configuration' : context.exception.message"/><cc:set name="is.message.detail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/></cc:local-out>
        <cc:async-mediation id="UpdatePrimaryLogTracking_142" routes-to="Call_StoreLogPrimary_142">
            <cc:steps>
                <cc:eval id="UpdateLogCounts">
                    <cc:expression>com.workday.custom.int006.ssk142.GeneralCloudLogHelper.updateLogCounts(context, 'primary');</cc:expression>
					</cc:eval></cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="UpdateSecondaryLogTracking_142" routes-to="Call_StoreLogSecondary_142">
            <cc:steps>
                <cc:eval id="UpdateLogCounts">
                    <cc:expression>com.workday.custom.int006.ssk142.GeneralCloudLogHelper.updateLogCounts(context, 'secondary');</cc:expression>
					</cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Teardown_120">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>isCleanUp = (props.inIsInvokedByHandleError &amp;&amp; context.isAbort()) || (!props.inIsInvokedByHandleError);</cc:expression>
                    <cc:expression>if (isCleanUp) {&#xD;
	foreach (propname : ['localRestUrl','localIsUseBatch','localIsDataJson','localRecordCount']) {
		context.removeProperty(propname);
	}&#xD;
}</cc:expression>
                    <cc:expression>if (isCleanUp) {&#xD;
	foreach (varname : ['localCountResult120']) {&#xD;
		vars[varname] = null;&#xD;
	}&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_120" routes-to="Teardown_120"><cc:parameter default="true" name="inIsInvokedByHandleError" required="true" type="boolean"/></cc:local-in>
        <cc:local-out id="Call_Debug_Result_120" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Results_120" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="props['inCustomObjectServiceAlias'] # '__Response'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_Results_Error_120" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the RaaS results from the message rootpart to variable globalRaaSResults.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_120'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="Results_120" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars[props.inReturnResults] = parts[0].source;</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Results_Error_120"/>
        </cc:async-mediation>
        <cc:workday-out-rest id="CallCustomObjectAPI_120" store-message="none" routes-response-to="Call_Debug_Result_120" extra-path="@{props['localRestUrl']}" method="@{props['inHttpMethod']}"/>
        <cc:local-out id="Call_HandleError_CallService_Error_120" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Non-Effective Dated Custom Object Execution Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while updating the non-effective dated custom object for the '# props['inCustomObjectServiceAlias'] #' custom object alias.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_120'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="CallNonEffectiveDatedRequest_Catch_120" routes-to="CallCustomObjectAPI_120" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CallService_Error_120"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_Request_120" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_Debug_URL_120" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="props['inCustomObjectServiceAlias'] # '__Request'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_BuildRequestFromXmlAndXsd_120" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Generate JSON From XSD Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while generating JSON from XML and XSD.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_120'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsdFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsdFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsdFile'], '/') :&#xD;&#xA;&#x9;props['inPathToXsdFile']"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="BuildRequestFromXmlAndXsd_120" execute-steps-when="props['inPathToXsdFile'] != empty">
            <cc:steps>
                <cc:xml-to-json id="XmlToJson" output-mimetype="application/json" schema-url="@{props['inPathToXsdFile']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_BuildRequestFromXmlAndXsd_120"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_BuildRequestFromXmlAndXslt_120" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Generate JSON From XSLT Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while generating JSON from XML and XSLT.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_120'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xD;&#xA;&#x9;props['inPathToXsltFile']"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="BuildRequestFromXmlAndXslt_120" routes-to="BuildRequestFromXmlAndXsd_120" execute-steps-when="props['inPathToXsltFile'] != empty">
            <cc:steps>
                <cc:xslt-plus id="CountRecords" output="variable" output-mimetype="text/xml" output-variable="localCountResult120" url="xslt/ssk120/SSK120_CountRecords.xsl"/>
                <cc:eval id="SetValue">
                    <cc:expression>props['localRecordCount'] = vars['localCountResult120'].xstream('/totalRecords'); </cc:expression>
                </cc:eval>
                <cc:xslt-plus id="XsltPlus" output-mimetype="application/json" url="@{props['inPathToXsltFile']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_BuildRequestFromXmlAndXslt_120"/>
        </cc:async-mediation>
        <cc:splitter id="BatchSplitter_120">
            <cc:sub-route name="ProcessBatch" routes-to="Call_TransformXML_Batch_120"/>
            <cc:xml-stream-splitter xpath="/Blocks/*"/>
        </cc:splitter>
        <cc:local-out id="Call_HandleError_BuildBlockMessage_Error_120" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'XSLT3 Block Splitter Error'"/>
            <cc:set name="inLogMessageDetail" value="'The XML data was unable to be split using the XSLT Block Splitter'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'XsltBlockSplitter-SplitXml'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_120'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="BuildBlockMessage_120" routes-to="BatchSplitter_120" handle-downstream-errors="true">
            <cc:steps>
                <cc:xslt-plus id="SplitXML" url="xslt/ssk120/SSK120_XsltBlockSplit.xsl"/>
                <cc:eval id="UpdateURL">
                    <cc:expression>if (org.apache.commons.lang3.StringUtils.contains(props.localRestUrl, '?')) {&#xD;
	props['localRestUrl'] = props['localRestUrl'] # '&amp;bulk=true';&#xD;
} else {&#xD;
	props['localRestUrl'] = props['localRestUrl'] # '?bulk=true';&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_BuildBlockMessage_Error_120"/>
        </cc:async-mediation>
        <cc:route id="RouteBatch_120">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['localIsUseBatch']" route="Batch"/>
                <cc:choose-route expression="true" route="Single"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Batch" routes-to="BuildBlockMessage_120"/>
            <cc:sub-route name="Single" routes-to="Call_TransformXML_Single_120"/>
        </cc:route>
        <cc:route id="RouteSource_120">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['localIsDataJson']" route="JSON"/>
                <cc:choose-route expression="true" route="XML"/>
            </cc:mvel-strategy>
            <cc:sub-route name="JSON" routes-to="Call_ProcessJSON_120"/>
            <cc:sub-route name="XML" routes-to="Call_ProcessXML_120"/>
        </cc:route>
        <cc:async-mediation id="PrepareData_120" routes-to="RouteSource_120" execute-steps-when="props['inParameterDataLocation'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveVarToMsg">
                    <cc:expression>parts[0] = vars[props.inParameterDataLocation].source;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Error_120" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Custom Object Preparation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a Custom Object call.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_120'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
        <cc:set name="inTargetType" value="'properties'"/><cc:set name="inTargetName" value="'sskDebugPropertyList'"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_120" routes-to="PrepareData_120" continue-after-error="rewind" handle-downstream-errors="true" routes-response-to="Call_Finally_120">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localIsUseBatch'] = false;</cc:expression>
                    <cc:expression>props['localIsDataJson'] = ((props['inParameterDataLocation'] == 'message') &amp;&amp; (parts[0].getMimeType().toLowerCase().startsWith('application/json'))) || (context.variables.isVariable(props.inParameterDataLocation) &amp;&amp; (vars[props.inParameterDataLocation].mimeType.toLowerCase().startsWith('application/json')));</cc:expression>
                </cc:eval>
                <cc:eval id="BuildURL">
                    <cc:expression>props['localRestUrl'] = intsys.customObjectService.getExtrapath(props.inCustomObjectServiceAlias);</cc:expression>
                    <cc:expression>if (props['inHttpMethod'] == 'POST' &amp;&amp; props['inUpdateIfExists']) {&#xD;
	props['localRestUrl'] = props['localRestUrl'] # '?updateIfExists=true';&#xD;
}</cc:expression>
                </cc:eval>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Error_120"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_120" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_120"><cc:set name="inIsInvokedByHandleError" value="false"/></cc:local-out>
        <cc:local-in id="WriteNonEffectiveDatedCustomObject" routes-to="InitializeAndFinalize_120" access="public" icon="icons/WriteNonEffectiveDatedCustomObject.png">
            <cc:parameter documentation="The Custom Object Service configuration representing the non-effective dated custom object to update.  If passed, this will be a non-effective dated custom object that will be updated via a REST POST" name="inCustomObjectServiceAlias" required="true" type="string"/>
            <cc:parameter default="'POST'" documentation="This parameter allows you to control the behavior of the component with respect to the object's data.  One of 3 methods are supported:  PUT or POST.  Using &quot;PUT&quot; will result in an update to an existing Custom Object of only the fields you provide.  Using &quot;POST&quot; will create a new instance of the Custom Object.  If you also set inUpdateIfExists to &quot;true&quot;, then the API will update the instance if it already exists.  In this case for updates though, there is no partial update - you must provide all fields as any omitted field will be nullified.  DELETE operations are not supported by this component." name="inHttpMethod" required="true" type="string" validation="['PUT','POST'] contains props['inHttpMethod'].trim().toUpperCase()"/><cc:parameter default="false" documentation="Setting for updateIfExists parameter for Non-Effective Dated Custom Objects when using the HTTP &quot;POST&quot; method.  Note this is only implicitly effective for single-instance objects.  For multi-instance objects, a new instance will be created unless the specific instance id of the custom object record is also included in the json body data." name="inUpdateIfExists" required="false" type="boolean" validation="if (props['inHttpMethod'] != 'POST') {&#xD;&#xA;&#x9;props['inUpdateIfExists'] == empty&#xD;&#xA;}"/>
            <cc:parameter documentation="Where the data for the Non-Effective Dated Custom Object request can be found.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inParameterDataLocation" required="true" type="string" validation="(props['inParameterDataLocation'] == 'message' &amp;&amp;&#xD;&#xA;&#x9;(parts[0].getMimeType().toLowerCase().startsWith('application/json') ||&#xD;&#xA;&#x9;(parts[0].isXml() &amp;&amp; parts[0].getMimeType().toLowerCase().startsWith('text/xml')))) || &#xD;&#xA;(context.variables.isVariable(props.inParameterDataLocation) &amp;&amp;&#xD;&#xA;&#x9;(vars[props.inParameterDataLocation].mimeType.toLowerCase().startsWith('application/json') ||&#xD;&#xA;&#x9;(vars[props.inParameterDataLocation].isXml() &amp;&amp; vars[props.inParameterDataLocation].mimeType.toLowerCase().startsWith('text/xml'))))"/>
            <cc:parameter documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the JSON request, e.g. &quot;xslt/GenerateJson.xslt&quot;." name="inPathToXsltFile" required="props['inPathToXsdFile'] == empty &amp;&amp; &#xD;&#xA;&#x9;((props['inParameterDataLocation'] == 'message' &amp;&amp; &#xD;&#xA;&#x9;&#x9;parts[0].isXml() &amp;&amp;&#xD;&#xA;&#x9;&#x9;parts[0].getMimeType().toLowerCase().startsWith('text/xml')) || &#xD;&#xA;&#x9;(props['inParameterDataLocation'] != 'message' &amp;&amp; &#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].isXml() &amp;&amp;&#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].mimeType.toLowerCase().startsWith('text/xml')))" type="string" validation="props['inPathToXsltFile'] == empty ||&#xD;&#xA;&#x9;(props['inPathToXsdFile'] == empty &amp;&amp;&#xD;&#xA;&#x9;((props['inParameterDataLocation'] == 'message' &amp;&amp; &#xD;&#xA;&#x9;&#x9;parts[0].isXml() &amp;&amp;&#xD;&#xA;&#x9;&#x9;parts[0].getMimeType().toLowerCase().startsWith('text/xml')) || &#xD;&#xA;&#x9;(props['inParameterDataLocation'] != 'message' &amp;&amp; &#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].isXml() &amp;&amp;&#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].mimeType.toLowerCase().startsWith('text/xml'))))"/>
            <cc:parameter documentation="The file path relative to /ws/WSAR-INF for the XSD file that will generate the JSON request, e.g. &quot;xslt/GenerateJson.xsd&quot;." name="inPathToXsdFile" required="props['inPathToXsltFile'] == empty &amp;&amp; &#xD;&#xA;&#x9;((props['inParameterDataLocation'] == 'message' &amp;&amp; &#xD;&#xA;&#x9;&#x9;parts[0].isXml() &amp;&amp; &#xD;&#xA;&#x9;&#x9;parts[0].getMimeType().toLowerCase().startsWith('text/xml')) || &#xD;&#xA;&#x9;(props['inParameterDataLocation'] != 'message' &amp;&amp; &#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].isXml() &amp;&amp;&#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].mimeType.toLowerCase().startsWith('text/xml')))" type="string" validation="props['inPathToXsdFile'] == empty ||&#xD;&#xA;&#x9;(props['inPathToXsltFile'] == empty &amp;&amp;&#xD;&#xA;&#x9;((props['inParameterDataLocation'] == 'message' &amp;&amp;&#xD;&#xA;&#x9;&#x9;parts[0].isXml() &amp;&amp; &#xD;&#xA;&#x9;&#x9;parts[0].getMimeType().toLowerCase().startsWith('text/xml')) || &#xD;&#xA;&#x9;(props['inParameterDataLocation'] != 'message' &amp;&amp; &#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].isXml() &amp;&amp;&#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].mimeType.toLowerCase().startsWith('text/xml'))))"/>
            <cc:parameter default="'message'" documentation="How the Custom Object Service results are returned to the caller, either on the message if the value is 'message', or in the 'globalCustomObjectResults' variable if the value is 'variable', which is the default." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="props['sskIsValidationMode']" documentation="Controls whether or not the Custom Object Service request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="false" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-in id="ProcessXML_120" routes-to="InitializeXml_120"/>
        <cc:local-in id="ProcessJSON_120" routes-to="Call_Debug_Request_120"/>
        <cc:local-out id="Call_ProcessJSON_120" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/ProcessJSON_120"/>
        <cc:local-out id="Call_ProcessXML_120" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/ProcessXML_120"/>
        <cc:local-out id="Call_ProcessJSON_Batch_120" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/ProcessJSON_120"/>
        <cc:local-in id="TransformXML_120" routes-to="BuildRequestFromXmlAndXslt_120"/>
        <cc:async-mediation id="InitializeXml_120" routes-to="RouteBatch_120">
            <cc:steps>
                <cc:xslt-plus id="CountRecords" output="variable" output-mimetype="text/xml" output-variable="localCountResult120" url="xslt/ssk120/SSK120_CountRecords.xsl"/>
                <cc:eval id="SetValue">
                    <cc:expression>props['localRecordCount'] = vars['localCountResult120'].xstream('/totalRecords'); &#xD;
props['localIsUseBatch'] = props['localRecordCount'] > 1;</cc:expression>
                    <cc:expression>if (props['localIsUseBatch']) {&#xD;
	props['localBlockSize'] = (props.containsKey('atf.aunit.test') &amp;&amp; props['atf.aunit.test']) ? 2 : 100;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_TransformXML_Single_120" store-message="none" routes-response-to="Call_ProcessJSON_Single_120" endpoint="vm://INT006_Greenhouse_Inbound/TransformXML_120"/>
        <cc:local-out id="Call_TransformXML_Batch_120" store-message="none" routes-response-to="Call_ProcessJSON_Batch_120" endpoint="vm://INT006_Greenhouse_Inbound/TransformXML_120"/>
        <cc:local-out id="Call_ProcessJSON_Single_120" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/ProcessJSON_120"/>
        <cc:local-out id="Call_Debug_URL_120" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallNonEffectiveDatedRequest_Catch_120" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localRestUrl'"/>
            
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_PIE_108" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError"><cc:set name="inLogMessage" value="'Progress Update Error'"/><cc:set name="inLogMessageDetail" value="'An error occurred while attempting to update the integration event progress.  Since this is not a critical action, processing of the integration will continue.  Potential error reponse data on the message will be output to the debug log file.'"/><cc:set name="inLogLevel" value="'warn'"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/><cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/><cc:set name="inIsAbortOnError" value="false"/><cc:set name="inIsResetError" value="false"/><cc:set name="inIncludeDebugOutput" value="true"/><cc:set name="inTargetType" value="'message'"/><cc:set name="inEntityName" value="'EventProgress__Error'"/><cc:set name="inLogTarget" value="'primary'"/></cc:local-out>
        <cc:async-mediation id="ErrorTrap_108" routes-to="PIM_108" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_PIE_108"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_ThreadedResultOutput_Error_102" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Storage Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while storing data to the Integration Event.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="ThreadedResultOutput_102" execute-steps-when="props['inIsChildThreadContext'] &amp;&amp; props['inSaveResultsToIntegrationEvent']">
            <cc:steps>
                <cc:store id="StoreContent" output="variable" output-mimetype="text/xml" output-variable="localStoreResult_102" input="message" createDocumentReference="true" expiresIn="@{props['inDocumentRetentionPeriod']}" title="@{'RAAS-Results__' # props['inReportServiceAlias']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_ThreadedResultOutput_Error_102"/>
        </cc:async-mediation>
        <cc:route id="Threading_141">
            <cc:mvel-strategy>
                <cc:choose-route expression="!props['inIsChildThreadContext']" route="MainThread"/>
                <cc:choose-route expression="true" route="ChildThread"/>
            </cc:mvel-strategy>
            <cc:sub-route name="MainThread" routes-to="Call_CreateLogEntry_141"/>
            <cc:sub-route name="ChildThread" routes-to="Call_CreateLogEntryOnThread_141"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntryOnThread_141" store-message="none" routes-response-to="Call_Debug_Child_141" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread"><cc:set name="inLogMessage" value="props['inLogMessage']"/><cc:set name="inLogMessageDetail" value="props['inLogMessageDetail']"/><cc:set name="inLogReferenceId" value="props['inLogReferenceId']"/><cc:set name="inLogLevel" value="props['inLogLevel']"/><cc:set name="inExtraLocalIn" value="props['inExtraLocalIn']"/><cc:set name="inExtraRecordNumber" value="props['inExtraRecordNumber']"/><cc:set name="inExtraSupportData" value="props['inExtraSupportData']"/><cc:set name="inExtraErrorCode" value="props['inExtraSupportData']"/></cc:local-out>
        <cc:local-out id="Call_LogXsltMessages_107" store-message="none" routes-response-to="FinalizeResults" endpoint="vm://INT006_Greenhouse_Inbound/CloudLogXSLTMessages"><cc:set name="inMessages" value="props['xsltstep.messages']"/><cc:set name="inIsClearMessages" value="true"/><cc:set name="inMinLogLevel" value="'debug'"/><cc:set name="inLogTarget" value="props['inLogTargetForXsltMessages']"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_CreateThreadLogEntry_Info_102" store-message="none" execute-when="props['inIsChildThreadContext']" routes-response-to="ComposeRequest_102" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread"><cc:set name="inLogMessage" value="'Executing reports-as-a-service for the '# props['inReportServiceAlias'] #' report alias using SOAP.'"/><cc:set name="inLogMessageDetail" value="'The URL constructed including querystring parameters exceed the maximum URL length for RESTful RaaS calls of 16000 Bytes.  Switching to use SOAP as protocol.'"/><cc:set name="inLogLevel" value="'info'"/></cc:local-out>
        <cc:async-mediation id="Teardown_128">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                        <cc:remove-header name="X-Tenant"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localPollURI','localIsContinueLoop','localMessageId','localMessageURI','localMessageTimestamp']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_128" routes-to="Teardown_128"/>
        <cc:local-out id="Call_CreateLogEntry_MessageDelete_LogInfo_128" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Message Deleted'"/>
            <cc:set name="inLogMessageDetail" value="'The read message was deleted from the queue.  See the Reference ID for the message filename in the debug archive.'"/>
            <cc:set name="inLogReferenceId" value="props['outEntityName']"/>
            <cc:set name="inLogLevel" value="'info'"/>
            <cc:set name="inExtraLocalIn" value="'CallQueue_Delete_128'"/>
            <cc:set name="inExtraRecordNumber" value="props['localMessageId']"/>
            <cc:set name="inExtraSupportData" value="'Message Index = ' # props['localMessageId'] # ';  Message Enqueued On = ' # props['localMessageTimestamp'] # ';  Message URI = ' # props['localMessageURI']"/>
            
        </cc:local-out>
        <cc:local-out id="Call_Debug_REST_DeleteResponse_128" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_CreateLogEntry_MessageDelete_LogInfo_128" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__QueueDelete' # props['localMessageId']"/>
        </cc:local-out>
        <cc:http-out id="CallQueue_Delete_128" store-message="none" routes-response-to="Call_Debug_REST_DeleteResponse_128" endpoint="@{props['localMessageURI']}" http-method="DELETE">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_HandleError_CatchDequeueErrors_128" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Delete Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while deleting the next message from the Message Queue.  Processing will attempt to continue, but full deletion of all queue messages cannot be guaranteed.  An additional Administrator event may be required after the cause of this error has been resolved.'"/>
            <cc:set name="inLogReferenceId" value="props['localMessageURI']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_128'"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="true"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localMessageURI'"/>
        </cc:local-out>
        <cc:async-mediation id="CatchDequeueErrors_128" routes-to="CallQueue_Delete_128" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CatchDequeueErrors_128"/>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_MessageRead_LogInfo_128" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Message Retrieved'"/>
            <cc:set name="inLogMessageDetail" value="'A message was read from the queue.  The contents of the message were saved to the debug archive for future reference/audit.  See the Reference ID for the message filename in that archive.'"/>
            <cc:set name="inLogReferenceId" value="props['outEntityName']"/>
            <cc:set name="inLogLevel" value="'info'"/>
            <cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_MessageRead_LogInfo_128'"/>
            <cc:set name="inExtraRecordNumber" value="props['localMessageId']"/>
            <cc:set name="inExtraSupportData" value="'Message Index = ' # props['localMessageId'] # ';  Message Enqueued On = ' # props['localMessageTimestamp'] # ';  Message URI = ' # props['localMessageURI']"/>
            
        </cc:local-out>
        <cc:local-out id="Call_Debug_REST_ReadResponse_128" store-message="none" routes-response-to="Call_CreateLogEntry_MessageRead_LogInfo_128" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="props['localMessageURI']"/>
        </cc:local-out>
        <cc:http-out id="CallQueue_Read_128" store-message="none" routes-response-to="Call_Debug_REST_ReadResponse_128" endpoint="@{props['localMessageURI']}" http-method="GET">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_Read_128" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallQueue_Read_128" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localMessageURI'"/>
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_CatchReadErrors_128" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Read Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while reading the next message from the Message Queue.  Processing will attempt to continue, but full deletion of all queue messages cannot be guaranteed.  An additional Administrator event may be required after the cause of this error has been resolved.'"/>
            <cc:set name="inLogReferenceId" value="props['localMessageURI']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_128'"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="true"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:async-mediation id="CatchReadErrors_128" routes-to="Call_Debug_REST_Read_128" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CatchReadErrors_128"/>
        </cc:async-mediation>
        <cc:local-in id="LogMessage_128" routes-to="CatchReadErrors_128">
            
            
            
        </cc:local-in>
        <cc:local-out id="Call_LogMessage_128" store-message="none" execute-when="props['inIsLogMessageBeforeDelete']" routes-response-to="Call_DeleteMessage_128" endpoint="vm://INT006_Greenhouse_Inbound/LogMessage_128">
            
            
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_CatchLocalOutErrors_128" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while parsing the poll result to begin removal of the associated message.  Without message information, this message cannot be removed, and complete deletion of all messages from the queue cannot be guaranteed.  See Support Data for more information.'"/>
            <cc:set name="inLogReferenceId" value="props['inMessageURI']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_128'"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="true"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:async-mediation id="CatchLocalOutErrors_128" routes-to="Call_LogMessage_128" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['localMessageId'] = parts[0].xpath('/*:message/*:index');&#xD;
props['localMessageURI'] = props['inEndpoint'] # (parts[0].xpath('/*:message/*:uri'));&#xD;
props['localMessageTimestamp'] = parts[0].xpath('/*:message/*:uploaded');</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CatchLocalOutErrors_128"/>
        </cc:async-mediation>
        <cc:splitter id="SplitMessages_128" no-split-message-error="false">
            <cc:sub-route name="ProcessMessage" routes-to="CatchLocalOutErrors_128"/>
            <cc:xml-stream-splitter xpath="/*/*"/>
        </cc:splitter>
        <cc:local-out id="Call_Debug_REST_PollResponse_128" store-message="none" execute-when="props['inDebugMode']" routes-response-to="EvaluateQueue_128" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__QueuePoll'"/>
        </cc:local-out>
        <cc:http-out id="CallQueue_128" store-message="none" routes-response-to="Call_Debug_REST_PollResponse_128" endpoint="@{props['localPollURI']}" http-method="GET">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_Poll_128" store-message="none" execute-when="props['inDebugMode']" routes-response-to="AllMessages_128" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localPollURI'"/>
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_128" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Delete Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while deleting the next message from the Message Queue.'"/>
            <cc:set name="inLogReferenceId" value="props['inMessageURI']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_128'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_128" routes-to="Call_Debug_REST_Poll_128" routes-response-to="Call_Finally_128">
            <cc:request-steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="X-Tenant" value="@{props['cc.customer.id']}"/>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="SetValues">
                    <cc:expression>props['localPollURI'] = props['inEndpoint'] # '/ccx/wd-queue/' # props['inQueueName'] # '/fresh?maxMessages=999'</cc:expression>
                    <cc:expression>props['localIsContinueLoop'] = true;</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_128"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_128" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_128"/>
        <cc:local-in id="PurgeQueue" routes-to="InitializeAndFinalize_128" icon="icons/PurgeQueue.png">
            <cc:parameter default="props['sskQueueEndpoint']" documentation="The tenant endpoint at which the Message Queue REST API may be found." name="inEndpoint" required="true" type="string"/>
            <cc:parameter default="props['sskQueueName']" documentation="The name of the queue for which to return the polling URI." name="inQueueName" required="true" type="string"/>
            <cc:parameter default="props['sskQueueUsername']" documentation="The username with which to authenticate to the tenant endpoint." name="inUsername" required="true" type="string"/>
            <cc:parameter default="props['sskQueuePassword']" documentation="The password with which to authenticate to the tenant endpoint." name="inPassword" required="true" type="string"/>
            <cc:parameter default="props['sskIsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/><cc:parameter default="false" documentation="If true, then the message content will be written out to the debug log prior to deletion.  Otherwise, the message will simply be dequeued." name="inIsLogMessageBeforeDelete" required="true" type="boolean"/>
        </cc:local-in>
        <cc:async-mediation id="Teardown_127">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                        <cc:remove-header name="X-Tenant"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localURI']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_127" routes-to="Teardown_127"/>
        <cc:local-out id="Call_CreateLogEntry_MessageDelete_127" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Message Deleted'"/>
            <cc:set name="inLogMessageDetail" value="'The message was deleted from the queue.  See the Reference ID for the message filename in the debug archive.'"/>
            <cc:set name="inLogReferenceId" value="props['outEntityName']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_MessageDelete_127'"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_REST_DeleteResponse_127" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_CreateLogEntry_MessageDelete_127" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__QueueDelete'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:http-out id="CallQueueDelete_127" store-message="none" routes-response-to="Call_Debug_REST_DeleteResponse_127" endpoint="@{props['localURI']}" http-method="DELETE">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_Delete_127" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallQueueDelete_127" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_127" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Delete Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while deleting the next message from the Message Queue.'"/>
            <cc:set name="inLogReferenceId" value="props['inMessageURI']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_127'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_127" routes-to="Call_Debug_REST_Delete_127" routes-response-to="Call_Finally_127">
            <cc:request-steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="X-Tenant" value="@{props['cc.customer.id']}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="SetValues">
                    <cc:expression>props['localURI'] = props['inEndpoint'] # props['inMessageURI']</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_127"/>
        </cc:sync-mediation>
        <cc:local-in id="DeleteMessageFromQueue" routes-to="InitializeAndFinalize_127" icon="icons/DeleteMessageFromQueue.png">
            <cc:parameter default="props['sskQueueEndpoint']" documentation="The tenant endpoint at which the Message Queue REST API may be found." name="inEndpoint" required="true" type="string"/>
            <cc:parameter default="props['sskQueueName']" documentation="The name of the queue for which to return the polling URI." name="inQueueName" required="true" type="string"/>
            <cc:parameter default="props['sskQueueUsername']" documentation="The username with which to authenticate to the tenant endpoint." name="inUsername" required="true" type="string"/>
            <cc:parameter default="props['sskQueuePassword']" documentation="The password with which to authenticate to the tenant endpoint." name="inPassword" required="true" type="string"/>
            <cc:parameter default="props['outMessageURI']" name="inMessageURI" required="true" type="string"/>
            
            <cc:parameter default="props['sskIsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="'message'" documentation="How the REST response is returned to the caller.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        </cc:local-in>
        <cc:async-mediation id="Teardown_126">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                        <cc:remove-header name="X-Tenant"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localURI','localIsPreserveMessage']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['localMessageCache126']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
                <cc:eval id="ReduceDebug">
                    <cc:expression>if (context.containsProperty('sskDebugPropertyList')) {&#xD;
	props['sskDebugPropertyList'].remove('inEndpoint');&#xD;
	props['sskDebugPropertyList'].remove('inQueueName');&#xD;
	props['sskDebugPropertyList'].remove('inUsername');&#xD;
	props['sskDebugPropertyList'].remove('inPassword');&#xD;
	props['sskDebugPropertyList'].remove('inValidateOnly');&#xD;
	props['sskDebugPropertyList'].remove('inDebugMode');&#xD;
	props['sskDebugPropertyList'].remove('inIsAbortOnError');&#xD;
	props['sskDebugPropertyList'].remove('inDataSource');&#xD;
	props['sskDebugPropertyList'].remove('inXsltSplitDataToMessages');&#xD;
	props['sskDebugPropertyList'].remove('inNamespaceSplitDataToMessages');&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="RestoreMessage_126" routes-to="Teardown_126" execute-steps-when="props['localIsPreserveMessage'] &amp;&amp; vars['localMessageCache126'] != null">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output="message" input="variable" input-variable="localMessageCache126"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_126" routes-to="RestoreMessage_126"/>
        <cc:local-out id="Call_Debug_REST_EnqueueResponse_126" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__QueuePost'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:http-out id="CallQueue_126" store-message="none" routes-response-to="Call_Debug_REST_EnqueueResponse_126" endpoint="@{props['localURI']}" http-method="POST">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_Enqueue_126" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallQueue_126" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_EnqueueMessage_126" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'An error occurred enqueuing a batch request.  Normal execution will attempt to continue...'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber"/>
            <cc:set name="inExtraSupportData"/>
            <cc:set name="inExtraErrorCode" value="'104'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_126'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inTargetName"/>
            <cc:set name="inEntityName"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="EnqueueMessage_Catch_126" routes-to="Call_Debug_REST_Enqueue_126" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_EnqueueMessage_126"/>
        </cc:async-mediation>
        <cc:splitter id="SplitMessages_126" no-split-message-error="false">
            <cc:sub-route name="ProcessBatch" routes-to="EnqueueMessage_Catch_126"/>
            <cc:xml-stream-splitter namespaces="@{props['inNamespaceSplitDataToMessages']}" xpath="@{props['inXsltSplitDataToMessages']}"/>
        </cc:splitter>
        <cc:route id="Route_126">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inXsltSplitDataToMessages'] != empty" route="MultipleMessages"/>
                <cc:choose-route expression="true" route="SingleMessage"/>
            </cc:mvel-strategy>
            <cc:sub-route name="MultipleMessages" routes-to="SplitMessages_126"/>
            <cc:sub-route name="SingleMessage" routes-to="EnqueueMessage_Catch_126"/>
        </cc:route>
        <cc:local-out id="Call_HandleError_PrepareData_126" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'An error occurred caching message.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_126'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'MessageRoot__to_localMessageCache126'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="PrepareData_126" routes-to="Route_126" execute-steps-when="props['localIsPreserveMessage']">
            <cc:steps>
                <cc:copy id="CopyMsgToVar" output="variable" output-variable="localMessageCache126"/>
                <cc:eval id="CopyVarToMsg">
                    <cc:expression>if (props['inDataSource'] != 'message') {&#xD;
	parts[0] = vars[props.inDataSource].source;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="Call_HandleError_PrepareData_126"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_126" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'An error occurred preparing message to be enqueued.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_126'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'properties'"/>
            <cc:set name="inTargetName" value="'globalDebugPropertyList'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_126" routes-to="PrepareData_126" routes-response-to="Call_Finally_126">
            <cc:request-steps>
                <cc:eval id="UpdateDebug">
                    <cc:expression>if (context.containsProperty('sskDebugPropertyList')) {&#xD;
	props['sskDebugPropertyList'].add('inEndpoint');&#xD;
	props['sskDebugPropertyList'].add('inQueueName');&#xD;
	props['sskDebugPropertyList'].add('inUsername');&#xD;
	props['sskDebugPropertyList'].add('inValidateOnly');&#xD;
	props['sskDebugPropertyList'].add('inDebugMode');&#xD;
	props['sskDebugPropertyList'].add('inIsAbortOnError');&#xD;
	props['sskDebugPropertyList'].add('inDataSource');&#xD;
	props['sskDebugPropertyList'].add('inXsltSplitDataToMessages');&#xD;
	props['sskDebugPropertyList'].add('inNamespaceSplitDataToMessages');&#xD;
}</cc:expression>
                </cc:eval>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="X-Tenant" value="@{props['cc.customer.id']}"/>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="InitValues">
                    <cc:expression>props['localURI'] = props['inEndpoint'] # '/ccx/wd-queue/' # props['inQueueName'];</cc:expression>
                    <cc:expression>props['localIsPreserveMessage'] = props['inDataSource'] != 'message';</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_126"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_126" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_126"/>
        <cc:local-in id="AddMessageToQueue" routes-to="InitializeAndFinalize_126" icon="icons/AddMessageToQueue.png">
            <cc:parameter default="props['sskQueueEndpoint']" documentation="The tenant endpoint at which the Message Queue REST API may be found." name="inEndpoint" required="true" type="string"/>
            <cc:parameter default="props['sskQueueName']" documentation="The name of the queue for which to return the polling URI." name="inQueueName" required="true" type="string"/>
            <cc:parameter default="props['sskQueueUsername']" documentation="The username with which to authenticate to the tenant endpoint." name="inUsername" required="true" type="string"/>
            <cc:parameter default="props['sskQueuePassword']" documentation="The password with which to authenticate to the tenant endpoint." name="inPassword" required="true" type="string"/>
            <cc:parameter default="props['sskIsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="'message'" documentation="Where the data to be written to the queue is stored.  If this is 'message', then the message root part will be used (which is default), and otherwise, it is interpreted as the name of a variable." name="inDataSource" required="true" type="string"/>
            <cc:parameter documentation="An XPath expression used against the data provided to sub-divide the set to individual messages." name="inXsltSplitDataToMessages" required="false" type="string"/>
            <cc:parameter documentation="The namespace alias and fully qualified definition for any undefined namespaces in the XPath used for splitting the data." name="inNamespaceSplitDataToMessages" required="props['inXsltSplitDataToMessages'] != empty" type="string"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
            
        </cc:local-in>
        <cc:async-mediation id="Teardown_125">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                        <cc:remove-header name="X-Tenant"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localURI']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_125" routes-to="Teardown_125"/>
        <cc:local-out id="Call_CreateLogEntry_MessageDelete_125" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Message Deleted'"/>
            <cc:set name="inLogMessageDetail" value="'The read message was deleted from the queue.  See the Reference ID for the message filename in the debug archive.'"/>
            <cc:set name="inLogReferenceId" value="props['outEntityName']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_MessageDelete_125'"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_REST_DeleteResponse_125" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_CreateLogEntry_MessageDelete_125" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__CallQueueDelete_125'"/>
        </cc:local-out>
        <cc:http-out id="CallQueueDelete_125" store-message="none" routes-response-to="Call_Debug_REST_DeleteResponse_125" endpoint="@{props['localURI']}" http-method="DELETE">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_HandleError_DequeueInit_125" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Delete Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while deleting the next message from the Message Queue.'"/>
            <cc:set name="inLogReferenceId" value="props['inMessageURI']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_125'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:async-mediation id="DequeueInit_125" routes-to="CallQueueDelete_125" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_DequeueInit_125"/>
        </cc:async-mediation>
        <cc:local-in id="Dequeue_125" routes-to="DequeueInit_125"/>
        <cc:local-out id="Call_Dequeue_125" store-message="none" execute-when="props['inIsDeleteAfterRead']" endpoint="vm://INT006_Greenhouse_Inbound/Dequeue_125" clone-request="true"/>
        <cc:async-mediation id="ReadMessage_125" routes-to="Call_Dequeue_125" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars[props.inReturnResults] = parts[0].source;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_MessageRead_125" store-message="none" execute-when="props['inDebugMode']" routes-response-to="ReadMessage_125" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Message Retrieved'"/>
            <cc:set name="inLogMessageDetail" value="'A message was read from the queue.  The contents of the message were saved to the debug archive for future reference/audit.  See the Reference ID for the message filename in that archive.'"/>
            <cc:set name="inLogReferenceId" value="props['outEntityName']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_MessageRead_125'"/>
            <cc:set name="inExtraSupportData" value="'Message Index = ' # props['inMessageId'] # ';  Message URI = ' # props['inMessageURI']"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_REST_ReadResponse_125" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_CreateLogEntry_MessageRead_125" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="props['inMessageURI']"/>
        </cc:local-out>
        <cc:http-out id="CallQueueRead_125" store-message="none" routes-response-to="Call_Debug_REST_ReadResponse_125" endpoint="@{props['localURI']}" http-method="GET">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_Read_125" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallQueueRead_125" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_125" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Read Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while reading the next message from the Message Queue.  The message has not been deleted from the queue.'"/>
            <cc:set name="inLogReferenceId" value="props['inMessageURI']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_125'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'ReadMessageFromQueue_ErrorResponse'"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_125" routes-to="Call_Debug_REST_Read_125" handle-downstream-errors="true" routes-response-to="Call_Finally_125">
            <cc:request-steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="X-Tenant" value="@{props['cc.customer.id']}"/>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="SetValues">
                    <cc:expression>props['localURI'] = props['inEndpoint'] # props['inMessageURI']</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_125"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_125" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_125"/>
        <cc:local-in id="ReadMessageFromQueue" routes-to="InitializeAndFinalize_125" icon="icons/ReadMessageFromQueue.png">
            <cc:parameter default="props['sskQueueEndpoint']" documentation="The tenant endpoint at which the Message Queue REST API may be found." name="inEndpoint" required="true" type="string"/>
            <cc:parameter default="props['sskQueueName']" documentation="The name of the queue for which to return the polling URI." name="inQueueName" required="true" type="string"/>
            <cc:parameter default="props['sskQueueUsername']" documentation="The username with which to authenticate to the tenant endpoint." name="inUsername" required="true" type="string"/>
            <cc:parameter default="props['sskQueuePassword']" documentation="The password with which to authenticate to the tenant endpoint." name="inPassword" required="true" type="string"/>
            <cc:parameter default="props['outMessageId']" name="inMessageId" required="true" type="string"/>
            <cc:parameter default="props['outMessageURI']" name="inMessageURI" required="true" type="string"/>
            
            <cc:parameter default="true" documentation="A boolean flag to indicate if the message should be removed from the queue after being read." name="inIsDeleteAfterRead" required="true" type="boolean"/>
            <cc:parameter default="props['sskIsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="'message'" documentation="How the REST response is returned to the caller.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found.  " name="inReturnResults" required="true" type="string"/>
        </cc:local-in>
        <cc:async-mediation id="Teardown_124">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="X-Tenant"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localURI']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_124" routes-to="Teardown_124"/>
        <cc:async-mediation id="QueueResults_124">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>if (parts[0].xpathB('/*:messages/*:message')) {&#xD;
	props['outMessageId'] = parts[0].xpath('/*:messages/*:message[1]/*:index');&#xD;
	props['outMessageURI'] = parts[0].xpath('/*:messages/*:message[1]/*:uri');&#xD;
} else {&#xD;
	props['outMessageId'] = '';&#xD;
	props['outMessageURI'] = '';&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_REST_PollResponse_124" store-message="none" execute-when="props['inDebugMode']" routes-response-to="QueueResults_124" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__QueuePoll'"/>
        </cc:local-out>
        <cc:http-out id="CallQueue_124" store-message="none" routes-response-to="Call_Debug_REST_PollResponse_124" endpoint="@{props['localURI']}" http-method="GET">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_Poll_124" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallQueue_124" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPollURI'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_124" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Query Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while querying the Message Queue for statistics.  Without queue information, the integration processing cannot safely continue and will be terminated.  See Support Data for more information.'"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="'105'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_124'"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['globalIsDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'PollQueue_ErrorResponse'"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_124" routes-to="Call_Debug_REST_Poll_124" handle-downstream-errors="true" routes-response-to="Call_Finally_124">
            <cc:request-steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="X-Tenant" value="@{props['cc.customer.id']}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="SetValues">
                    <cc:expression>props['localURI'] = props['inEndpoint'] # props['inPollURI'];&#xD;
if (props['inBatchSize'] != empty) {&#xD;
	props['localURI'] = props['localURI'] # '?maxMessages=' # props['inBatchSize'];&#xD;
}</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_124"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_124" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_124"/>
        <cc:local-in id="PollQueue" routes-to="InitializeAndFinalize_124" icon="icons/PollQueue.png">
            <cc:parameter default="props['sskQueueEndpoint']" documentation="The tenant endpoint at which the Message Queue REST API may be found." name="inEndpoint" required="true" type="string"/>
            <cc:parameter default="props['outPollURI']" documentation="The polling URI for the queue.  Parameter is defaulted to the output parameter from GetQueues." name="inPollURI" required="true" type="string"/>
            <cc:parameter documentation="Determines the number of messages that will be returned if there are more messages in the queue than the default batch size of 100.  If not defined, then the default behavior is applied and up to the default number of messages is returned." name="inBatchSize" required="false" type="string"/><cc:parameter default="props['sskQueueUsername']" documentation="The username with which to authenticate to the tenant endpoint." name="inUsername" required="true" type="string"/>
            <cc:parameter default="props['sskQueuePassword']" documentation="The password with which to authenticate to the tenant endpoint." name="inPassword" required="true" type="string"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:out-parameter documentation="The REST resource id of the next message on the queue to be fetched." name="outMessageId"/>
            <cc:out-parameter documentation="The REST URI of the message to facilitate reading" name="outMessageURI"/>
        </cc:local-in>
        <cc:async-mediation id="Teardown_123">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                        <cc:remove-header name="X-Tenant"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localURI']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_123" routes-to="Teardown_123"/>
        <cc:local-out id="Call_HandleError_QueueResults_123" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Result Error'"/>
            <cc:set name="inLogMessageDetail" value="props['inQueueName'] # ' was not found executing endpoint ' # props['inEndpoint'] # '/ccx/wd-queue/'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_123'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="QueueResults_123">
            <cc:steps>
                <cc:validate-xpath id="ValidateXpath" xpath="/*:queues/*:queue[*:name = &quot;@{props['inQueueName']}&quot;]"/>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outPollURI'] = parts[0].xpath('/*:queues/*:queue[*:name = &quot;'# props['inQueueName'] #'&quot;]/*:poll-uri');&#xD;
props['outMessageCount'] = parts[0].xpath('/*:queues/*:queue[*:name = &quot;'# props['inQueueName'] #'&quot;]/*:message-count');</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_QueueResults_123"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_REST_QueueStatusResponse_123" store-message="none" execute-when="props['inDebugMode']" routes-response-to="QueueResults_123" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__QueueStatistics'"/>
        </cc:local-out>
        <cc:http-out id="CallQueue_123" store-message="none" routes-response-to="Call_Debug_REST_QueueStatusResponse_123" endpoint="@{props['localURI']}" http-method="GET">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_QueueStatusRequest_123" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallQueue_123" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_123" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Query Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while querying the Message Queue for statistics.  See Support Data for more information.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_123'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'GetQueues_ErrorResponse'"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_123" routes-to="Call_Debug_REST_QueueStatusRequest_123" handle-downstream-errors="true" routes-response-to="Call_Finally_123">
            <cc:request-steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="X-Tenant" value="@{props['cc.customer.id']}"/>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="SetValues">
                    <cc:expression>props['localURI'] = props['inEndpoint'] # '/ccx/wd-queue/'</cc:expression>
                    <cc:expression>props['outPollURI'] = '';&#xD;
props['outMessageCount'] = 0;</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_123"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_123" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_123"/>
        <cc:local-in id="GetQueues" routes-to="InitializeAndFinalize_123" icon="icons/GetQueues.png">
            <cc:parameter default="props['sskQueueEndpoint']" documentation="The tenant endpoint at which the Message Queue REST API may be found." name="inEndpoint" required="true" type="string"/>
            <cc:parameter default="props['sskQueueName']" documentation="The name of the queue for which to return the polling URI." name="inQueueName" required="true" type="string"/>
            <cc:parameter default="props['sskQueueUsername']" documentation="The username with which to authenticate to the tenant endpoint." name="inUsername" required="true" type="string"/>
            <cc:parameter default="props['sskQueuePassword']" documentation="The password with which to authenticate to the tenant endpoint." name="inPassword" required="true" type="string"/>
            <cc:parameter default="props['sskIsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:out-parameter documentation="The relative Uniform Resource Identifier of the queue" name="outPollURI"/>
            <cc:out-parameter documentation="The number of messages currently on the queue for processing." name="outMessageCount"/>
        </cc:local-in>
        <cc:local-out id="Call_Debug_BlockSplitResults_116" store-message="none" execute-when="props['inDebugMode']" routes-response-to="ValidateBlockSplitResults_116" endpoint="vm://INT006_Greenhouse_Inbound/Debug" clone-request="true">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SSK116_BlockSplitResults.xml'"/>
        </cc:local-out>
        <cc:local-out id="Call_ParallelSubroutine_116" store-message="none" endpoint="vm://wcc/ParallelSubroutine">
            <cc:set name="parallel.processing.aggregation.endpoint" value="props['inAggregationEndpoint']"/>
            <cc:set name="parallel.processing.worker.endpoint" value="props['inProcessEndpoint']"/>
            <cc:set name="parallel.processing.worker.count" value="props['inParallelThreadCount']"/>
            <cc:set name="parallel.processing.worker.timeout" value="props['inParallelThreadTimeout']"/>
            <cc:set name="parallel.processing.timeout" value="props['inParallelSplitterTimeout']"/>
            <cc:set name="parallel.processing.splitter" value="spring.getBean('SSK116BlockSplitter')"/>
        </cc:local-out>
        <cc:route id="RouteSplit_116">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inIsUseParallel'] &amp;&amp; props['localIsBlocks']" route="Parallel"/>
                <cc:choose-route expression="true" route="Serial"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Parallel" routes-to="Call_ParallelSubroutine_116"/>
            <cc:sub-route name="Serial" routes-to="StoreOutput_116"/>
        </cc:route>
        <cc:route id="RouteParallelism_115">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inIsUseOrderedAggregation']" route="Serial"/>
                <cc:choose-route expression="true" route="Parallel"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Parallel" routes-to="PrepareFileResults_Parallel_115"/>
            <cc:sub-route name="Serial" routes-to="PrepareFileResults_Serial_115"/>
        </cc:route>
        <cc:async-mediation id="PrepareFileResults_Serial_115" routes-to="RouteFileCount_Serial_115">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localLabels'] = 'Data - Partial' # (props['inRetrievalDocTag'] == empty ? '' : ', ' # props['inRetrievalDocTag'])</cc:expression>
                    <cc:expression>props['localFileCount'] = da.size(org.apache.commons.lang3.StringUtils.split(props.localLabels, ','));</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteFileCount_Serial_115">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['localFileCount'] &lt; 1" route="NoFiles"/>
                <cc:choose-route expression="true" route="Files"/>
            </cc:mvel-strategy>
            <cc:sub-route name="NoFiles" routes-to="Call_CreateLogEntry_NoFiles_Info_115"/>
            <cc:sub-route name="Files" routes-to="Call_Debug_Property_115"/>
        </cc:route>
        <cc:local-out id="Call_Aggregate_Append_115" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/AggregateSerial_115">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="LoadFile_115" routes-to="Call_Aggregate_Append_115">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" input="variable" input-variable="wd.retrieve.variable"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_Variable_115" store-message="none" execute-when="props['inDebugMode']" routes-response-to="LoadFile_115" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'wd.retrieve.variable'"/>
            <cc:set name="inEntityName" value="'DIS_Partial_File'"/>
        </cc:local-out>
        <cc:route id="RetrieveFiles_115">
            <cc:doc-iterator labels="@{props['localLabels']}" sort-by="FILENAME_ASCENDING"/>
            <cc:sub-route name="Route" routes-to="Call_Debug_Variable_115"/>
        </cc:route>
        <cc:local-out id="Call_Debug_Property_115" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_AggregateSerialized_115" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localLabels'"/>
        </cc:local-out>
        <cc:local-in id="OrderedAggregation_115" routes-to="RetrieveFiles_115"/>
        <cc:local-out id="Call_AggregateSerialized_115" store-message="none" routes-response-to="Call_Aggregate_Finalize_115" endpoint="vm://INT006_Greenhouse_Inbound/OrderedAggregation_115"/>
        <cc:local-out id="Call_Aggregate_Finalize_115" store-message="none" routes-response-to="Call_Debug_Message_115" endpoint="vm://INT006_Greenhouse_Inbound/AggregateSerial_115">
            <cc:set name="inCollate" value="false"/>
            <cc:set name="inBatch" value="true"/>
        </cc:local-out>
        <cc:aggregator id="AggregateFileSerial_115" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="message" output-mimetype="text/xml" xpath="*/*">
        <cc:header-text>&lt;DISRoot xmlns:tdf=&quot;urn:com.workday/tdf&quot;></cc:header-text>
        <cc:footer-text>&lt;/DISRoot></cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-in id="AggregateSerial_115" routes-to="AggregateFileSerial_115">
            
            
        <cc:parameter default="true" name="inCollate" required="true" type="boolean"/><cc:parameter default="false" name="inBatch" required="true" type="boolean"/></cc:local-in>
        <cc:route id="RouteThread_Message_144">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inIsChildThreadContext']" route="Child"/>
                <cc:choose-route expression="true" route="Parent"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Child" routes-to="GetMessageFragment_144"/>
            <cc:sub-route name="Parent" routes-to="Call_Aggregate_Message_144"/>
        </cc:route>
        <cc:route id="RouteThread_Variable_144">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inIsChildThreadContext']" route="Child"/>
                <cc:choose-route expression="true" route="Parent"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Child" routes-to="GetVariableFragment_144"/>
            <cc:sub-route name="Parent" routes-to="Variable_InitializeAndFinalize_Parent_144"/>
        </cc:route>
        <cc:async-mediation id="GetMessageFragment_144" routes-to="Call_CreateLogEntryOnThread_Debug_Message_144">
            <cc:steps>
                <cc:custom id="Custom" ref="SSK144DebugBean"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_Message_144" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'Message RootPart'"/>
            <cc:set name="inLogMessageDetail" value="'Message root part initial fragment (up to 10 KB) saved in the Support Data field (full data may not be available if exceeds 10 KB)'"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="util.cleanString(props['sskFileBackedManagedDataDebugFragment']) "/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_Property_144" store-message="none" execute-when="props['inIsChildThreadContext']" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'Property ' # props['inTargetName']"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_Properties_144" store-message="none" execute-when="props['inIsChildThreadContext']" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="props['localKey144']"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:route id="RouteProperties_144">
            <cc:loop-strategy condition="props['localCounter144'] &lt; props[props.inTargetName].size()" increment="props['localCounter144'] = props['localCounter144'] + 1" init="props['localCounter144'] = 0"/>
            <cc:sub-route name="Log" routes-to="MessageValues_Properties_144"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntry_Debug_Properties_144" store-message="none" execute-when="!props['inIsChildThreadContext']" routes-response-to="Call_CreateLogEntryOnThread_Debug_Properties_144" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="props['localKey144']"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_Variable_144" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'Variable ' # props['inTargetName']"/>
            <cc:set name="inLogMessageDetail" value="'Variable initial fragment (up to 10 KB) saved in the Support Data field (full data may not be available if exceeds 10 KB)'"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="util.cleanString(props['sskFileBackedManagedDataDebugFragment']) "/>
        </cc:local-out>
        <cc:async-mediation id="GetVariableFragment_144" routes-to="Call_CreateLogEntryOnThread_Debug_Variable_144">
            <cc:steps>
                <cc:custom id="Custom" ref="SSK144DebugBean"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteMap_144">
            <cc:loop-strategy condition="props['localCounter144'] &lt; props['localKeys144'].size()" increment="props['localCounter144'] = props['localCounter144'] + 1" init="props['localCounter144'] = 0"/>
            <cc:sub-route name="Log" routes-to="MessageValues_Map_144"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_Map_144" store-message="none" execute-when="props['inIsChildThreadContext']" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="props[props.inTargetName] # '/' # props['localKey144']"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:async-mediation id="GetMapKeys_144" routes-to="RouteMap_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localKeys144'] = com.workday.custom.int006.ssk144.DebugBean.getIterableList(context, props.inTargetName);</cc:expression>
                    <cc:expression>props['localCollection144'] = props[props.inTargetName];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteList_144">
            <cc:loop-strategy condition="props['localCounter144'] &lt; props['localKeys144'].size()" increment="props['localCounter144'] = props['localCounter144'] + 1" init="props['localCounter144'] = 0"/>
            <cc:sub-route name="Log" routes-to="MessageValues_List_144"/>
        </cc:route>
        <cc:async-mediation id="GetListKeys_144" routes-to="RouteList_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localKeys144'] = props[props.inTargetName];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_List_144" store-message="none" execute-when="props['inIsChildThreadContext']" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="props.inTargetName # ' Element ' # String.valueOf(props.localCounter144)"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:async-mediation id="GetSetKeys_144" routes-to="RouteSet_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localKeys144'] = com.workday.custom.int006.ssk144.DebugBean.getIterableList(context, props.inTargetName);</cc:expression>
                    <cc:expression>props['localCollection144'] = props[props.inTargetName];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteSet_144">
            <cc:loop-strategy condition="props['localCounter144'] &lt; props['localKeys144'].size()" increment="props['localCounter144'] = props['localCounter144'] + 1" init="props['localCounter144'] = 0"/>
            <cc:sub-route name="Log" routes-to="MessageValues_Set_144"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_Set_144" store-message="none" execute-when="props['inIsChildThreadContext']" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="props.inTargetName # ' Element ' # String.valueOf(props.localCounter144)"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_Set_144" store-message="none" execute-when="!props['inIsChildThreadContext']" routes-response-to="Call_CreateLogEntryOnThread_Debug_Set_144" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="props.inTargetName # ' Element ' # String.valueOf(props.localCounter144)"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntryOnThread_Warn_Finalize_144" store-message="none" execute-when="props['inIsChildThreadContext']" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'Invalid Debug Target on Child Thread'"/>
            <cc:set name="inLogMessageDetail" value="'The &quot;finalize&quot; target is invalid to be used when executing the Debug component on a child thread.'"/>
            <cc:set name="inLogLevel" value="'warn'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntryOnThread_Warn_Undefined_144" store-message="none" execute-when="props['inIsChildThreadContext']" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'Undefined Debug Log'"/>
            <cc:set name="inLogMessageDetail" value="'RouteType_144 was not able to correctly process the inTargetType input parameter.'"/>
            <cc:set name="inLogLevel" value="'warn'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:async-mediation id="MessageValues_Property_144" routes-to="Call_CreateLogEntry_Debug_Property_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localValue144'] = com.workday.custom.int006.ssk144.DebugBean.getPropertyTargetValue(context, props.inTargetName);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="MessageValues_Properties_144" routes-to="Call_CreateLogEntry_Debug_Properties_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localKey144'] = com.workday.custom.int006.ssk144.DebugBean.getPropertiesTargetKey(props[props.inTargetName], props.localCounter144);</cc:expression>
                    <cc:expression>props['localValue144'] = com.workday.custom.int006.ssk144.DebugBean.getPropertyTargetValue(context, props.localKey144);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="MessageValues_Map_144" routes-to="Call_CreateLogEntry_Debug_Map_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localKey144'] = props['localKeys144'].get(props.localCounter144);</cc:expression>
                    <cc:expression>props['localValue144'] = com.workday.custom.int006.ssk144.DebugBean.getMapTargetValue(context, props.localCollection144, props.localKey144);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="MessageValues_List_144" routes-to="Call_CreateLogEntry_Debug_List_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localValue144'] = com.workday.custom.int006.ssk144.DebugBean.getPropertiesTargetKey(props['localKeys144'], props.localCounter144);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="MessageValues_Set_144" routes-to="Call_CreateLogEntry_Debug_Set_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localKey144'] = props['localKeys144'].get(props.localCounter144);</cc:expression>
                    <cc:expression>props['localValue144'] = com.workday.custom.int006.ssk144.DebugBean.getItemValue(props.localKey144);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_Warn_101" store-message="none" routes-response-to="InitializeAndFinalize_Property_101" endpoint="vm://INT006_Greenhouse_Inbound/CreateLogEntry"><cc:set name="inLogMessage" value="'SSK Component Usage Warning'"/><cc:set name="inLogMessageDetail" value="'SSK101 AddReportPromptFromProperty should not be used to build report prompts'"/><cc:set name="inLogLevel" value="'warn'"/><cc:set name="inExtraLocalIn" value="'AddReportPromptFromProperty'"/><cc:set name="inExtraSupportData" value="'While the component is functional, it is not the most-performant way to build prompts for a RaaS report.  AddReportPromptFromProperty serves as a guide and example to illustrate how to build a report prompt map for SSK102 ReadDataFromRaaS.  However, all prompts can easily be added in a single Eval step and save the overhead of validation and multiple mediation steps in the component.  This overhead is compounded when multiple prompts are needed.'"/></cc:local-out>
        <cc:local-out id="Call_Debug_SoapXslt_113" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inBuildRequestPathToXsltFile'"/>
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_Transform_Error_113" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Transformation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a SOAP service call.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_113'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inBuildRequestPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inBuildRequestPathToXsltFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inBuildRequestPathToXsltFile'], '/') :&#xD;&#xA;&#x9;props['inBuildRequestPathToXsltFile']"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            
        </cc:local-out>
        <cc:async-mediation id="Transform_Handler_113" routes-to="Call_HandleError_Transform_Error_113">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Transform_113" routes-to="Call_Debug_SoapXslt_113">
            <cc:steps>
                <cc:xslt-plus id="WriteSoap" input="message" url="@{props['inBuildRequestPathToXsltFile']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Transform_Handler_113"/>
        </cc:async-mediation>
        <cc:async-mediation id="PreparePropertyInput_113" routes-to="Transform_113">
            <cc:steps>
                <cc:write id="PrimeMessage">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;Root/></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Property_113" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleBuildRequestValidationError_113">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Property_113" routes-to="PreparePropertyInput_113">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>propname = props['inBuildRequestDataLocationId'];&#xD;
props['localIsValueDefined'] = context.containsProperty(propname);&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (context.getProperty(propname) instanceof java.util.Map) &amp;&amp; !(((java.util.Map)(context.getProperty(propname))).isEmpty());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="11304" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, a context property named [@{props.inBuildRequestDataLocationId}] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="11305" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, the referenced context property named [@{props.inBuildRequestDataLocationId}] was not an instance of a java.util.Map, or that Map was empty.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Property_113"/>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareVariableInput_113" routes-to="Transform_113">
            <cc:steps>
                <cc:eval id="PrimeMessage">
                    <cc:expression>varname = props['inBuildRequestDataLocationId'];&#xD;
parts[0] = vars[varname].source;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Variable_113" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleBuildRequestValidationError_113">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Variable_113" routes-to="PrepareVariableInput_113">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>varname = props['inBuildRequestDataLocationId'];&#xD;
props['localIsValueDefined'] = (vars.isVariable(varname)) &amp;&amp; (vars[varname] != null);&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (vars[varname].isXml());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="11302" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, a message variable named [@{props.inBuildRequestDataLocationId}] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="11303" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, the referenced message variable named [@{props.inBuildRequestDataLocationId}] was not valid XML data.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Variable_113"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Message_113" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleBuildRequestValidationError_113">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Message_113" routes-to="Transform_113">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>props['localIsValueDefined'] = parts[0] != empty;&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (parts[0].isXml());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="11300" failure-message="Message part[0] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="11301" failure-message="Message part[0] was not valid XML data.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Message_113"/>
        </cc:async-mediation>
        <cc:route id="RouteInputSource_113">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inBuildRequestDataLocation'].trim().toLowerCase() == 'message'" route="Message"/>
                <cc:choose-route expression="props['inBuildRequestDataLocation'].trim().toLowerCase() == 'variable'" route="Variable"/>
                <cc:choose-route expression="true" route="Property"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Message" routes-to="Validation_Message_113"/>
            <cc:sub-route name="Variable" routes-to="Validation_Variable_113"/>
            <cc:sub-route name="Property" routes-to="Validation_Property_113"/>
        </cc:route>
        <cc:local-in id="BuildRequest_113" routes-to="RouteInputSource_113">
            <cc:parameter default="props['inApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter default="props['inBuildRequestPathToXsltFile']" documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;." name="inBuildRequestPathToXsltFile" required="true" type="string"/>
            <cc:parameter default="props['inBuildRequestDataLocation']" documentation="The java.util.Map instance that holds the key/value pairs of values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapVariableName.  The transform will define pre-established keys for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inBuildRequestDataLocation" required="false" type="string"/>
            <cc:parameter default="context.containsProperty('inBuildRequestDataLocationId') ? props['inBuildRequestDataLocationId'] : null" documentation="The name of the context variable that holds the data values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapPropertyName.  The XML stored in the variable must be compatible with the XSLT provided on inPathToXsltFile.  See aUnit tests for a generic example of a multi-iteration, multi-variable example." name="inBuildRequestDataLocationId" required="false" type="string"/>
            <cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="props['inIsAbortOnError']" name="inIsAbortOnError" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_HandleError_Validation_Error_113" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Validation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while validating parameters for a SOAP service call.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_113'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Handler_113" routes-to="Call_HandleError_Validation_Error_113">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="HandleBuildRequestValidationError_113" routes-to="Validation_Handler_113"/>
        <cc:local-out id="Call_Debug_Child_141" store-message="none" execute-when="props['inIncludeDebugOutput'] &amp;&amp; props['inTargetType'] != empty" routes-response-to="Handler_141" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="props['inTargetType']"/>
            <cc:set name="inTargetName" value="props['inTargetName']"/>
            <cc:set name="inEntityName" value="props['inEntityName']"/>
        <cc:set name="inIsChildThreadContext" value="true"/></cc:local-out>
        <cc:local-out id="Call_Debug_FilteredDocuments_110" store-message="none" execute-when="props['inDebugMode']" routes-response-to="RouteOnCount_110" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'Get_Event_Documents_Filtered'"/>
        </cc:local-out>
        <cc:async-mediation id="Teardown_122">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                        <cc:remove-header name="X-Tenant"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localURI']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_122" routes-to="Teardown_122"/>
        <cc:local-out id="Call_HandleError_QueueResults_122" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Result Error'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="props['inEndpoint'] # '/ccx/wd-queue/'"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_122'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="QueueResults_122">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outPollURI'] = parts[0].xpath('/*:queues/*:queue[*:name = &quot;'# props['inQueueName'] #'&quot;]/*:poll-uri');</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_QueueResults_122"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_REST_QueueStatusResponse_122" store-message="none" execute-when="props['inDebugMode']" routes-response-to="RouteQueueExists_122" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__QueueStatistics'"/>
        </cc:local-out>
        <cc:http-out id="CallQueue_122" store-message="none" routes-response-to="Call_Debug_REST_QueueStatusResponse_122" endpoint="@{props['localURI']}" http-method="GET">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_QueueStatusRequest_122" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallQueue_122" endpoint="vm://INT006_Greenhouse_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_122" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Query Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while querying the Message Queue for statistics.  See Support Data for more information.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_122'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'GetQueues_ErrorResponse'"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_122" routes-to="Call_Debug_REST_QueueStatusRequest_122" handle-downstream-errors="true" routes-response-to="Call_Finally_122">
            <cc:request-steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="X-Tenant" value="@{props['cc.customer.id']}"/>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="SetValues">
                    <cc:expression>props['localURI'] = props['inEndpoint'] # '/ccx/wd-queue/'</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_122"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_122" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_122"/>
        <cc:local-in id="CreateQueue" routes-to="InitializeAndFinalize_122" icon="icons/CreateQueue.png">
            <cc:parameter default="props['sskQueueEndpoint']" documentation="The tenant endpoint at which the Message Queue REST API may be found." name="inEndpoint" required="true" type="string"/>
            <cc:parameter default="props['sskQueueName']" documentation="The name of the queue for which to return the polling URI." name="inQueueName" required="true" type="string"/>
            <cc:parameter default="props['sskQueueUsername']" documentation="The username with which to authenticate to the tenant endpoint." name="inUsername" required="true" type="string"/>
            <cc:parameter default="props['sskQueuePassword']" documentation="The password with which to authenticate to the tenant endpoint." name="inPassword" required="true" type="string"/>
            <cc:parameter default="props['sskIsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['sskIsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:out-parameter documentation="The fully-qualified Uniform Resource Identifier of the queue" name="outPollURI"/>
            
        </cc:local-in>
        <cc:route id="RouteQueueExists_122">
            <cc:mvel-strategy>
                <cc:choose-route expression="parts[0].xpathB('/*:queues/*:queue[*:name = &quot;'# props['inQueueName'] #'&quot;]')" route="ReturnQueue"/>
                <cc:choose-route expression="true" route="CreateQueue"/>
            </cc:mvel-strategy>
            <cc:sub-route name="ReturnQueue" routes-to="QueueResults_122"/>
            <cc:sub-route name="CreateQueue" routes-to="CreateCatch_122"/>
        </cc:route>
        <cc:local-out id="Call_HandleError_CreateQueue_122" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Result Error'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="props['inEndpoint'] # '/ccx/wd-queue/' # props['inQueueName']"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_122'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="CreateCatch_122" routes-to="CreateQueue_122" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CreateQueue_122"/>
        </cc:async-mediation>
        <cc:http-out id="CreateQueue_122" store-message="none" routes-response-to="CreateResults_122" endpoint="@{props['localURI']}@{props['inQueueName']}" http-method="PUT">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_HandleError_CreateResults_122" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Result Error'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="props['inEndpoint'] # '/ccx/wd-queue/'"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT006_Greenhouse_Inbound/Finally_122'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="CreateResults_122">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outPollURI'] = parts[0].xpath('/*:queue/*:poll-uri');</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CreateResults_122"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Finally_127" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Finally_127"/>
        <cc:route id="AllMessages_128">
            <cc:loop-strategy condition="props['localIsContinueLoop']"/>
            <cc:sub-route name="CheckQueue" routes-to="CallQueue_128"/>
        </cc:route>
        <cc:async-mediation id="EvaluateQueue_128" routes-to="SplitMessages_128">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['localIsContinueLoop'] = ((parts[0].xpath('/*:messages/@*:returned-count')) != (parts[0].xpath('/*:messages/@*:total-count')));</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_DeleteMessage_128" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/DeleteMessage_128">
            
            
            
        </cc:local-out>
        <cc:local-in id="DeleteMessage_128" routes-to="CatchDequeueErrors_128">
            
            
            
        </cc:local-in>
        <cc:local-out id="HandleError_CustomLogic" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'An unhandled error occurred within the custom integration flow.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
        	<cc:set name="inFinallyEndpoint"/>
        	<cc:set name="inIsAbortOnError" value="false"/>
        	<cc:set name="inIsResetError" value="false"/>
        	<cc:set name="inIncludeDebugOutput" value="false"/>
        	<cc:set name="inLogTarget" value="'primary'"/>
        	<cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        
        <cc:local-out id="GoToFindApplicant" store-message="none" routes-response-to="WhenApplicantExist" endpoint="vm://INT006_Greenhouse_Inbound/FindApplicant"/>
        <cc:async-mediation id="WhenApplicantExist" routes-to="GoToPutApplic" execute-steps-when="props['outApplicantsID'] != empty">
            <cc:steps>
                <cc:eval id="SetApplicantsID"><cc:expression>props['applicantID'] = props['outApplicantsID']</cc:expression></cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="JSONtoXMLError" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'An unhandled error occurred within the custom integration flow.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inFinallyEndpoint"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="'primary'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        <cc:set name="is.message.detail" value="context.errorMessage"/></cc:local-out>
        <cc:local-in id="PutApplicant" routes-to="GoToProcessCountryReport"/>
        <cc:async-mediation id="BuildRequest" routes-to="HireEmployee" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="Eval">
                    <cc:expression>props['costCenter']=props['costCenterHashmap'].get(props['jobRequisitionID'])</cc:expression>
                    <cc:expression>//props['customOrganization']=props['customOrganizationHashmap'].get(props['jobRequisitionID'])</cc:expression>
                    <cc:expression>props['compensationGrade']=props['compGradeHashmap'].get(props['jobRequisitionID'])</cc:expression>
                    <cc:expression>props['compensationPackage']=props['compPackageHashmap'].get(props['jobRequisitionID'])</cc:expression>
                    <cc:expression>props['company']=props['companyHashMap'].get(props['jobRequisitionID'])</cc:expression>
                </cc:eval>
                <cc:xslt-plus id="HireRequest" output="message" input="variable" input-variable="var.jsonFile" url="Hire_Request.xsl"/>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="HandleError_BuildHireRequestError"/>
        </cc:async-mediation>
        <cc:local-in id="Hire" routes-to="GoToProcessJobReqReport"/>
        <cc:local-out id="GoToHire" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/Hire"/>
        <cc:async-mediation id="BuildRequest0" routes-to="Put_Applicant">
            <cc:steps>
                <cc:eval id="Eval">
                    <cc:expression>props['applicantCountryId']=props['countryHashmap'].get(props['locationId'])</cc:expression>
                </cc:eval>
                <cc:xslt-plus id="XsltPlus" input="variable" input-variable="var.jsonFile" url="Put_New_Applicant_Request.xsl"/>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="PutApplicantBuildRequestError"/>
        </cc:async-mediation>
        <cc:local-out id="GoToPutApplic" store-message="none" execute-when="props['outApplicantsID'] == empty" routes-response-to="GoToHire" endpoint="vm://INT006_Greenhouse_Inbound/PutApplicant"/>
        <cc:local-out id="HandleError_BuildHireRequestError" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'An unhandled error occurred within the custom integration flow.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inFinallyEndpoint"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="'primary'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:local-out id="PutApplicantBuildRequestError" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'An unhandled error occurred within the custom integration flow.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inFinallyEndpoint"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="'primary'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="GetHireEvent" routes-to="PutHireEvent">
            <cc:steps>
                <cc:eval id="SetOutParameters">
                    <cc:expression>props['prefix'] = 'bsvc urn:com.workday/bsvc'</cc:expression><cc:expression>props['outHireEvent'] = parts[0].xpath('/env:Envelope/env:Body/bsvc:Hire_Employee_Event_Response/bsvc:Event_Reference/bsvc:ID[@wd:type = &quot;WID&quot;]', props['prefix'])</cc:expression></cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="PutHireEvent" endpoint="vm://wcc/PutIntegrationMessage" clone-request="true">
            <cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="'Hire Initiated ' # props['outHireEvent']"/>
        </cc:local-out>
        <cc:local-out id="PutIntegrationMessage00" endpoint="vm://wcc/PutIntegrationMessage" clone-request="true">
            <cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="'Pre-Hire created with ID ' # props['applicantID']"/>
        </cc:local-out>
        <cc:local-out id="GetEventDocuments" routes-response-to="InitializeAttributesAndLaunchParameters" endpoint="vm://wcc/GetEventDocuments"><cc:set name="ie.event.wid" value="lp.isSet() ? lp.getIntegrationEventWID() : null"/></cc:local-out>
        <cc:local-out id="GoToProcessJobReqReport" store-message="none" routes-response-to="GoToProcessCountryReport0" endpoint="vm://INT006_Greenhouse_Inbound/INProcessJobreqReport"/>
        <cc:async-mediation id="AsyncMediation11" routes-to="IsEmployee">
            <cc:steps>
                <cc:json-to-xml id="JsonToXml" output="message" input="variable" input-variable="webhookFile"/>
                <cc:copy id="Copy" output="variable" output-variable="var.jsonFile" input="message"/>
                <cc:eval id="SetParameters">
                    <cc:expression>props['applicantID']=parts[0].xpath('/root/data/payload/application/candidate/id')</cc:expression>
                    <cc:expression>props['firstName']=parts[0].xpath('/root/data/payload/application/candidate/first_name')</cc:expression>
                    <cc:expression>props['lastName']=parts[0].xpath('/root/data/payload/application/candidate/last_name')</cc:expression>
                    <cc:expression>props['hiringSource']=parts[0].xpath('/root/data/payload/application/source/name')</cc:expression>
                    <cc:expression>props['allowances']=parts[0].xpath('/root/data/payload/application/offer/custom_fields/allowances/value')</cc:expression>
                    <cc:expression>props['frequencyOfPay'] = parts[0].xpath('/root/data/payload/application/offer/custom_fields/frequency_of_pay/value')</cc:expression>
                    <cc:expression>props['jobProfileId']=parts[0].xpath('/root/data/payload/application/job/custom_fields/job_profile_id/value')</cc:expression>
                    <cc:expression>props['locationId']=parts[0].xpath('/root/data/payload/application/offer/custom_fields/work_location/external_id')</cc:expression>                    
                    <cc:expression>props['salary_curr'] = parts[0].xpath('/root/data/payload/application/offer/custom_fields/base_pay_amount/value/unit')</cc:expression>                   
                    <cc:expression>props['salary_amt'] = parts[0].xpath('/root/data/payload/application/offer/custom_fields/base_pay_amount/value/amount')</cc:expression>
                    <cc:expression>props['homeEmailPublic'] = parts[0].xpath('/root/data/payload/application/candidate/email_addresses/data/value')</cc:expression>
                    <cc:expression>props['GHHireReason'] = parts[0].xpath('/root/data/payload/application/offer/custom_fields/hire_reason/value')</cc:expression>
                    <cc:expression>if (props['HireType']=='Rehire') {&#xD;
props['isRehire']='true' &#xD;
} else {&#xD;
props['isRehire']='false'&#xD;
}</cc:expression>
                    <cc:expression>props['employeeID'] = parts[0].xpath('/root/data/payload/application/offer/custom_fields/employee_id/value')</cc:expression>
                    <cc:expression>props['homeEmailAddress']=parts[0].xpath('/root/data/payload/application/candidate/last_name')</cc:expression>
                    <cc:expression>props['citizenship']=parts[0].xpath('/root/data/payload/application/candidate/custom_fields/citizenship/external_id')</cc:expression>
                    <cc:expression>props['attachmentFile'] = parts[0].xpath('/root/data/payload/application/candidate/attachments/data[type=&quot;signed_offer_letter&quot;]/url')</cc:expression>
                    <cc:expression>props['attachedFileName'] = parts[0].xpath('/root/data/payload/application/candidate/attachments/data[type=&quot;signed_offer_letter&quot;]/filename')</cc:expression>
                    <cc:expression>props['positionID']=parts[0].xpath('/root/data/payload/application/opening/opening_id')</cc:expression>
                    <cc:expression>if(props['GHHireReason']== 'New Hire') {&#xD;
 props['HireType'] = 'New_Hire'&#xD;
} else if (props['GHHireReason'] == 'Rehire'){&#xD;
	props['HireType'] = 'Rehire'&#xD;
} else if (props['GHHireReason'] == 'Internal Transfer'){&#xD;
	props['HireType'] = 'Conversion'&#xD;
} else{&#xD;
	 props['HireType'] = 'New_Hire'&#xD;
}</cc:expression>
                    <cc:expression>props['time_type_GH']=parts[0].xpath('/root/data/payload/application/job/custom_fields/time_type/value')</cc:expression>
                    <cc:expression>props['worker_sub_type_GH']=parts[0].xpath('/root/data/payload/application/job/custom_fields/worker_sub_type/value')</cc:expression>
                    <cc:expression>props['pay_rate_type_GH']=parts[0].xpath('/root/data/payload/application/offer/custom_fields/pay_rate_type/value')</cc:expression>
                    <cc:expression>props['employment_type_GH']=parts[0].xpath('/root/data/payload/application/offer/custom_fields/employment_type/value')</cc:expression>
                    <cc:expression>props['department_GH'] = parts[0].xpath('/root/data/payload/application/job/departments/data/external_id')</cc:expression>
                    <cc:expression>props['phoneNumber'] = parts[0].xpath('/root/data/payload/application/candidate/phone_numbers/data/value')</cc:expression>
                    <cc:expression>props['Social_Security_Number']=parts[0].xpath('/root/data/payload/application/candidate/custom_fields/social_security_number_candidate_1653321224.5887396/value')</cc:expression>
                    <cc:expression>props['forskrivarkod_ID']=parts[0].xpath('/root/data/payload/application/candidate/custom_fields/forskrivarkod_candidate_1661434080.8754494/value')</cc:expression>
                </cc:eval>
                
                <cc:eval id="EvaluateParameters">
                    <cc:expression>props['emailPersonalType'] = 'Home'</cc:expression>
                    <cc:expression>if (props['time_type_GH'] == 'Full Time'){&#xD;
	props['time_type_GH']=props['time_type_GH'].toString().replace(&quot; &quot;, &quot;_&quot;)&#xD;
} else {&#xD;
	props['time_type_GH']=props['time_type_GH'].toString().replace(&quot; &quot;, &quot;_&quot;)&#xD;
}</cc:expression>
                    <cc:expression>props['emailWorkType'] = 'Work' </cc:expression>
                    <cc:expression>//props['sourceId']=intsys.integrationMapReverseLookup('Source', props['hiringSource'], true).toString().replaceAll(&quot;[\\[\\]]&quot;,&quot;&quot;)</cc:expression>
                    <cc:expression>//props['sourceIdMapped'] = true</cc:expression>
                    <cc:expression>//if (parts[0].xpath('/root/data/payload/application/opening') == 'null') {&#xD;
	props['jobRequisitionID']=parts[0].xpath('/root/data/payload/application/job/requisition_id')&#xD;
//} else {&#xD;
	//props['jobRequisitionID']=parts[0].xpath('/root/data/payload/application/opening/opening_id')&#xD;
</cc:expression>
                    <cc:expression>if(props['employeeID'] != 'null' and props['employeeID'] != ''){&#xD;
	props['emplIdExists'] = true&#xD;
}else{&#xD;
	props['emplIdExists'] = false&#xD;
}</cc:expression>
                    <cc:expression>props['outApplicantsIDExists']= false</cc:expression>
                    <cc:expression>props['outApplicantsID'] = ''</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="JSONtoXMLError"/>
        </cc:async-mediation>
        <cc:local-out id="GoToProcessCountryReport" store-message="none" routes-response-to="BuildRequest0" endpoint="vm://INT006_Greenhouse_Inbound/InProcessCountryReport"/>
        <cc:local-in id="INProcessJobreqReport" routes-to="AsyncMediation000"/>
        <cc:async-mediation id="AsyncMediation000" routes-to="JobReqReport" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="SetProps">
                    <cc:expression>props['compGradeHashmap'] = new java.util.HashMap</cc:expression>
                    <cc:expression>props['compPackageHashmap'] = new java.util.HashMap</cc:expression>
                    <cc:expression>props['costCenterHashmap'] = new java.util.HashMap</cc:expression>
                     <cc:expression>props['companyHashMap'] = new java.util.HashMap</cc:expression>
                    <cc:expression>props['namespace']='wd urn:com.workday.report/INT006_JobRequisitions'</cc:expression>
                </cc:eval>
                <cc:cloud-log id="CloudLog" message="Calling Job Requistions report"/>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="HandleError_JobReqReportError"/>
        </cc:async-mediation>
        <cc:local-out id="HandleError_JobReqReportError" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'An unhandled error occurred within the custom integration flow.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inFinallyEndpoint"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="'primary'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:workday-out-rest id="JobReqReport" routes-response-to="Splitter00" extra-path="@{intsys.reportService.getExtrapath('int006_JobReq')}?format=xml&amp;Include_Evergreen_Requisitions=0&amp;referenceID=@{props['jobRequisitionID']}" method="GET"/>
        <cc:splitter id="Splitter00">
            <cc:sub-route name="SubRoute" routes-to="CreateHashmaps00"/>
            <cc:xml-stream-splitter namespaces="wd urn:com.workday.report/INT006_JobRequisitions" xpath="/wd:Report_Data/wd:Report_Entry"/>
        </cc:splitter>
        <cc:async-mediation id="CreateHashmaps00">
            <cc:steps>
                <cc:eval id="Eval">
                    <cc:expression>props['jobReqId'] = parts[0].xpath('/wd:Report_Entry/wd:JobReqID', props['namespace'])</cc:expression>
                    <cc:expression>props['costCenterId'] = parts[0].xpath('/wd:Report_Entry/wd:Cost_Center_ID/wd:ID[@wd:type = &quot;Cost_Center_Reference_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['marketOrgID'] = parts[0].xpath('/wd:Report_Entry/wd:Market/wd:ID[@wd:type = &quot;Custom_Organization_Reference_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['costCenterHashmap'].put(props['jobReqId'],props['costCenterId'])</cc:expression>
                    <cc:expression>props['jobReqLocation'] = parts[0].xpath('/wd:Report_Entry/wd:Primary_Location/wd:ID[@wd:type = &quot;Location_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>if (props['jobReqLocation'] != props['locationId']) {&#xD;
props['isLocationChange'] = true&#xD;
} else {&#xD;
props['isLocationChange'] = false&#xD;
}</cc:expression>
                    <cc:expression>props['payRateType'] = parts[0].xpath('/wd:Report_Entry/wd:Pay_Rate_Type/wd:ID[@wd:type = &quot;Pay_Rate_Type_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['workShift'] = parts[0].xpath('/wd:Report_Entry/wd:Work_Shift/wd:ID[@wd:type = &quot;Work_Shift_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['jobProfileId'] =   parts[0].xpath('/wd:Report_Entry/wd:Job_Profile_Hiring_Requirement_group/wd:JobProfileId/wd:ID[@wd:type = &quot;Job_Profile_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['jobPostingTitle'] =   parts[0].xpath('/wd:Report_Entry/wd:Job_Posting_Title', props['namespace'])</cc:expression>
                    <cc:expression>props['compGradeId'] = parts[0].xpath('/wd:Report_Entry/wd:Compensation_Grade/wd:ID[@wd:type = &quot;Compensation_Grade_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['compPackageId'] = parts[0].xpath('/wd:Report_Entry/wd:Compensation_Package/wd:ID[@wd:type = &quot;Compensation_Package_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['compGradeProfileId'] = parts[0].xpath('/wd:Report_Entry/wd:Compensation_Grade_Profile/wd:ID[@wd:type = &quot;Compensation_Grade_Profile_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['compGradeHashmap'].put(props['jobReqId'],props['compGradeId'])</cc:expression>
                    <cc:expression>props['compPackageHashmap'].put(props['jobReqId'],props['compPackageId'])</cc:expression>
                    <cc:expression>props['targetHireDate'] = parts[0].xpath('/wd:Report_Entry/wd:Target_Hire_Date', props['namespace'])</cc:expression>
                    <cc:expression>props['targetEndDate'] = parts[0].xpath('/wd:Report_Entry/wd:Target_End_Date', props['namespace'])</cc:expression>
                    <cc:expression>props['hireDate'] = props['targetHireDate'].toString().substring(0, 10)</cc:expression>
                    <cc:expression>if(props['targetEndDate'] != null and  props['targetEndDate'] != ''){&#xD;
	props['endDate' ] = props['targetEndDate'].toString().substring(0, 10)&#xD;
}</cc:expression>
                    <cc:expression>props['jobReqScheduledWeeklyHours'] = parts[0].xpath('/wd:Report_Entry/wd:Scheduled_Weekly_Hours', props['namespace'])</cc:expression>
                    <cc:expression>props['jobReqSalaryFreqPlan'] = parts[0].xpath('/wd:Report_Entry/wd:Requisition_Salary_Plan_Assignments_group/Plan_Frequency/wd:ID[@wd:type = &quot;Frequency_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['DepartmentOrgID'] = parts[0].xpath('/wd:Report_Entry/wd:Department/wd:ID[@wd:type = &quot;Custom_Organization_Reference_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['BusinessUnitOrgID'] = parts[0].xpath('/wd:Report_Entry/wd:BusinessUnit/wd:ID[@wd:type = &quot;Custom_Organization_Reference_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['ProductOrgID'] = parts[0].xpath('/wd:Report_Entry/wd:Product/wd:ID[@wd:type = &quot;Custom_Organization_Reference_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['areaOrgID'] = parts[0].xpath('/wd:Report_Entry/wd:AreaR_D/wd:ID[@wd:type = &quot;Custom_Organization_Reference_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['teamOrgID'] = parts[0].xpath('/wd:Report_Entry/wd:TeamR_D/wd:ID[@wd:type = &quot;Custom_Organization_Reference_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['functionOrgID'] = parts[0].xpath('/wd:Report_Entry/wd:FunctionR_D/wd:ID[@wd:type = &quot;Custom_Organization_Reference_ID&quot;]/text()', props['namespace']) </cc:expression>
                    <cc:expression>props['supOrg'] = parts[0].xpath('/wd:Report_Entry/wd:Supervisory_Organization/wd:ID[@wd:type = &quot;Organization_Reference_ID&quot;]/text()', props['namespace']) </cc:expression>
                    <cc:expression>props['companyID'] = parts[0].xpath('/wd:Report_Entry/wd:Company/wd:ID[@wd:type = &quot;Company_Reference_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['companyHashMap'].put(props['jobReqId'],props['companyID'])</cc:expression>
                    <cc:expression>props['fullOrPartTime'] =parts[0].xpath('/wd:Report_Entry/wd:Time_Type_Hiring_Requirement/wd:ID[@wd:type = &quot;Position_Time_Type_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['employeeType'] =parts[0].xpath('/wd:Report_Entry/wd:Worker_Sub-Type_Hiring_Requirement/wd:ID[@wd:type = &quot;Employee_Type_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['jobReqFreq'] = parts[0].xpath('/wd:Report_Entry/wd:Range_Frequency/wd:ID[@wd:type = &quot;Frequency_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['jobReqSalaryCompPlan'] = parts[0].xpath('/wd:Report_Entry/wd:Requisition_Salary_Plan_Assignments_group/wd:Compensation_Plan/wd:ID[@wd:type = &quot;Compensation_Plan_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['jobReqHourlyFreqPlan'] = parts[0].xpath('/wd:Report_Entry/wd:Requisition_Hourly_Plan_Assignments_group/Plan_Frequency/wd:ID[@wd:type = &quot;Frequency_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['jobReqHourlyCompPlan'] = parts[0].xpath('/wd:Report_Entry/wd:Requisition_Hourly_Plan_Assignments_group/wd:Compensation_Plan/wd:ID[@wd:type = &quot;Compensation_Plan_ID&quot;]/text()', props['namespace'])</cc:expression>
                    <cc:expression>props['defaultJobTitle'] =   parts[0].xpath('/wd:Report_Entry/wd:Job_Profile_Hiring_Requirement_group/wd:Default_Job_Title', props['namespace'])</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="JobReqResultsError"/>
        </cc:async-mediation>
        <cc:local-out id="JobReqResultsError" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'An unhandled error occurred within the custom integration flow.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inFinallyEndpoint"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="'primary'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        
        <cc:local-in id="INProcessHireReason" routes-to="AsyncMediationHirereason"/>
        <cc:async-mediation id="AsyncMediationHirereason" routes-to="HireReason" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="SetProps">
                    <cc:expression>props['namespace']='wd urn:com.workday.report/INT006_Reasons'</cc:expression>
                </cc:eval>
                <cc:cloud-log id="CloudLog" message="Calling Hire&#xD;&#xA;"/>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="HandleError_HireReasonRequest"/>
        </cc:async-mediation>
        <cc:workday-out-rest id="HireReason" routes-response-to="SplitterHireReason" extra-path="@{intsys.reportService.getExtrapath('int006_Reasons')}?format=xml&amp;referenceID=@{java.net.URLEncoder.encode(props['HireType'],'UTF-8')}" method="GET"/>
        <cc:splitter id="SplitterHireReason">
            <cc:sub-route name="SubRoute" routes-to="CreateHashmaps0"/>
            <cc:xml-stream-splitter namespaces="wd urn:com.workday.report/INT006_Reasons" xpath="/wd:Report_Data/wd:Report_Entry/wd:SubCategory"/>
        </cc:splitter>
        <cc:async-mediation id="CreateHashmaps0">
            <cc:steps>
                <cc:eval id="Eval0">
                    <cc:expression>props['hireReasonId'] = parts[0].xpath('/wd:SubCategory/wd:referenceID', props['namespace'])</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="HandleError_CustomLogicHireReason"/>
        </cc:async-mediation>
        <cc:local-out id="HandleError_CustomLogicHireReason" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Error in Hire reason report.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inFinallyEndpoint"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="'primary'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:local-out id="HandleError_HireReasonRequest" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'An unhandled error occurred within the custom integration flow.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inFinallyEndpoint"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="'primary'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:local-out id="GoToProcessHireReasonReport" store-message="none" routes-response-to="BuildRequest" endpoint="vm://INT006_Greenhouse_Inbound/INProcessHireReason"/>
        <cc:local-out id="GoToProcessCountryReport0" store-message="none" execute-when="props['countryName'] == empty" routes-response-to="GoToProcessHireReasonReport" endpoint="vm://INT006_Greenhouse_Inbound/InProcessCountryReport"/>
        <cc:async-mediation id="CheckIfInactiveWorkerExists" routes-to="Get_Workers" execute-steps-when="props['emplIdExists']">
            <cc:steps>
                <cc:write execute-when="props['emplIdExists']" id="CreateRequest">
                    <cc:message>
                        <cc:text>&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:bsvc=&quot;urn:com.workday/bsvc&quot;>&#xD;
   &lt;soapenv:Header>&#xD;
    &#xD;
   &lt;/soapenv:Header>&#xD;
   &lt;soapenv:Body>&#xD;
      &lt;bsvc:Get_Workers_Request bsvc:version=&quot;@{props['globalApiVersion']}&quot;>&#xD;
         &lt;!--Optional:-->&#xD;
         &lt;bsvc:Request_References>&#xD;
            &lt;!--1 or more repetitions:-->&#xD;
            &lt;bsvc:Worker_Reference>&#xD;
               &lt;!--Zero or more repetitions:-->&#xD;
               &lt;bsvc:ID bsvc:type=&quot;Employee_ID&quot;>@{props['employeeID']}&lt;/bsvc:ID>&#xD;
            &lt;/bsvc:Worker_Reference>&#xD;
         &lt;/bsvc:Request_References>&#xD;
         &lt;!--Optional:-->&#xD;
      &#xD;
        &#xD;
      &lt;/bsvc:Get_Workers_Request>&#xD;
   &lt;/soapenv:Body>&#xD;
&lt;/soapenv:Envelope></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="CheckIfInactiveWorkerExistsError"/>
        </cc:async-mediation>
        <cc:workday-out-soap id="Get_Workers" execute-when="props['emplIdExists']" routes-response-to="ValidateGeWorkersResponse" application="Staffing" version="@{props['globalApiVersion']}"/>
        <cc:async-mediation id="ValidateGeWorkersResponse" routes-to="FindExistingApplicant" continue-after-error="rewind" execute-steps-when="props['emplIdExists']">
            <cc:steps>
                <cc:validate-exp id="InActiveWorkerFound">
                    <cc:expression failure-message="More than one applicant with the given e-mail address exists. Consider checking e-mail typos or deactivating duplicate applicants. Sought applicant: @{props['firstName']} @{props['lastName']}; @{props['applicantID']}">parts[0].xpath('/env:Envelope/env:Body/wd:Get_Workers_Response/wd:Response_Data/wd:Worker/wd:Worker_Data/wd:Employment_Data/wd:Worker_Status_Data/wd:Active') != 1</cc:expression>
                </cc:validate-exp>
                <cc:eval id="Eval">
                    <cc:expression>props['workerActive'] = parts[0].xpath('/env:Envelope/env:Body/wd:Get_Workers_Response/wd:Response_Data/wd:Worker/wd:Worker_Data/wd:Employment_Data/wd:Worker_Status_Data/wd:Active')</cc:expression>
                    <cc:expression>props['getWorkerFirstName'] = parts[0].xpath('/env:Envelope/env:Body/wd:Get_Workers_Response/wd:Response_Data/wd:Worker/wd:Worker_Data/wd:Personal_Data/wd:Name_Data/wd:Legal_Name_Data/wd:Name_Detail_Data/wd:First_Name')</cc:expression>
                    <cc:expression>props['getWorkerLastName'] = parts[0].xpath('/env:Envelope/env:Body/wd:Get_Workers_Response/wd:Response_Data/wd:Worker/wd:Worker_Data/wd:Personal_Data/wd:Name_Data/wd:Legal_Name_Data/wd:Name_Detail_Data/wd:Last_Name')</cc:expression>
                    <cc:expression>if(props['workerActive'] != 1){&#xD;
 props['isRehire'] = true&#xD;
}else if(props['workerActive'] == 1 and ((props['getWorkerFirstName'] != props['firstName']) or (props['getWorkerLastName'] != props['lastName']) )){&#xD;
	 props['isRehire'] = true&#xD;
}else{&#xD;
	 props['isRehire'] = false&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="FindExistingApplicant" routes-to="Get_Applicant" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
                <cc:write execute-when="props['isRehire'] == true and props['emplIdExists'] == true" id="CreateRequestByEmployeeID">
                    <cc:message>
                        <cc:text>&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:bsvc=&quot;urn:com.workday/bsvc&quot;>&#xD;
   &lt;soapenv:Header/>&#xD;
   &lt;soapenv:Body>&#xD;
      &lt;bsvc:Get_Applicants_Request bsvc:version=&quot;@{props['globalApiVersion']}&quot;>          &#xD;
      &lt;bsvc:Request_Criteria>  &#xD;
           &lt;bsvc:Worker_Reference>             &#xD;
               &lt;bsvc:ID bsvc:type=&quot;Employee_ID&quot;>@{props['employeeID']}&lt;/bsvc:ID>&#xD;
            &lt;/bsvc:Worker_Reference>     &#xD;
         &lt;/bsvc:Request_Criteria>      &#xD;
         &lt;bsvc:Response_Group>&#xD;
            &lt;bsvc:Include_Reference>true&lt;/bsvc:Include_Reference>&#xD;
            &lt;bsvc:Include_Personal_Information>true&lt;/bsvc:Include_Personal_Information>            &#xD;
         &lt;/bsvc:Response_Group>&#xD;
      &lt;/bsvc:Get_Applicants_Request>&#xD;
   &lt;/soapenv:Body>&#xD;
&lt;/soapenv:Envelope>&#xD;
</cc:text>
                    </cc:message>
                </cc:write>
                <cc:write execute-when="props['isRehire'] == false and props['emplIdExists'] == false" id="CreateRequest">
                    <cc:message>
                        <cc:text>&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:bsvc=&quot;urn:com.workday/bsvc&quot;>&#xD;
   &lt;soapenv:Header/>&#xD;
   &lt;soapenv:Body>&#xD;
      &lt;bsvc:Get_Applicants_Request bsvc:version=&quot;@{props['globalApiVersion']}&quot;>       &#xD;
      &lt;bsvc:Request_Criteria>  &#xD;
            &lt;bsvc:Email_Address>@{props['homeEmailPublic']}&lt;/bsvc:Email_Address>          &#xD;
         &lt;/bsvc:Request_Criteria>      &#xD;
         &lt;bsvc:Response_Group>&#xD;
            &lt;bsvc:Include_Reference>true&lt;/bsvc:Include_Reference>&#xD;
            &lt;bsvc:Include_Personal_Information>true&lt;/bsvc:Include_Personal_Information>            &#xD;
         &lt;/bsvc:Response_Group>&#xD;
      &lt;/bsvc:Get_Applicants_Request>&#xD;
   &lt;/soapenv:Body>&#xD;
&lt;/soapenv:Envelope>&#xD;
</cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="FindApplicantError"/>
        </cc:async-mediation>
        <cc:local-out id="FindApplicantError" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Error checking existing applicant.' # props['applicantID'] # props['outApplicantsID']"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inFinallyEndpoint"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="'primary'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:local-out id="CheckIfInactiveWorkerExistsError" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Error checking active worker exists.' # props['applicantID'] # props['outApplicantsID']"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inFinallyEndpoint"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="'primary'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:workday-out-soap id="Get_Applicant" routes-response-to="ValidateGetApplicantsResponse" application="Staffing" version="@{props['globalApiVersion']}"/>
        <cc:async-mediation id="ValidateGetApplicantsResponse" routes-to="PrepareFindApplicantResult" continue-after-error="rewind">
            <cc:steps>
                <cc:validate-exp id="OneOrNoApplicantsFound">
                    <cc:expression failure-message="More than one applicant with the given e-mail address exists. Consider checking e-mail typos or deactivating duplicate applicants. Sought applicant: @{props['firstName']} @{props['lastName']}; @{props['applicantID']}">parts[0].xpath('count(/env:Envelope/env:Body/wd:Get_Applicants_Response/wd:Response_Data/wd:Applicant)') &lt;= 1</cc:expression>
                </cc:validate-exp>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareFindApplicantResult" continue-after-error="rewind" execute-steps-when="parts[0].xpath('/env:Envelope/env:Body/wd:Get_Applicants_Response/wd:Response_Data').isEmpty() == false">
            <cc:steps>
                <cc:eval id="SetOutParameters"><cc:expression>props['outApplicantsID'] = parts[0].xpath('/env:Envelope/env:Body/wd:Get_Applicants_Response/wd:Response_Data/wd:Applicant/wd:Applicant_Reference/wd:ID[@wd:type = &quot;Applicant_ID&quot;]/text()')</cc:expression>
                    <cc:expression>props['outApplicantsIDExists'] = true</cc:expression></cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="FindApplicant" routes-to="CheckIfInactiveWorkerExists"/>
        <cc:local-in id="InProcessCountryReport" routes-to="CreateHashmap"/>
        <cc:async-mediation id="CreateHashmap" routes-to="CountryReport" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="SetProps">
                    <cc:expression>props['countryHashmap'] = new java.util.HashMap</cc:expression>
                    <cc:expression>props['namespace']='wd urn:com.workday.report/INT006_Country'</cc:expression>
                </cc:eval>
                <cc:cloud-log id="CloudLog" message="Calling Country Report&#xD;&#xA;"/>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="CountryReportPropsError"/>
        </cc:async-mediation>
        <cc:workday-out-rest id="CountryReport" routes-response-to="Splitter0" extra-path="@{intsys.reportService.getExtrapath('int006_Country')}?Location_Usages_for_Location!WID=46db411c4a5245fbb39834d8b2cba049&amp;referenceID=@{java.net.URLEncoder.encode(props['locationId'],'UTF-8')}&amp;format=xml" method="GET"/>
        <cc:splitter id="Splitter0">
            <cc:sub-route name="SubRoute" routes-to="BuildHashmaps0"/>
            <cc:xml-stream-splitter namespaces="wd urn:com.workday.report/INT006_Country" xpath="/wd:Report_Data/wd:Report_Entry"/>
        </cc:splitter>
        <cc:async-mediation id="BuildHashmaps0">
            <cc:steps>
                <cc:eval id="Eval">
                    <cc:expression>props['locationRefId'] = parts[0].xpath('/wd:Report_Entry/wd:location_ReferenceId', props['namespace'])</cc:expression>
                    <cc:expression>props['countryId'] = parts[0].xpath('/wd:Report_Entry/wd:country/wd:referenceID', props['namespace'])</cc:expression>
                    <cc:expression>props['countryName']=parts[0].xpath('/wd:Report_Entry/wd:country/wd:Country_Name', props['namespace'])</cc:expression>
                    <cc:expression>props['countryHashmap'].put(props['locationRefId'],props['countryId'])</cc:expression>
                    <cc:expression>if (props['countryName'] == 'United States of America') {&#xD;
props['countryName'] = 'USA'&#xD;
}</cc:expression>
                    <cc:expression>props['scheduledWeeklyHours']=parts[0].xpath('/wd:Report_Entry/wd:Scheduled_Weekly_Hours', props['namespace'])</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="CountryReportResultsError"/>
        </cc:async-mediation>
        <cc:local-out id="CountryReportPropsError" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'An unhandled error occurred within the custom integration flow.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inFinallyEndpoint"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="'primary'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:local-out id="CountryReportResultsError" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Error in country report.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inFinallyEndpoint"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="'primary'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:workday-out-soap id="Put_Applicant" routes-response-to="AsyncMediation0" application="Staffing" version="@{props['globalApiVersion']}"/>
        <cc:workday-out-soap id="HireEmployee" routes-response-to="GetHireEvent" application="Staffing" version="@{props['globalApiVersion']}"/>
        <cc:http-out id="HttpOut" store-message="both" execute-when="props['attachmentFile'] != null and props['attachmentFile'] != '' " routes-response-to="AsyncMediation" endpoint="@{props['attachmentFile']}" http-method="GET">
        </cc:http-out>
        <cc:async-mediation id="AsyncMediation" routes-to="GoToFindApplicant" execute-steps-when="props['attachmentFile'] != null and props['attachmentFile'] != ''">
            <cc:steps>
                <cc:base64-encode id="Base64Encode" output="variable" output-variable="var.EncodedFile"/>
                <cc:eval id="Eval">
                    <cc:expression>props['p.ExtensionLocation'] = props['attachedFileName'].lastIndexOf(&quot;.&quot;) + 1</cc:expression>
                    <cc:expression>props['p.FileExtension'] = props['attachedFileName'].substring(props['p.ExtensionLocation']).toLowerCase()</cc:expression>
                    <cc:expression>props['p.ContentType'] = 'application/' # props['p.FileExtension']</cc:expression>
                    <cc:expression>props['p.EncodedFile'] = vars['var.EncodedFile'].text</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="AsyncMediation0" routes-to="PutIntegrationMessage00">
            <cc:steps>
                <cc:eval id="Eval">
                    <cc:expression>props['prefix'] = 'bsvc urn:com.workday/bsvc'</cc:expression>
                    <cc:expression>props['applicantID'] = parts[0].xpath('/env:Envelope/env:Body/bsvc:Put_Applicant_Response/bsvc:Applicant_Reference/bsvc:ID[@wd:type = &quot;Applicant_ID&quot;]', props['prefix'])</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="IsEmployee">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['employment_type_GH'] == 'Employee'" route="Employee"/>
                <cc:choose-route expression="props['employment_type_GH'] != 'Employee'" route="ContingentWorker"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Employee" routes-to="HttpOut"/>
            <cc:sub-route name="ContingentWorker" routes-to="NotEmployeeError"/>
        </cc:route>
        <cc:local-out id="NotEmployeeError" store-message="none" endpoint="vm://INT006_Greenhouse_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Candidate is not an employee: ' # props['applicantID'] "/>
            
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inFinallyEndpoint"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="'primary'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
            <cc:set name="is.message.detail" value="context.errorMessage"/>
        </cc:local-out>
	</cc:assembly>
    <bean id="SSK115FileSplitter" class="com.workday.custom.int006.ssk115.ParallelBlockSplitter">
        <property name="blockSize" value="1"/>
    </bean>
    <bean id="SSK109InitializeCore" class="com.workday.custom.int006.ssk109.CoreInitializationBean" scope="prototype"/>
    <bean id="SSK102SoapAuthorBean" class="com.workday.custom.int006.ssk102.SoapAuthorBean" scope="prototype"/>
    <bean id="SSK116BlockSplitter" class="com.workday.custom.int006.ssk116.ParallelBlockSplitter" scope="prototype">
        <property name="blockSize" value="1"/>
    </bean>
    <bean id="SSK144DebugBean" class="com.workday.custom.int006.ssk144.DebugBean" scope="prototype"/>

</beans>